head	1.2;
access;
symbols
	HOL97:1.2.2.1.0.2
	bpHOL97:1.2.2.1
	hol90_9_alpha:1.2.2.1
	hol90_pre8_for_multiple_compilers:1.2.0.2
	hol90_pre8_after_donalds_separate_compilation_changes:1.2
	hol90_8_after_merging_Konrad_Elsa:1.2
	hol90_7_cleaned_up_original_branchtag:1.1.1.1.0.2
	hol90_7_cleaned_up_original:1.1.1.1
	hol90_7_cleaned_up_original:1.1.1;
locks; strict;
comment	@# @;


1.2
date	95.10.17.17.06.09;	author drs1004;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	95.10.16.13.33.31;	author rjb;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.16.13.33.31;	author rjb;	state Exp;
branches;
next	;

1.2.2.1
date	96.08.23.11.12.50;	author rjb;	state Exp;
branches
	1.2.2.1.2.1;
next	;

1.2.2.1.2.1
date	97.06.11.18.48.48;	author kxs;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Keeping you up to date:

I'm about to do a checkin of elsa's modifications to the hol90.7
sources to create her hol90.pre8.  To recap what I've done:
	- I checked out hol90 (in /usr/groups/hol/drs1004/hol90)
		cvs co hol90
	  (Well, to be honest, I only checked out those
	  parts of hol90 I knew I'd be changing, e.g. not the
	  Manual, and only parts of the library.  Checking out the
	  entire source takes a while, mainly due to the enormous number
	  of help files.  The limiting factor is files/second, which
         runs at around 5 when CVS is working on nfs over a network, not
         KB/second, which you might at first think it would be).

	- By doing a recursive diff between Elsa's source and the
	hol90.7 source I found all the changes Elsa had made to
	source files.  I copied relevant files from Elsa's source
	into my checked out version.  The only new files were
		- the sml_system files in src/0
		- some make scripts in src/.
	Changed files were in:
		src/{0,1,2,3}
		library/arith/src/thm_convs.sml
		library/list/src/list_conv1.sml
		library/num/src/num_lib.sml
		library/prog_logic/src/halts_logic.sml
		library/prog_logic/src/translation.sml
		library/prog_logic/theories/src/mk_halts.sml
		library/real/theories/src/Make
		library/real/theories/src/equiv.sml
		library/real/theories/src/seq.sml
		library/reduce/src/arithconv.sml
		library/string/src/string_conv.sml
		library/unity/theories/src/aux_definitions.sml
		library/word/theories/src/*

	- I will now commit these changes, with this email as the log message.
		cvs commit

	- Tomorrow I will get this version compiling
	with NJSML 108 (I will probably add
	the files to enable the NJSML compilation manager to make
	this easier), then check those changes in.  I think it's
	good to get things in a working state.
@
text
@(* ===================================================================== *)
(* FILE: mk_bword_bitop.ml	    DATE: 14 Aug 1992			*)
(* AUTHOR: Wai WONG  	    	    					*)
(* TRANSLATOR: Paul Curzon  1 June 1993, September 1994			*)
(* Writes: bword_bitop.th	    	    				*)
(* Uses: Libraries: more_lists res_quan					*)
(* Description: Creates a theorey for boolean word bitwise operations	*)
(* ===================================================================== *)
(* PC 18/11/93: SEG ->WSEG *)

val path = 
   "../"^Globals.theory_file_type^"/"

val _ = theory_path := path::(!theory_path);


local
fun delete_theory name = 
    Sml_system.system("/bin/rm -f "^name^".thms "^name^".holsig")
in
  val _ = delete_theory (path^"bword_bitop")
end;


load_theory "word_bitop";
load_library{lib = res_quan_lib, theory = "bword_bitop"};


Add_to_sml.add_theory_to_sml "word_base";
Add_to_sml.add_theory_to_sml "word_bitop";

val word_CASES_TAC =
    let val cthm = (theorem "word_base" "word_cases")
    in
       (fn w => CHOOSE_THEN SUBST1_TAC (ISPEC w cthm))
    end;

val word_INDUCT_TAC = 
    let val ithm = theorem "word_base" "word_induct"
    in
     (INDUCT_THEN ithm (fn t => ALL_TAC))
    end;

val RESQ_WORDLEN_TAC = 
    (CONV_TAC RESQ_FORALL_CONV THEN word_INDUCT_TAC
     THEN PURE_ONCE_REWRITE_TAC[definition "word_base" "PWORDLEN_DEF"]
     THEN GEN_TAC THEN DISCH_TAC);


(* --------------------------------------------------------------------- *)
(* We begin with some lemmas about lists. They are used in the proofs.	*)
(* --------------------------------------------------------------------- *)

val MAP2_SNOC = prove(
    (--`!(f:'a->'b->'c) h1 h2 l1 l2. (LENGTH l1 = LENGTH l2) ==>
     (MAP2 f(SNOC h1 l1)(SNOC h2 l2) = SNOC(f h1 h2)(MAP2 f l1 l2))`--),
    GEN_TAC THEN GEN_TAC THEN GEN_TAC THEN EQ_LENGTH_INDUCT_TAC THENL[
      REWRITE_TAC[SNOC,MAP2],
      REWRITE_TAC[LENGTH,INV_SUC_EQ,SNOC,MAP2,CONS_11]
      THEN REPEAT STRIP_TAC THEN RES_TAC]);

val BUTLASTN_MAP2 = prove(
    (--`!l1 l2. (LENGTH l1 = LENGTH l2) ==> !n. (n <= LENGTH l1) ==>
     !(f:'a->'b->'c).
      BUTLASTN n (MAP2 f l1 l2) = MAP2 f (BUTLASTN n l1) (BUTLASTN n l2)`--),
    let val lem1 = ARITH_PROVE (--`!n. n <= 0 ==> (n = 0)`--)
    in
    EQ_LENGTH_SNOC_INDUCT_TAC THENL[
      PURE_ONCE_REWRITE_TAC[LENGTH] THEN GEN_TAC
      THEN DISCH_THEN (SUBST1_TAC o (MATCH_MP lem1))
      THEN REWRITE_TAC[BUTLASTN,MAP2],
      INDUCT_TAC THEN REWRITE_TAC[BUTLASTN,MAP2_SNOC,LESS_EQ_MONO]
      THEN IMP_RES_THEN (fn t => PURE_REWRITE_TAC[t]) MAP2_SNOC
      THEN REWRITE_TAC[BUTLASTN] THEN DISCH_TAC THEN RES_TAC]
    end);

val LASTN_MAP2 = prove(
    (--`!l1 l2. (LENGTH l1 = LENGTH l2) ==> !n. (n <= LENGTH l1) ==>
     !(f:'a->'b->'c). 
      LASTN n (MAP2 f l1 l2) = MAP2 f (LASTN n l1) (LASTN n l2)`--),
    let val lem1 = ARITH_PROVE (--`!n. n <= 0 ==> (n = 0)`--) in
    EQ_LENGTH_SNOC_INDUCT_TAC THENL[
      GEN_TAC THEN PURE_ONCE_REWRITE_TAC[LENGTH]
      THEN DISCH_THEN (SUBST1_TAC o (MATCH_MP lem1))
      THEN REWRITE_TAC[LASTN,MAP2],
      INDUCT_TAC THEN REWRITE_TAC[LASTN,MAP2,LESS_EQ_MONO]
      THEN REPEAT STRIP_TAC THEN COND_REWRITE1_TAC MAP2_SNOC THENL[
    	COND_REWRITE1_TAC LENGTH_LASTN THEN TRY REFL_TAC
    	THEN FIRST_ASSUM (SUBST1_TAC o SYM)
    	THEN FIRST_ASSUM ACCEPT_TAC,
    	REWRITE_TAC[LASTN,SNOC_11] THEN RES_TAC
    	THEN FIRST_ASSUM MATCH_ACCEPT_TAC]]
    end);


(* --------------------------------------------------------------------- *)
(* WNOT	    	    	    	    					*)
(* --------------------------------------------------------------------- *)


val WNOT_DEF = new_recursive_definition {
 name = "WNOT_DEF",
 fixity = Prefix,
 rec_axiom = word_Ax,
 def = 
 --`
   WNOT (WORD l) = WORD((MAP $~) l)
 `--
 };

val BIT_WNOT_SYM_lemma = TAC_PROOF(([],
     (--`!n. !w:(bool)word ::PWORDLEN n. PWORDLEN n (WNOT w) /\
      !m k. ((m + k) <= n) ==> (WNOT(WSEG m k w) = WSEG m k (WNOT w))`--)),
    GEN_TAC THEN RESQ_WORDLEN_TAC THEN PURE_ASM_REWRITE_TAC
    	[PWORDLEN_DEF,WNOT_DEF,WSEG_DEF,LENGTH_MAP,WORD_11]
    THEN CONJ_TAC THENL[
      REFL_TAC,
      REPEAT GEN_TAC THEN DISCH_TAC
      THEN FIRST_ASSUM (ASSUME_TAC o CONJUNCT2 o (MATCH_MP LESS_EQ_SPLIT))
      THEN COND_REWRITE1_TAC BUTLASTN_MAP THENL[
    	IMP_RES_TAC LESS_EQ_SPLIT,
        COND_REWRITE1_TAC LASTN_MAP THENL[
          COND_REWRITE1_TAC LENGTH_BUTLASTN
          THEN COND_REWRITE1_TAC (GSYM ADD_LESS_EQ_SUB)
          THEN FIRST_ASSUM ACCEPT_TAC,
    	  REFL_TAC]]]);


(* PBITOP_WNOT = |- PBITOP WNOT *)

val PBITOP_WNOT = save_thm("PBITOP_WNOT",
    EQT_ELIM (TRANS (ISPEC (--`WNOT`--) PBITOP_DEF)
     (EQT_INTRO BIT_WNOT_SYM_lemma)));

val WNOT_WNOT = store_thm("WNOT_WNOT",
    (--`!w. WNOT(WNOT w) = w`--),
    word_INDUCT_TAC THEN PURE_REWRITE_TAC[WNOT_DEF]
    THEN LIST_INDUCT_TAC THEN REWRITE_TAC[MAP,WORD_11,CONS_11]
    THEN POP_ASSUM (ACCEPT_TAC o (REWRITE_RULE[WORD_11])));

val WCAT_WNOT = store_thm("WCAT_WNOT",
    (--`!n1 n2 . !w1:(bool)word::PWORDLEN n1. !w2:(bool)word::PWORDLEN n2.
     WCAT ((WNOT w1), (WNOT w2)) =  (WNOT (WCAT (w1,w2)))`--),
    REPEAT GEN_TAC THEN REPEAT RESQ_GEN_TAC
    THEN MAP_EVERY word_CASES_TAC [(--`w1:(bool)word`--), (--`w2:(bool)word`--)]
    THEN REWRITE_TAC[WCAT_DEF,WNOT_DEF,MAP_APPEND]);

val LENGTH_MAP22 = GEN_ALL (DISCH_ALL (CONJUNCT2 (SPEC_ALL (UNDISCH_ALL
    (SPEC_ALL LENGTH_MAP2)))));

(* --------------------------------------------------------------------- *)
(* WAND	    	    	    	    					*)
(* --------------------------------------------------------------------- *)
(* WAND_DEF = |- !l1 l2. WAND(WORD l1)(WORD l2) = WORD(MAP2 $/\ l1 l2) *)

val WAND_DEF = new_specification
 {name="WAND_DEF",
  consts= [{fixity= Infix 400,const_name="WAND"}],
  sat_thm = (ISPEC (--`$/\`--) PBITBOP_EXISTS)
};

val PBITBOP_WAND_lemma = prove(
    (--`!n. !w1:(bool)word ::PWORDLEN n. !w2:(bool)word ::PWORDLEN n.
     (PWORDLEN n (w1 WAND w2)) /\
     !m k. ((m + k) <= n) ==>
     ((WSEG m k w1) WAND (WSEG m k w2) = WSEG m k (w1 WAND w2))`--),
    GEN_TAC THEN REPEAT RESQ_WORDLEN_TAC
    THEN PURE_ASM_REWRITE_TAC[PWORDLEN_DEF,WAND_DEF,WORD_11,WSEG_DEF]
    THEN CONJ_TAC THENL[
     POP_ASSUM SUBST_ALL_TAC THEN MATCH_MP_TAC (GSYM LENGTH_MAP22)
     THEN FIRST_ASSUM ACCEPT_TAC,
     POP_ASSUM (fn t => RULE_ASSUM_TAC (TRANS (SYM t)))
     THEN REPEAT STRIP_TAC THEN COND_REWRITE1_TAC BUTLASTN_MAP2 THENL[
      FIRST_ASSUM (ACCEPT_TAC o SYM),
      FIRST_ASSUM (SUBST1_TAC o SYM) THEN IMP_RES_TAC LESS_EQ_SPLIT,
      COND_REWRITE1_TAC LASTN_MAP2 THENL[
       COND_REWRITE1_TAC LENGTH_BUTLASTN THENL[
        FIRST_ASSUM (SUBST1_TAC o SYM) THEN FIRST_ASSUM ACCEPT_TAC,
        FIRST_ASSUM SUBST1_TAC THEN REFL_TAC],
       COND_REWRITE1_TAC LENGTH_BUTLASTN
       THEN COND_REWRITE1_TAC (GSYM ADD_LESS_EQ_SUB)
       THEN FIRST_ASSUM SUBST1_TAC THEN FIRST_ASSUM ACCEPT_TAC,
       REFL_TAC]]]);

val PBITBOP_WAND = save_thm("PBITBOP_WAND",
    EQT_ELIM (TRANS (ISPEC (--`WAND`--) PBITBOP_DEF)
     (EQT_INTRO PBITBOP_WAND_lemma)));

(* --------------------------------------------------------------------- *)
(* WOR	    	    	    	    					*)
(* --------------------------------------------------------------------- *)
(* WOR_DEF = |- !l1 l2. WOR(WORD l1)(WORD l2) = WORD(MAP2 $\/ l1 l2)   *)

val WOR_DEF = new_specification
 {name="WOR_DEF",
  consts= [{fixity= Infix 300,const_name="WOR"}],
  sat_thm = (ISPEC (--`$\/`--) PBITBOP_EXISTS)
};

val PBITBOP_WOR_lemma = prove(
    (--`!n. !w1:(bool)word ::PWORDLEN n. !w2:(bool)word ::PWORDLEN n.
     (PWORDLEN n (w1 WOR w2)) /\
     !m k. ((m + k) <= n) ==>
     ((WSEG m k w1) WOR  (WSEG m k w2) = WSEG m k (w1 WOR w2))`--),
    GEN_TAC THEN REPEAT RESQ_WORDLEN_TAC
    THEN PURE_ASM_REWRITE_TAC[PWORDLEN_DEF,WOR_DEF,WORD_11,WSEG_DEF]
    THEN CONJ_TAC THENL[
     POP_ASSUM SUBST_ALL_TAC THEN MATCH_MP_TAC (GSYM LENGTH_MAP22)
     THEN FIRST_ASSUM ACCEPT_TAC,
     POP_ASSUM (fn t => RULE_ASSUM_TAC (TRANS (SYM t)))
     THEN REPEAT STRIP_TAC THEN COND_REWRITE1_TAC BUTLASTN_MAP2 THENL[
      FIRST_ASSUM (ACCEPT_TAC o SYM),
      FIRST_ASSUM (SUBST1_TAC o SYM) THEN IMP_RES_TAC LESS_EQ_SPLIT,
      COND_REWRITE1_TAC LASTN_MAP2 THENL[
       COND_REWRITE1_TAC LENGTH_BUTLASTN THENL[
        FIRST_ASSUM (SUBST1_TAC o SYM) THEN FIRST_ASSUM ACCEPT_TAC,
        FIRST_ASSUM SUBST1_TAC THEN REFL_TAC],
       COND_REWRITE1_TAC LENGTH_BUTLASTN
       THEN COND_REWRITE1_TAC (GSYM ADD_LESS_EQ_SUB)
       THEN FIRST_ASSUM SUBST1_TAC THEN FIRST_ASSUM ACCEPT_TAC,
       REFL_TAC]]]);

val PBITBOP_WOR = save_thm("PBITBOP_WOR",
    EQT_ELIM (TRANS (ISPEC (--`WOR`--) PBITBOP_DEF)
     (EQT_INTRO PBITBOP_WOR_lemma)));

(* --------------------------------------------------------------------- *)
(* WXOR	    	    	    	    					*)
(* --------------------------------------------------------------------- *)
(* |- !l1 l2. WXOR(WORD l1)(WORD l2) = WORD(MAP2(\x y. ~(x = y))l1 l2) *)

val WXOR_DEF = new_specification
 {name="WXOR_DEF",
  consts= [{fixity= Infix 300,const_name="WXOR"}],
  sat_thm = (ISPEC (--`(\x y:bool. ~(x = y))`--) PBITBOP_EXISTS)
};

val PBITBOP_WXOR_lemma = prove(
    (--`!n. !w1:(bool)word ::PWORDLEN n. !w2:(bool)word ::PWORDLEN n.
     (PWORDLEN n (w1 WXOR w2)) /\
     !m k. ((m + k) <= n) ==>
     ((WSEG m k w1) WXOR (WSEG m k w2) = WSEG m k (w1 WXOR w2))`--),
    GEN_TAC THEN REPEAT RESQ_WORDLEN_TAC
    THEN PURE_ASM_REWRITE_TAC[PWORDLEN_DEF,WXOR_DEF,WORD_11,WSEG_DEF]
    THEN CONJ_TAC THEN POP_ASSUM SUBST_ALL_TAC THENL[
     MATCH_MP_TAC (GSYM LENGTH_MAP22) THEN FIRST_ASSUM ACCEPT_TAC,
     REPEAT STRIP_TAC THEN COND_REWRITE1_TAC BUTLASTN_MAP2 THENL[
      FIRST_ASSUM (ACCEPT_TAC o SYM),
      FIRST_ASSUM (SUBST1_TAC o SYM) THEN IMP_RES_TAC LESS_EQ_SPLIT,
      COND_REWRITE1_TAC LASTN_MAP2 THENL[
       COND_REWRITE1_TAC LENGTH_BUTLASTN THENL[
        FIRST_ASSUM (SUBST1_TAC o SYM) THEN FIRST_ASSUM ACCEPT_TAC,
        FIRST_ASSUM SUBST1_TAC THEN REFL_TAC],
       COND_REWRITE1_TAC LENGTH_BUTLASTN THENL[
        COND_REWRITE1_TAC (GSYM ADD_LESS_EQ_SUB)
        THEN FIRST_ASSUM SUBST1_TAC THEN FIRST_ASSUM ACCEPT_TAC],
       REFL_TAC]]]);

val PBITBOP_WXOR = save_thm("PBITBOP_WXOR",
    EQT_ELIM (TRANS (ISPEC (--`WXOR`--) PBITBOP_DEF)
     (EQT_INTRO PBITBOP_WXOR_lemma)));

export_theory();

@


1.2.2.1
log
@Replaced uses of the structure Sml_system with Portable.
The structures Cond_rewrite and Res_quan are now opened where required.
@
text
@d19 1
a19 1
    Portable.system("/bin/rm -f "^name^".thms "^name^".holsig")
a27 1
open Cond_rewrite Res_quan;
@


1.2.2.1.2.1
log
@Changes to accomodate move to SML/NJ 109.26.
@
text
@d11 2
a12 1
val path = "../"^SysParams.theory_file_type^"/"
@


1.1
log
@Initial revision
@
text
@d19 1
a19 1
    System.system("/bin/rm -f "^name^".thms "^name^".holsig")
@


1.1.1.1
log
@Sources of hol90.7 as released, cleaned up by R.J.Boulton and D.R.Syme.

Summary of changes:

 * "contrib" directory not included
 * Machine-generatable files deleted, e.g. .dvi, .ps, .thms, .holsig, .hol_lib
 * Some directory restructuring in "library", in particular help files for
   ML functions have been put in a help/entries subdirectory in cases where
   they were originally in the help directory itself.
@
text
@@
