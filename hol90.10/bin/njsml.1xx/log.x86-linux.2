val it = () : unit
- GC #0.0.0.0.1.16:   (0 ms)
GC #0.0.0.1.2.40:   (30 ms)
GC #0.0.0.1.3.65:   (10 ms)
[opening /usr/groups/hol/hol90.10/src/2/sources.sml]
[opening ../theories/src/ld_BASIC_HOL.sml]

Loading theory "BASIC_HOL"

Theory "bool" already consistent with disk, hence not exported.
structure BASIC_HOL : sig end
val it = () : unit
[opening 2/rec_type_support.sig]
signature Rec_type_support_sig =
  sig
    structure Thm :
      sig
        structure Term : <sig>
        type thm
        val reset_thm_count : unit -> unit
        val counting_thms : bool -> unit
        val thm_count : unit
                        -> {ABS:int, ASSUME:int, BETA_CONV:int, DISCH:int,
                            INST_TYPE:int, MP:int, REFL:int, SUBST:int,
                            axiom:int, definition:int, drule:int,
                            from_disk:int, other:int, valid_tac:int}
        val hyp : thm -> Term.term list
        val concl : thm -> Term.term
        val dest_thm : thm -> Term.term list * Term.term
        val thm_free_vars : thm -> Term.term list
        val hyp_union : thm list -> Term.term list
        val pp_thm : ?.PrettyPrint.ppstream -> thm -> unit
        val thm_to_string : thm -> string
        val print_thm : thm -> unit
        val ASSUME : Term.term -> thm
        val REFL : Term.term -> thm
        val BETA_CONV : Term.term -> thm
        val SUBST : {thm:thm, var:Term.term} list -> Term.term -> thm -> thm
        val ABS : Term.term -> thm -> thm
        val INST_TYPE : Term.Type.hol_type subst -> thm -> thm
        val DISCH : Term.term -> thm -> thm
        val MP : thm -> thm -> thm
        val mk_axiom_thm : Term.term list * Term.term -> thm
        val mk_definition_thm : Term.term list * Term.term -> thm
        val mk_drule_thm : Term.term list * Term.term -> thm
        val mk_disk_thm : Term.term list * Term.term -> thm
        val mk_tac_thm : Term.term list * Term.term -> thm
        val mk_thm : Term.term list * Term.term -> thm
        datatype just_arg
          = JA_INT of int
          | JA_INTLIST of int list
          | JA_PAIR of just_arg * just_arg
          | JA_STRING of string
          | JA_TERM of Term.term
          | JA_THM of thm
          | JA_TYPE of Term.Type.hol_type
        datatype step = STEP of {Just:just_arg list, Name:string, Thm:thm}
        val record_step : (step -> thm) ref
        val record_proof : bool -> unit
        val suspend_recording : unit -> unit
        val resume_recording : unit -> unit
        val is_recording_proof : unit -> bool
        val note : step * thm -> thm
      end
    val prove_induction_thm : Thm.thm -> Thm.thm
    val prove_cases_thm : Thm.thm -> Thm.thm
    val prove_constructors_one_one : Thm.thm -> Thm.thm
    val prove_constructors_distinct : Thm.thm -> Thm.thm
  end
val it = () : unit
GC #0.0.0.1.4.140:   (10 ms)
GC #0.0.0.1.5.188:   (40 ms)
GC #0.0.0.1.6.225:   (30 ms)
GC #0.0.1.2.7.281:   (50 ms)
GC #0.0.1.2.8.310:   (20 ms)
GC #0.0.1.2.9.323:   (20 ms)
[opening 2/rec_type_support.sml]
2/rec_type_support.sml:763.8-763.57 Warning: binding not exhaustive
          {Args=_ :: ty :: nil,Tyop=_} = ...
2/rec_type_support.sml:758.29-759.69 Warning: match nonexhaustive
          (rul,eq :: eqs,nil) => ...
          (rul,eq :: eqs,h :: t) => ...
  
2/rec_type_support.sml:748.32-757.10 Warning: match nonexhaustive
          (rul,eq,eqs,nil,acc) => ...
          (rul,eq,heq :: eqrst,h :: t,acc) => ...
  
2/rec_type_support.sml:731.13-731.65 Warning: binding not exhaustive
          l :: r :: nil = ...
2/rec_type_support.sml:14.1-785.4 Warning: match nonexhaustive
          _ :: nil => ...
          h :: rst => ...
  
2/rec_type_support.sml:721.4-728.7 Warning: match nonexhaustive
          (h :: rst,t) => ...
  
2/rec_type_support.sml:610.23-611.59 Warning: match nonexhaustive
          (nil,nil) => ...
          (a :: L1,b :: L2) => ...
  
2/rec_type_support.sml:362.8-362.61 Warning: binding not exhaustive
          {Args=ty :: rty :: nil,Tyop=_} = ...
GC #0.0.1.2.10.394:   (30 ms)
GC #0.0.1.2.11.398:   (30 ms)
GC #0.0.1.2.12.434:   (20 ms)
GC #0.0.1.2.13.471:   (20 ms)
GC #0.0.1.2.14.499:   (40 ms)
GC #0.0.1.3.15.521:   (80 ms)
GC #0.0.1.3.16.553:   (10 ms)
GC #0.0.1.3.17.595:   (30 ms)
GC #0.0.1.3.18.634:   (0 ms)
GC #0.0.1.3.19.716:   (60 ms)
GC #0.0.1.3.20.800:   (60 ms)
GC #0.0.1.3.21.860:   (30 ms)
GC #0.1.2.4.22.904:   (190 ms)
GC #0.1.2.4.23.933:   (30 ms)
GC #0.1.2.4.24.938:   (30 ms)
GC #0.1.2.4.25.942:   (20 ms)
GC #0.1.2.4.26.944:   (20 ms)
GC #0.1.2.4.27.976:   (20 ms)
GC #1.2.3.5.28.1061:   (350 ms)
GC #1.2.3.5.29.1109:   (30 ms)
GC #1.2.3.6.30.1114:   (10 ms)
GC #1.2.3.6.31.1115:   (0 ms)
structure Rec_type_support : Rec_type_support_sig
val it = () : unit
[opening 2/num_induct.sig]
signature Num_induct_sig =
  sig
    structure Thm :
      sig
        structure Term : <sig>
        type thm
        val reset_thm_count : unit -> unit
        val counting_thms : bool -> unit
        val thm_count : unit
                        -> {ABS:int, ASSUME:int, BETA_CONV:int, DISCH:int,
                            INST_TYPE:int, MP:int, REFL:int, SUBST:int,
                            axiom:int, definition:int, drule:int,
                            from_disk:int, other:int, valid_tac:int}
        val hyp : thm -> Term.term list
        val concl : thm -> Term.term
        val dest_thm : thm -> Term.term list * Term.term
        val thm_free_vars : thm -> Term.term list
        val hyp_union : thm list -> Term.term list
        val pp_thm : ?.PrettyPrint.ppstream -> thm -> unit
        val thm_to_string : thm -> string
        val print_thm : thm -> unit
        val ASSUME : Term.term -> thm
        val REFL : Term.term -> thm
        val BETA_CONV : Term.term -> thm
        val SUBST : {thm:thm, var:Term.term} list -> Term.term -> thm -> thm
        val ABS : Term.term -> thm -> thm
        val INST_TYPE : Term.Type.hol_type subst -> thm -> thm
        val DISCH : Term.term -> thm -> thm
        val MP : thm -> thm -> thm
        val mk_axiom_thm : Term.term list * Term.term -> thm
        val mk_definition_thm : Term.term list * Term.term -> thm
        val mk_drule_thm : Term.term list * Term.term -> thm
        val mk_disk_thm : Term.term list * Term.term -> thm
        val mk_tac_thm : Term.term list * Term.term -> thm
        val mk_thm : Term.term list * Term.term -> thm
        datatype just_arg
          = JA_INT of int
          | JA_INTLIST of int list
          | JA_PAIR of just_arg * just_arg
          | JA_STRING of string
          | JA_TERM of Term.term
          | JA_THM of thm
          | JA_TYPE of Term.Type.hol_type
        datatype step = STEP of {Just:just_arg list, Name:string, Thm:thm}
        val record_step : (step -> thm) ref
        val record_proof : bool -> unit
        val suspend_recording : unit -> unit
        val resume_recording : unit -> unit
        val is_recording_proof : unit -> bool
        val note : step * thm -> thm
      end
    val INDUCT : Thm.thm * Thm.thm -> Thm.thm
    val INDUCT_TAC : tactic
  end
val it = () : unit
GC #1.2.3.6.32.1145:   (10 ms)
GC #1.2.3.6.33.1163:   (10 ms)
GC #1.2.3.6.34.1197:   (20 ms)
GC #1.2.3.6.35.1212:   (10 ms)
[opening 2/num_induct.sml]
structure Num_induct : Num_induct_sig
val it = () : unit
[opening 2/let_conv.sig]
signature Let_conv_sig =
  sig
    val PAIRED_BETA_CONV : conv
    val let_CONV : conv
    val PAIRED_ETA_CONV : conv
    val GEN_BETA_CONV : conv
  end
val it = () : unit
GC #1.2.3.6.36.1300:   (20 ms)
GC #1.2.4.7.37.1345:   (20 ms)
[opening 2/let_conv.sml]
2/let_conv.sml:251.8-251.58 Warning: binding not exhaustive
          {Args=ty1 :: ty2 :: nil,Tyop=_} = ...
2/let_conv.sml:89.8-89.55 Warning: binding not exhaustive
          (fv,xv :: yv :: nil) = ...
2/let_conv.sml:87.8-87.42 Warning: binding not exhaustive
          t2 :: t3 :: nil = ...
2/let_conv.sml:86.8-86.51 Warning: binding not exhaustive
          t1 :: ty' :: nil = ...
GC #1.2.4.7.38.1399:   (40 ms)
GC #1.2.4.7.39.1405:   (30 ms)
GC #1.2.4.8.40.1446:   (50 ms)
GC #1.2.4.8.41.1464:   (10 ms)
GC #1.2.4.8.42.1487:   (10 ms)
GC #1.2.4.8.43.1501:   (0 ms)
GC #1.2.4.8.44.1567:   (30 ms)
GC #1.2.4.8.45.1582:   (30 ms)
GC #1.2.4.8.46.1637:   (20 ms)
GC #1.2.4.8.47.1654:   (0 ms)
structure Let_conv : Let_conv_sig
val it = () : unit
[opening 2/num_conv.sig]
signature Num_conv_sig =
  sig
    structure Thm :
      sig
        structure Term : <sig>
        type thm
        val reset_thm_count : unit -> unit
        val counting_thms : bool -> unit
        val thm_count : unit
                        -> {ABS:int, ASSUME:int, BETA_CONV:int, DISCH:int,
                            INST_TYPE:int, MP:int, REFL:int, SUBST:int,
                            axiom:int, definition:int, drule:int,
                            from_disk:int, other:int, valid_tac:int}
        val hyp : thm -> Term.term list
        val concl : thm -> Term.term
        val dest_thm : thm -> Term.term list * Term.term
        val thm_free_vars : thm -> Term.term list
        val hyp_union : thm list -> Term.term list
        val pp_thm : ?.PrettyPrint.ppstream -> thm -> unit
        val thm_to_string : thm -> string
        val print_thm : thm -> unit
        val ASSUME : Term.term -> thm
        val REFL : Term.term -> thm
        val BETA_CONV : Term.term -> thm
        val SUBST : {thm:thm, var:Term.term} list -> Term.term -> thm -> thm
        val ABS : Term.term -> thm -> thm
        val INST_TYPE : Term.Type.hol_type subst -> thm -> thm
        val DISCH : Term.term -> thm -> thm
        val MP : thm -> thm -> thm
        val mk_axiom_thm : Term.term list * Term.term -> thm
        val mk_definition_thm : Term.term list * Term.term -> thm
        val mk_drule_thm : Term.term list * Term.term -> thm
        val mk_disk_thm : Term.term list * Term.term -> thm
        val mk_tac_thm : Term.term list * Term.term -> thm
        val mk_thm : Term.term list * Term.term -> thm
        datatype just_arg
          = JA_INT of int
          | JA_INTLIST of int list
          | JA_PAIR of just_arg * just_arg
          | JA_STRING of string
          | JA_TERM of Term.term
          | JA_THM of thm
          | JA_TYPE of Term.Type.hol_type
        datatype step = STEP of {Just:just_arg list, Name:string, Thm:thm}
        val record_step : (step -> thm) ref
        val record_proof : bool -> unit
        val suspend_recording : unit -> unit
        val resume_recording : unit -> unit
        val is_recording_proof : unit -> bool
        val note : step * thm -> thm
      end
    val num_CONV : Thm.Term.term -> Thm.thm
  end
val it = () : unit
GC #1.2.4.8.48.1699:   (20 ms)
[opening 2/num_conv.sml]
structure Num_conv : Num_conv_sig
val it = () : unit
val it = () : unit
GC #1.2.4.8.49.1734:   (0 ms)
[opening /usr/groups/hol/hol90.10/src/2/hol2.sml]
opening Num_conv
  structure Thm :
    sig
      structure Term : <sig>
      datatype thm = ...
      val reset_thm_count : unit -> unit
      val counting_thms : bool -> unit
      val thm_count : unit
                      -> {ABS:int, ASSUME:int, BETA_CONV:int, DISCH:int,
                          INST_TYPE:int, MP:int, REFL:int, SUBST:int,
                          axiom:int, definition:int, drule:int, from_disk:int,
                          other:int, valid_tac:int}
      val hyp : thm -> Term.term list
      val concl : thm -> Term.term
      val dest_thm : thm -> Term.term list * Term.term
      val thm_free_vars : thm -> Term.term list
      val hyp_union : thm list -> Term.term list
      val pp_thm : ?.PrettyPrint.ppstream -> thm -> unit
      val thm_to_string : thm -> string
      val print_thm : thm -> unit
      val ASSUME : Term.term -> thm
      val REFL : Term.term -> thm
      val BETA_CONV : Term.term -> thm
      val SUBST : {thm:thm, var:Term.term} list -> Term.term -> thm -> thm
      val ABS : Term.term -> thm -> thm
      val INST_TYPE : Term.Type.hol_type subst -> thm -> thm
      val DISCH : Term.term -> thm -> thm
      val MP : thm -> thm -> thm
      val mk_axiom_thm : Term.term list * Term.term -> thm
      val mk_definition_thm : Term.term list * Term.term -> thm
      val mk_drule_thm : Term.term list * Term.term -> thm
      val mk_disk_thm : Term.term list * Term.term -> thm
      val mk_tac_thm : Term.term list * Term.term -> thm
      val mk_thm : Term.term list * Term.term -> thm
      datatype just_arg
        = JA_INT of int
        | JA_INTLIST of int list
        | JA_PAIR of just_arg * just_arg
        | JA_STRING of string
        | JA_TERM of Term.term
        | JA_THM of thm
        | JA_TYPE of Term.Type.hol_type
      datatype step = STEP of {Just:just_arg list, Name:string, Thm:thm}
      val record_step : (step -> thm) ref
      val record_proof : bool -> unit
      val suspend_recording : unit -> unit
      val resume_recording : unit -> unit
      val is_recording_proof : unit -> bool
      val note : step * thm -> thm
    end
  val num_CONV : Thm.Term.term -> Thm.thm
opening Let_conv
  val PAIRED_BETA_CONV : conv
  val let_CONV : conv
  val PAIRED_ETA_CONV : conv
  val GEN_BETA_CONV : conv
opening Num_induct
  structure Thm :
    sig
      structure Term : <sig>
      datatype thm = ...
      val reset_thm_count : unit -> unit
      val counting_thms : bool -> unit
      val thm_count : unit
                      -> {ABS:int, ASSUME:int, BETA_CONV:int, DISCH:int,
                          INST_TYPE:int, MP:int, REFL:int, SUBST:int,
                          axiom:int, definition:int, drule:int, from_disk:int,
                          other:int, valid_tac:int}
      val hyp : thm -> Term.term list
      val concl : thm -> Term.term
      val dest_thm : thm -> Term.term list * Term.term
      val thm_free_vars : thm -> Term.term list
      val hyp_union : thm list -> Term.term list
      val pp_thm : ?.PrettyPrint.ppstream -> thm -> unit
      val thm_to_string : thm -> string
      val print_thm : thm -> unit
      val ASSUME : Term.term -> thm
      val REFL : Term.term -> thm
      val BETA_CONV : Term.term -> thm
      val SUBST : {thm:thm, var:Term.term} list -> Term.term -> thm -> thm
      val ABS : Term.term -> thm -> thm
      val INST_TYPE : Term.Type.hol_type subst -> thm -> thm
      val DISCH : Term.term -> thm -> thm
      val MP : thm -> thm -> thm
      val mk_axiom_thm : Term.term list * Term.term -> thm
      val mk_definition_thm : Term.term list * Term.term -> thm
      val mk_drule_thm : Term.term list * Term.term -> thm
      val mk_disk_thm : Term.term list * Term.term -> thm
      val mk_tac_thm : Term.term list * Term.term -> thm
      val mk_thm : Term.term list * Term.term -> thm
      datatype just_arg
        = JA_INT of int
        | JA_INTLIST of int list
        | JA_PAIR of just_arg * just_arg
        | JA_STRING of string
        | JA_TERM of Term.term
        | JA_THM of thm
        | JA_TYPE of Term.Type.hol_type
      datatype step = STEP of {Just:just_arg list, Name:string, Thm:thm}
      val record_step : (step -> thm) ref
      val record_proof : bool -> unit
      val suspend_recording : unit -> unit
      val resume_recording : unit -> unit
      val is_recording_proof : unit -> bool
      val note : step * thm -> thm
    end
  val INDUCT : Thm.thm * Thm.thm -> Thm.thm
  val INDUCT_TAC : tactic
opening Rec_type_support
  structure Thm :
    sig
      structure Term : <sig>
      datatype thm = ...
      val reset_thm_count : unit -> unit
      val counting_thms : bool -> unit
      val thm_count : unit
                      -> {ABS:int, ASSUME:int, BETA_CONV:int, DISCH:int,
                          INST_TYPE:int, MP:int, REFL:int, SUBST:int,
                          axiom:int, definition:int, drule:int, from_disk:int,
                          other:int, valid_tac:int}
      val hyp : thm -> Term.term list
      val concl : thm -> Term.term
      val dest_thm : thm -> Term.term list * Term.term
      val thm_free_vars : thm -> Term.term list
      val hyp_union : thm list -> Term.term list
      val pp_thm : ?.PrettyPrint.ppstream -> thm -> unit
      val thm_to_string : thm -> string
      val print_thm : thm -> unit
      val ASSUME : Term.term -> thm
      val REFL : Term.term -> thm
      val BETA_CONV : Term.term -> thm
      val SUBST : {thm:thm, var:Term.term} list -> Term.term -> thm -> thm
      val ABS : Term.term -> thm -> thm
      val INST_TYPE : Term.Type.hol_type subst -> thm -> thm
      val DISCH : Term.term -> thm -> thm
      val MP : thm -> thm -> thm
      val mk_axiom_thm : Term.term list * Term.term -> thm
      val mk_definition_thm : Term.term list * Term.term -> thm
      val mk_drule_thm : Term.term list * Term.term -> thm
      val mk_disk_thm : Term.term list * Term.term -> thm
      val mk_tac_thm : Term.term list * Term.term -> thm
      val mk_thm : Term.term list * Term.term -> thm
      datatype just_arg
        = JA_INT of int
        | JA_INTLIST of int list
        | JA_PAIR of just_arg * just_arg
        | JA_STRING of string
        | JA_TERM of Term.term
        | JA_THM of thm
        | JA_TYPE of Term.Type.hol_type
      datatype step = STEP of {Just:just_arg list, Name:string, Thm:thm}
      val record_step : (step -> thm) ref
      val record_proof : bool -> unit
      val suspend_recording : unit -> unit
      val resume_recording : unit -> unit
      val is_recording_proof : unit -> bool
      val note : step * thm -> thm
    end
  val prove_induction_thm : Thm.thm -> Thm.thm
  val prove_cases_thm : Thm.thm -> Thm.thm
  val prove_constructors_one_one : Thm.thm -> Thm.thm
  val prove_constructors_distinct : Thm.thm -> Thm.thm
signature EMPTY = sig end
signature EMPTY = sig end
signature EMPTY = sig end
signature EMPTY = sig end
signature EMPTY = sig end
val it = () : unit
GC #2.3.5.9.50.1763:   (240 ms)
write 1,0: 3384 bytes [0x41960000..0x41960d38) @ 0x2000
write 1,1: 5560 bytes [0x419c0008..0x419c15c0) @ 0x3000
write 1,2: 2236 bytes [0x41a20000..0x41a208bc) @ 0x5000
write 1,3: 668 bytes [0x41a70000..0x41a7029c) @ 0x6000
write 2,0: 2596 bytes [0x41d90000..0x41d90a24) @ 0x7000
write 2,1: 24240 bytes [0x41dd0008..0x41dd5eb8) @ 0x8000
write 2,2: 504 bytes [0x41e40000..0x41e401f8) @ 0xe000
write 2,3: 11124 bytes [0x41e50000..0x41e52b74) @ 0xf000
write 2,0: 3 big objects (39 pages) @ 0x12000
write 3,0: 3176 bytes [0x40150000..0x40150c68) @ 0x1bc30
write 3,1: 21936 bytes [0x40160008..0x401655b8) @ 0x1cc30
write 3,2: 2312 bytes [0x401b0000..0x401b0908) @ 0x22c30
write 3,3: 5064 bytes [0x401c0000..0x401c13c8) @ 0x23c30
write 3,0: 2 big objects (94 pages) @ 0x25c30
write 4,0: 464 bytes [0x401e0000..0x401e01d0) @ 0x3d450
write 4,1: 0 bytes [0x401f0008..0x401f0008) @ 0x3e450
write 4,2: 0 bytes [0..0) @ 0x3e450
write 4,3: 132 bytes [0x40200000..0x40200084) @ 0x3e450
write 5,0: 903608 bytes [0x42880000..0x4295c9b8) @ 0x3f450
write 5,1: 1783568 bytes [0x42ce0008..0x42e93718) @ 0x11c450
write 5,2: 387064 bytes [0x435a0000..0x435fe7f8) @ 0x2d0450
write 5,3: 176948 bytes [0x43780000..0x437ab334) @ 0x32f450
write 5,0: 409 big objects (8578 pages) @ 0x35b450
val it = () : unit
- 