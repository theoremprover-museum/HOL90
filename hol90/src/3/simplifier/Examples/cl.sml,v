head	1.1;
access;
symbols;
locks; strict;
comment	@# @;


1.1
date	96.01.04.14.16.26;	author drs1004;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Added simplifier components, added drule files, added MK_ABS_CONV, better error messages
@
text
@(* =====================================================================*)
(* FILE         : cl.ml                                                 *)
(* DESCRIPTION   : Creates the syntactic theory of combinatory logic and*)
(*                defines reduction of terms in the logic. Proves the   *)
(*                Church-Rosser theorem for this reduction relation.    *)
(*                                                                      *)
(* AUTHORS      : Tom Melham and Juanito Camilleri                      *)
(* DATE         : 91.10.09                                              *)
(* =====================================================================*)

(* ---------------------------------------------------------------------*)
(* Open a new theory and load the inductive definitions library.        *)
(* ---------------------------------------------------------------------*)

new_theory "cl";

load_library_in_place ind_def_lib;

open Inductive_def;

(* =====================================================================*)
(* Syntax of the combinatory logic.                                     *)
(* =====================================================================*)

(* ---------------------------------------------------------------------*)
(* The recursive types package is used to define the syntax of terms in *)
(* combnatory logic. The syntax is:                                     *)
(*                                                                      *)
(*    U ::=   s  |  k  |  U1 # U2                                       *)
(*                                                                      *)
(* where U, U1, and U2 range over terms. In higher order logic, terms of*)
(* combinatory logic are represented by the following constructors of a *)
(* recursive type cl:                                                   *)
(*                                                                      *)
(*    s:cl,  k:cl, and #:cl -> cl -> cl                                 *)
(*                                                                      *)
(* We are unfortunately prevented from the using upper-case letter S, as*)
(* this is already a constant in the built-in HOL theory hierarchy.     *)
(* ---------------------------------------------------------------------*)

val cl = define_type{name="cl",
                     type_spec = `cl = s | k | # of cl => cl`,
                     fixities = [Prefix, Prefix, Infix 800]};

(*

val {axiom,
     cases,
     distinct,
     induct_tac,
     induction,
     one_one,
     simpset} = hol_datatype `cl = s | k | # of cl => cl`;

hol_infixl "#" 800;
    
*)

(* =====================================================================*)
(* Standard syntactic theory, derived by the recursive types package.   *)
(* =====================================================================*)

(* ---------------------------------------------------------------------*)
(* Structural induction theorem for terms of combinatory logic .        *)
(* ---------------------------------------------------------------------*)

val induct = save_thm ("induct",prove_induction_thm cl);

(* ---------------------------------------------------------------------*)
(* Exhaustive case analysis theorem for terms of combinatory logic.     *)
(* ---------------------------------------------------------------------*)

val cases = save_thm ("cases", prove_cases_thm induct);

(* ---------------------------------------------------------------------*)
(* Prove that the application constructor is one-to-one.                *)
(* ---------------------------------------------------------------------*)

val ap11 = save_thm("ap11", prove_constructors_one_one cl);

(* ---------------------------------------------------------------------*)
(* Prove that the constructors yield syntactically distinct values. One *)
(* typically needs all symmetric forms of the inequalities.             *)
(* ---------------------------------------------------------------------*)

val distinct =
    let val ths = CONJUNCTS (prove_constructors_distinct cl)
        val rths = map (GEN_ALL o NOT_EQ_SYM o SPEC_ALL) ths 
    in save_thm("distinct", LIST_CONJ (ths @@ rths))
    end;


val CL_ss = pure_ss ++ [distinct,ap11];
val cl_ss = merge_ss [hol_ss, CL_ss];


(* =====================================================================*)
(* Inductive definition of reduction of CL terms.                       *)
(* =====================================================================*)

(* ---------------------------------------------------------------------*)
(* Definition of weak contraction.                                      *)
(*                                                                      *)
(* The one-step contraction relation -> is inductively defined by the   *)
(* rules shown below.  This is the "weak contraction' relation of       *)
(* Hindley and Seldin.  A weak redex is a term of the form Kxy or Sxyz. *)
(* A term U weakly contracts to V (i.e. U ---> V) if V can be obtained  *)
(* by replacing one occurrence of a redex in U, where a redex Kxy is    *)
(* replaced by x and a redex Sxyz is replaced by (xz)yz.  The first two *)
(* rules in the inductive definition given below define the contraction *) 
(* of redexes, the second two rules define the contraction of subterms. *)
(* ---------------------------------------------------------------------*)


open Inductive_def;
val tt = mk_typetable ["--->" |--> (==`:cl->cl->bool`==)];
fun -+ t _ = mk_term_parser [type_inference, typetable tt] t;
val +- = 1;
    
hol_infix ("--->", 700);

val {desc=Crules,induction_thm = Cind} =
new_inductive_definition {name="contract", fixity = Infix 700,
   patt = ((-+`U ---> V`+-), []),
   rules=[
   {hypotheses=[],      side_conditions=[],
    (* ------------------------------------------------------ *)
    conclusion=         (-+`((k # x) # y) ---> x`+-)           },

   {hypotheses=[],      side_conditions=[],
    (*---------------------------------------------------------------- *)
    conclusion=   (-+`(((s # x) # y) # z) ---> ((x # z) # (y # z))`+-)},


   {hypotheses=[-+`x ---> y`+-],    side_conditions=[],
    (*----------------------------------------------------------------- *)
    conclusion=             (-+`(x # z) ---> (y # z)`+-)                 },


   {hypotheses=[-+`x ---> y`+-],    side_conditions=[],
    (*----------------------------------------------------------------- *)
    conclusion=             (-+`(z # x) ---> (z # y)`+-)                 }]};




(* ---------------------------------------------------------------------*)
(* Stronger form of rule induction.                                     *)
(* ---------------------------------------------------------------------*)

val Csind = derive_strong_induction (Crules,Cind);

(* ---------------------------------------------------------------------*)
(* Standard rule induction tactic for --->.  This uses the weaker form  *)
(* of the rule induction theorem, and both premisses and side conditions*)
(* are just assumed (in stripped form).                                 *)
(* ---------------------------------------------------------------------*)

val C_INDUCT_TAC =
    RULE_INDUCT_THEN Cind STRIP_ASSUME_TAC STRIP_ASSUME_TAC;

(* ---------------------------------------------------------------------*)
(* Prove the case analysis theorem for the contraction rules.           *)
(* ---------------------------------------------------------------------*)

val Ccases = derive_cases_thm (Crules,Cind);

(* ---------------------------------------------------------------------*)
(* Tactics for each of the contraction rules.                           *)
(* ---------------------------------------------------------------------*)

val C_ss = pure_ss ++ Crules;

(* ---------------------------------------------------------------------*)
(* The weak reduction relation on terms in combinatory logic is just the*)
(* reflexive-transitive closure of --->.  We define reflexive-transitive*)
(* closure inductively as follows, and then define the weak reduction   *)
(* relation --->* to be RTC --->.                                       *)
(* ---------------------------------------------------------------------*)

val {desc=RTCrules,induction_thm = RTCind} =
let val RTC = (-+`RTC:('a->'a->bool)->'a->'a->bool`+-) 
in
new_inductive_definition{name="RTC", fixity=Prefix,
   patt=((-+`^RTC R x y`+-), [(-+`R:'a->'a->bool`+-)]),
   rules=[
    {hypotheses=[],
     side_conditions = [-+`R (x:'a) (y:'a):bool`+-],
     (* ----------------------------------------- *) 
     conclusion=    (-+`^RTC R x y`+-)             },

     {hypotheses=[],
      side_conditions=[],                                      
      (* ---------------------------------------- *)
      conclusion=     (-+`^RTC R x x`+-)           },


     {hypotheses=[(-+`^RTC R x z`+-), (-+`^RTC R z y`+-)],
      side_conditions=[],
      (*------------------------------------------------*)
      conclusion=          (-+`^RTC R x y`+-)            }]}
end;



(* ---------------------------------------------------------------------*)
(* Standard rule induction tactic for RTC.                              *)
(* ---------------------------------------------------------------------*)

val RTC_INDUCT_TAC =
    RULE_INDUCT_THEN RTCind STRIP_ASSUME_TAC STRIP_ASSUME_TAC;

(* ---------------------------------------------------------------------*)
(* Case analysis theorem for RTC.                                       *)
(* ---------------------------------------------------------------------*)

val RTCcases = derive_cases_thm (RTCrules,RTCind);

(* ---------------------------------------------------------------------*)
(* Simpsets and non-simplification theorems for RTC			*)
(* ---------------------------------------------------------------------*)

val RTC_ss = pure_ss ++ [el 1 RTCrules, el 2 RTCrules];
val RTC_TRANS = el 3 RTCrules;

(* ---------------------------------------------------------------------*)
(* Definition of weak reduction.                                        *)
(* ---------------------------------------------------------------------*)

val reduce = new_infix_definition("reduce", (-+`+-->* = RTC $--->`+-),700);
val reduce_def_ss = pure_ss ++ [reduce];


(* =====================================================================*)
(* Theorem : ---> does not have the Church-Rosser property.             *)
(*                                                                      *)
(* We wish to prove that weak reduction is Church-Rosser.  If we could  *)
(* prove that the one-step contraction ---> has this property, then we  *)
(* could also show that reduction does, since taking the reflexive-     *)
(* transitive closure of a relation preserves the Church-Rosser theorem.*)
(* Unfortunately, however, ---> is not Church- Rosser, as the following *)
(* counterexample shows.                                                *)
(*                                                                      *)
(* The counter example is ki(ii) where i = skk. We have that:           *)
(*                                                                      *)
(*             ki(ii)                                                   *)
(*              /  \                                                    *)
(*             /    \                                                   *)
(*            /      \                                                  *)
(*           i    ki(ki)(ki)                                            *)
(*                   /                                                  *)
(*                  /                                                   *)
(*                 /                                                    *)
(*                i                                                     *)
(*                                                                      *)
(* But i doesn't contract to i (or indeed to any other term).           *)
(* =====================================================================*)

(* ---------------------------------------------------------------------*)
(* We first define i to be skk.                                         *)
(* ---------------------------------------------------------------------*)

val iDEF = new_definition ("iDEF", (-+`i = (s # k) # k`+-));
val iDEF_ss = pure_ss ++ [iDEF];


(* ---------------------------------------------------------------------
 * Given the definitions above, it is straightforward
 * to construct a simpset for automatically checking an assertion that 
 * one term contracts to another.                                  
 * ---------------------------------------------------------------------*)

val contracts_ss = hol_ss merge_ss C_ss merge_ss iDEF_ss;

(* ---------------------------------------------------------------------*)
(* We can now use this tactic to show the following lemmas:             *)
(*                                                                      *)
(*    1) ki(ii) ---> i                                                  *)
(*    2) ki(ii) ---> ki((ki)(ki))                                       *)
(*    3) ki((ki)(ki)) ---> i                                            *)
(* ---------------------------------------------------------------------*)

val lemma1 = prove
    ((-+`((k # i) # (i # i)) ---> i`+-),
     SIMP_TAC contracts_ss);

val lemma2 =
    prove
    ((-+`((k # i) # (i # i)) ---> (k # i) # ((k # i) # (k # i))`+-),
     SIMP_TAC contracts_ss);

val lemma3 =
    prove
    ((-+`((k # i) # ((k # i) # (k # i))) ---> i`+-),
     SIMP_TAC contracts_ss);

(* ---------------------------------------------------------------------
 * For the proof that !U. ~(i ---> U), we construct some infrastructure   
 * for a general way of dealing with contractability assertions.  The   
 * core of this consists of a tactic that rewrites assertions of the    
 * form (-+`U ---> V`+-) with the cases theorem for ---> :              
 *                                                                      
 *   |- !U V.                                                           
 *       U ---> V =                                                     
 *       (?y. U = (k # V) # y) \/                                       
 *       (?x y z. (U = ((s # x) # y) # z) /\ (V = (x # z) # (y # z))) \/)
 *       (?x y z. (U = x # z) /\ (V = y # z) /\ x ---> y) \/            
 *       (?x y z. (U = z # x) /\ (V = z # y) /\ x ---> y)               
 *                                                                      
 * The full method is as follows:                                       
 *                                                                      
 *   1) rewrite just once using the cases theorem                       
 *                                                                      
 *        PURE_ONCE_REWRITE_TAC [Ccases]                                
 *                                                                      
 *   2) simplify using:
 *         - distinctness cl terms and and injectivity of application. 
 *         - move negations in through quantifiers, conjuncts and disjuncts
 *         - one-step contraction theorems
 *         - eliminate redundant equations from existentials and equations
 *                                                                      
 * The overall effect is one step of expansion with the cases theorem,  
 * followed by a renormalization step.  Repeat as often as needed, but  
 * note that REPEAT may loop.  Could guard step 1 with a stopping       
 * condition if necessary.  Note that the normal form is a disjunction  
 * of existentially-quantified conjunctions.                            
 * ---------------------------------------------------------------------*)

(* ---------------------------------------------------------------------*)
(* We can now use this tactic to prove that i doesn't contract to any   *)
(* term of combinatory logic.  Note that since the transition in fact   *)
(* does NOT hold, step 2 of EXPAND_CASES_TAC eventually solves the goal.*)
(* Hence we may use REPEAT here.                                        *)
(* Total runtime: 2.810281 
   Total: 5316 *)
(* ---------------------------------------------------------------------*)

val simplify_contracts_ss = hol_ss merge_ss CL_ss merge_ss C_ss;
val lemma4 =
profile prove((-+`!U. ~(i ---> U)`+-),
    SIMP_TAC (simplify_contracts_ss ++ [iDEF])
    THEN  PURE_ONCE_REWRITE_TAC [Ccases] 
    THEN SIMP_TAC simplify_contracts_ss
    THEN  PURE_ONCE_REWRITE_TAC [Ccases] 
    THEN SIMP_TAC simplify_contracts_ss
    THEN  PURE_ONCE_REWRITE_TAC [Ccases] 
    THEN SIMP_TAC simplify_contracts_ss
);

(* ---------------------------------------------------------------------
 * We can now make a simpset for reasoning about "i" out
 * of these lemmas.
 * ---------------------------------------------------------------------*)

val I_ss = pure_ss ++ [lemma1, lemma2, lemma3, lemma4];

(* ---------------------------------------------------------------------*)
(* We now have our counterexample to show that ---> does not have the   *)
(* Church-Rosser property.  We first define an abbreviation for the     *)
(* assertion that a relation R has this property.                       *)
(* ---------------------------------------------------------------------*)

val CR =
    new_definition
    ("CR",
      (-+`CR (R: 'a -> 'a -> bool) =
       !a b. R a b ==> !c. R a c ==> ?d. R b d /\ R c d`+-));

val CR_def_ss = pure_ss ++ [CR];

(* ---------------------------------------------------------------------
 * Use the counterexample to show that ---> is not Church-Rosser.       
 * Simplify using 
 *	- definition of CR
 *	- facts just proven about I
 * 	- rules for ----> 
 *	- datatype theorems for cl constructs.
 * ---------------------------------------------------------------------*)

val ss = hol_ss merge_ss CR_def_ss merge_ss I_ss merge_ss C_ss merge_ss CL_ss;

val NOT_C_CR =
prove((-+`~CR($--->)`+-),
    SIMP_TAC ss
    THEN EXISTS_TAC (-+`(k # i) # (i # i)`+-) 
    THEN EXISTS_TAC (-+`(k # i) # ((k # i) # (k # i))`+-)
    THEN SIMP_TAC ss
    THEN  EXISTS_TAC (-+`i`+-)
    THEN SIMP_TAC ss
);

(* =====================================================================*)
(* Inductive definition of parallel reduction of CL terms               *)
(* =====================================================================*)

(* --------------------------------------------------------------------- *)
(* Definition of one-step parallel contraction.                          *)
(*                                                                       *)
(* This one-step contraction relation has the Church-Rosser property,    *)
(* and its transitive closure (parallel reduction) therefore also does.  *)
(* Moreover, parallel reduction and --->* are the same relation, so we can*)
(* prove the Church-Rosser theorem for --->* by proving it for parallel  *)
(* reduction.  The inductive definition of one-step parallel contraction *)
(* is given below.  The allow any number of redexes among the subterms   *)
(* of a term to be contracted in a single step.                          *)
(* --------------------------------------------------------------------- *)


val {desc=PCrules,induction_thm = PCind} =
let val PCTR = (-+`===> :cl->cl->bool`+-) 
in
new_inductive_definition{name="pcontract", fixity = Infix 700,
   patt=((-+`^PCTR U V`+-), []),
   rules=[

    {hypotheses=[],
     side_conditions=[],
     (* ------------------------------------------------------ *)
     conclusion=            (-+`^PCTR x x`+-)                   },


    {hypotheses=[],
     side_conditions=[],
     (* ------------------------------------------------------ *)
     conclusion=       (-+`^PCTR ((k # x) # y) x`+-)            },


     {hypotheses=[],
      side_conditions=[],
      (*------------------------------------------------------------- *)
      conclusion= (-+`^PCTR (((s # x) # y) # z)  ((x # z) # (y # z))`+-)},


     {side_conditions=[],
      hypotheses=     [(-+`^PCTR w x`+-),     (-+`^PCTR y z`+-)       ],
      (*------------------------------------------------------------ *)
      conclusion =          (-+`^PCTR (w # y) (x # z)`+-)             }]}
end;



(* --------------------------------------------------------------------- *)
(* Stronger form of rule induction.                                      *)
(* --------------------------------------------------------------------- *)

val PCsind = derive_strong_induction (PCrules,PCind);


(* --------------------------------------------------------------------- *)
(* Standard rule induction tactic for ===>.                              *)
(* --------------------------------------------------------------------- *)

val PC_INDUCT_TAC =
    RULE_INDUCT_THEN PCind STRIP_ASSUME_TAC STRIP_ASSUME_TAC;

(* ---------------------------------------------------------------------*)
(* Case analysis theorem for ===>.                                      *)
(* ---------------------------------------------------------------------*)

val PCcases = derive_cases_thm (PCrules,PCind);

(* ---------------------------------------------------------------------
 * Simpset for rules for Parallel Contraction
 * ---------------------------------------------------------------------*)

val PC_ss = pure_ss ++ PCrules;

(* --------------------------------------------------------------------- *)
(* The weak reduction relation on terms in combinatory logic is just the *)
(* transitive closure of ===>.  Transitive is defined inductively as    *)
(* follows.  Note that the transitivity rule formulated as:             *)
(*                                                                      *)
(*            TC R x z                                                  *)
(*   R1:   -------------- R z y                                         *)
(*            TC R x y                                                  *)
(*                                                                      *)
(* and not as                                                           *)
(*                                                                      *)
(*          TC R x z   TC R z y                                         *)
(*   R2:  ------------------------                                      *)
(*              TC R x z                                                *)
(*                                                                      *)
(* This is because rule R1 gives a linear structure to rule inductions  *)
(* for transitive closure, which make the details of these proofs easier*)
(* to handle than the tree-shaped structure induced by rule R2.         *)
(*                                                                      *)
(* Once transitive closure has been defined, the parallel reduction     *)
(* relation ===>* can just be defined to be TC ===>.                    *)
(* ---------------------------------------------------------------------*)

val {desc = TCrules, induction_thm = TCind} =
let val TC = (-+`TC:('a->'a->bool)->'a->'a->bool`+-) 
in
new_inductive_definition{name="TC" ,fixity=Prefix,
   patt=((-+`^TC R x y`+-), [(-+`R:'a->'a->bool`+-)]),
   rules=[
    {hypotheses=[],
     side_conditions=[    -+`R (x:'a) (y:'a):bool`+-     ],
      (* ----------------------------------------------- *)
     conclusion=             (-+`^TC R x y`+-)            },


    {hypotheses=[         (-+`^TC R x z`+-)               ],
     side_conditions=[ (-+`R (z:'a) (y:'a):bool`+-)       ],
     (*-------------------------------------------------- *)
     conclusion=            (-+`^TC R x y`+-)             }]}
end;


(* ---------------------------------------------------------------------*)
(* Standard rule induction tactic for TC.                               *)
(* ---------------------------------------------------------------------*)

val TC_INDUCT_TAC =
    RULE_INDUCT_THEN TCind STRIP_ASSUME_TAC STRIP_ASSUME_TAC;


(* ---------------------------------------------------------------------*)
(* Strong form of rule induction for TC.                                *)
(* ---------------------------------------------------------------------*)

val TCsind = derive_strong_induction (TCrules,TCind);

(* ---------------------------------------------------------------------
 * Simpsets for TC rules
 * Transitivity is exported as a seperate theorem since it cannot go
 * in the simpset (it is a backward chaining conditional rewrite rule).  
 * Use MATCH_MP_TAC to match it to the current goal.
 * ---------------------------------------------------------------------*)

val TC_ss = pure_ss ++ [el 1 TCrules];
val TC_TRANS = el 2 TCrules;

(* ---------------------------------------------------------------------*)
(* Now, define parallel reduction for terms of CL.                      *)
(* ---------------------------------------------------------------------*)

val preduce = new_infix_definition("preduce", (-+`===>* = TC $===>`+-),700);

val preduce_def_ss = pure_ss ++ [preduce];

(* =====================================================================*)
(* Theorem: ===>* and --->* are the same relation.                      *)
(* =====================================================================*)

(* ---------------------------------------------------------------------*)
(* The following sequence of lemmas show that the rules for the single  *)
(* step contraction ---> also hold its reflexive-transitive closure,    *)
(* namely the relation --->*.  The proofs are trivial for the k and s   *)
(* axioms. For the two application rules, we need a simple induction    *)
(* on the rules defining RTC.                                           *)
(* ---------------------------------------------------------------------*)

val simplify_reduce_ss = hol_ss merge_ss RTC_ss merge_ss CL_ss merge_ss C_ss;

val Rk_THM =
    prove
    ((-+`!a b. ((k # a) # b) --->* a`+-),
     SIMP_TAC simplify_reduce_ss);

val Rs_THM =
    prove
    ((-+`!a b c. (((s # a) # b) # c) --->* ((a # c) # (b # c))`+-),
     SIMP_TAC simplify_reduce_ss);

val LRap_THM =
prove((-+`!a b. a --->* b ==> !c. (a # c) --->* (b # c)`+-),
    SIMP_TAC simplify_reduce_ss
    THEN  RTC_INDUCT_TAC
    THEN ASM_SIMP_TAC simplify_reduce_ss
    THEN GEN_TAC THEN MATCH_MP_TAC RTC_TRANS
    THEN EXISTS_TAC (-+`(z # c :cl)`+-)
    THEN ASM_SIMP_TAC simplify_reduce_ss
);

val RRap_THM =
prove((-+`!a b. a --->* b ==> !c. (c # a) --->* (c # b)`+-),
    SIMP_TAC (rtc_ss ++ [reduce])
    THEN  RTC_INDUCT_TAC
    THEN ASM_SIMP_TAC simplify_reduce_ss
    THEN GEN_TAC THEN MATCH_MP_TAC RTC_TRANS
    THEN EXISTS_TAC (-+`(c # z :cl)`+-)
    THEN ASM_SIMP_TAC simplify_reduce_ss
);

(* --------------------------------------------------------------------- *)
(* To avoid having to expand --->* into RTC --->, we also prove that the *)
(* rules for reflexive-transitive closure hold of --->*.  The proofs are *)
(* completely trivial.                                                   *)
(* --------------------------------------------------------------------- *)

val CONT_IN_RED =
    prove
    ((-+`!U V. U ---> V ==> U --->* V`+-),
     SIMP_TAC simplify_reduce_ss);


val RED_REFL =
    prove
    ((-+`!U. U --->* U`+-),
     SIMP_TAC simplify_reduce_ss);


(* SIMP_TAC doesn't work here since RTC_TRANS isn't in rts_cc *)
val RED_TRANS =
prove((-+`!U V. (?W. U --->* W /\ W --->* V) ==> (U --->* V)`+-),
    SIMP_TAC simplify_reduce_ss
    THEN REPEAT STRIP_TAC
    THEN MATCH_MP_TAC RTC_TRANS
    THEN EXISTS_TAC (-+`(W :cl)`+-)
    THEN ASM_SIMP_TAC simplify_reduce_ss
);


(* ---------------------------------------------------------------------
 * We now have enough theorems to make a simpset about "reduce"
 * ---------------------------------------------------------------------*)
val RED_ss = pure_ss ++ [CONT_IN_RED, RED_REFL, Rk_THM, Rs_THM, LRap_THM, RRap_THM];



(* ---------------------------------------------------------------------  *)
(* We can now use these lemmas to prove that the relation ===>* is a      *)
(* subset of --->*. The proof has two parts. The first is to show that if *)
(* there is a one-step parallel reduction U ===> V, then U --->* V. Given *)
(* the lemmas proved above, it is easy to show that --->* is closed under *)
(* the rules that define ===>, and hence by rule induction that ===> is   *)
(* a subset of --->*.                                                     *)
(* ---------------------------------------------------------------------  *)

val simplify_preduce_ss = 
     hol_ss merge_ss 
     RED_ss merge_ss 
     preduce_def_ss merge_ss 
     PC_ss merge_ss 
     TC_ss merge_ss
     C_ss merge_ss
     CL_ss;
val PCONT_SUB_RED =
prove((-+`!U V. U ===> V ==> U --->* V`+-),
    PC_INDUCT_TAC
    THENL [
       SIMP_TAC simplify_preduce_ss,
       SIMP_TAC simplify_preduce_ss,
       SIMP_TAC simplify_preduce_ss,
       MATCH_MP_TAC RED_TRANS
       THEN EXISTS_TAC  (-+`(x # y)`+-)
       THEN ASM_SIMP_TAC simplify_preduce_ss
    ]
);

(* --------------------------------------------------------------------- *)
(* Given this result, one can then prove that ===>* is a subset of --->* *)
(* by rule induction.  The previous lemma just states that the relation  *)
(* --->* is closed under the inclusion rule for TC ===>. And one can also*)
(* prove that --->* is closed under the transitivity rule, since we have *)
(* already above proved that --->* is transitive.  Hence, by rule        *)
(* induction of transitive closure, TC ===> is a subset of --->*.        *)
(* --------------------------------------------------------------------- *)

val PRED_SUB_RED =
prove((-+`!U V. (U ===>* V) ==> U --->* V`+-),
    SIMP_TAC simplify_preduce_ss THEN TC_INDUCT_TAC
    THENL [
       ASM_SIMP_TAC (simplify_preduce_ss ++ [PCONT_SUB_RED]),
       MATCH_MP_TAC RED_TRANS
       THEN EXISTS_TAC (-+`(z :cl)`+-)
       THEN ASM_SIMP_TAC (simplify_preduce_ss ++ [PCONT_SUB_RED])
    ]
);


(* --------------------------------------------------------------------- *)
(* The proof of the converse inclusion, that --->* is a subset of ===>*, *)
(* is similar.  Again, we begin with a series of lemmas which establish  *)
(* that the rules defining ===> hold for its transitive closure ===>*.   *)
(* --------------------------------------------------------------------- *)

val PRk_THM =
    prove
    ((-+`!a b. ((k # a) # b) ===>* a`+-), SIMP_TAC simplify_preduce_ss);

val PRs_THM =
    prove
    ((-+`!a b c. (((s # a) # b) # c) ===>* ((a # c) # (b # c))`+-),
    SIMP_TAC simplify_preduce_ss);

(* --------------------------------------------------------------------- *)
(* The application case is slightly trickier than the two analogous      *)
(* application theorems in the previous series of lemmas. Because of the *)
(* way the transitivity rule is formulated, a double rule induction is   *)
(* needed.                                                               *)
(* --------------------------------------------------------------------- *)

val PRap_THM =
prove((-+`!a b. (a ===>* b) ==> 
               !c d. (c ===>* d) ==> 
                     ((a # c) ===>* (b # d))`+-),
    SIMP_TAC simplify_preduce_ss
    THEN  REPEAT TC_INDUCT_TAC 
    THENL [
       ALL_TAC,
       MATCH_MP_TAC TC_TRANS THEN EXISTS_TAC (-+`y # z`+-),
       MATCH_MP_TAC TC_TRANS THEN EXISTS_TAC (-+`z # x'`+-),
       MATCH_MP_TAC TC_TRANS THEN EXISTS_TAC (-+`y # z'`+-)
    ] THEN
    ASM_SIMP_TAC simplify_preduce_ss
);

(* --------------------------------------------------------------------- *)
(* We also need to show that ===>* is reflexive and transitive. Note that*)
(* in the transitivity case we need a careful formulation of the         *)
(* induction hypothesis, because of the way the transitivity rule for TC *)
(* is stated.  In particular, we induct on b ===>* c, rather than on     *)
(* a ===>* b.                                                            *)
(* --------------------------------------------------------------------- *)

val PR_REFL =
    prove
    ((-+`!U. U ===>* U`+-),
     SIMP_TAC simplify_preduce_ss);

val PR_TRANS_LEMMA = 
prove((-+`!b c. (b ===>* c) ==> !a. (a ===>* b) ==> (a ===>* c)`+-),
    SIMP_TAC simplify_preduce_ss
    THEN TC_INDUCT_TAC THEN REPEAT STRIP_TAC
    THENL [
       MATCH_MP_TAC TC_TRANS THEN EXISTS_TAC (-+`x:cl`+-),
       MATCH_MP_TAC TC_TRANS THEN EXISTS_TAC (-+`z:cl`+-)
    ]
    THEN ASM_SIMP_TAC simplify_preduce_ss
);

val PR_TRANS = 
prove((-+`!a c. (?b. (b ===>* c) /\ (a ===>* b)) ==> (a ===>* c)`+-),
    REPEAT STRIP_TAC THEN IMP_RES_TAC PR_TRANS_LEMMA);


(* ---------------------------------------------------------------------  
 * Now set up a simpset for reasoning about "preduce"
 * Once again transitivity (PR_TRANS) cannot go in - we have to explicitly use
 * MATCH_MP_TAC for it.
 * ---------------------------------------------------------------------  *)

val preduce_ss = pure_ss ++ [PR_REFL, PRap_THM, PRk_THM, PRs_THM];

(* ---------------------------------------------------------------------  *)
(* We now show by rule induction that ---> is a subset of ===>*. We have  *)
(* already proved that the s and k rules for ---> also hold for ===>*.    *)
(* Futhermore, the two application rules for ---> follow easily for the   *)
(* relation ===>*, since the more general application rule holds for this *)
(* relation and since it is reflexive.                                    *)
(* ---------------------------------------------------------------------  *)

val ss = hol_ss merge_ss preduce_ss;
val CONT_SUB_PRED =
prove((-+`!U V. U ---> V ==> U ===>* V`+-),
    C_INDUCT_TAC
    THEN ASM_SIMP_TAC ss
);

(* ---------------------------------------------------------------------   *)
(* That --->* is a subset of ===>* now follows by rule induction.  We have *)
(* shown that ===>* contains ---> and that it is reflexive and transitive. *)
(* So ===>* is closed under the rules for RTC --->, and hence --->* is a   *)
(* subset of ===>*.                                                        *)
(* ---------------------------------------------------------------------   *)

val ss = 
   hol_ss merge_ss 
   preduce_ss merge_ss 
   reduce_def_ss ++ 
   [CONT_SUB_PRED];
val RED_SUB_PRED =
prove((-+`!U V. U --->* V ==> U ===>* V`+-),
    SIMP_TAC ss
    THEN RTC_INDUCT_TAC
    THENL [
       ALL_TAC, ALL_TAC,
       MATCH_MP_TAC PR_TRANS THEN EXISTS_TAC (-+`z:cl`+-)
    ] THEN ASM_SIMP_TAC ss
);

(* --------------------------------------------------------------------- *)
(* The equality of --->* and ===>* follows immediately.                  *)
(* --------------------------------------------------------------------- *)

val RED_EQ_PRED =
prove((-+`$--->* = $===>*`+-),
     SIMP_TAC hol_ss THEN
     REPEAT (STRIP_TAC ORELSE EQ_TAC) THENL
     [IMP_RES_TAC RED_SUB_PRED, IMP_RES_TAC PRED_SUB_RED]);

(* ===================================================================== *)
(* Theorem: taking the transitive closure preserves Church-Rosser.       *)
(* ===================================================================== *)

(* ---------------------------------------------------------------------*)
(* Lemma: we can fill in any "strip' one transition wide.  That is, if  *)
(* R has the Church-Rosser rpoperty, then we have that                  *)
(*                                                                      *)
(*             a                                        a               *)
(*            / \                                      / \              *)
(*  if       b   \       then there exists d st:      b   \             *)
(*                \                                    \   \            *)
(*                 c                                    \   c           *)
(*                                                       \ /            *)
(*                                                        d             *)
(*                                                                      *)
(* The choice of formulation for the transitivity rule makes the proof a *)
(* straightforward rule indction down the a-to-c leg of the rectangle.   *)
(* --------------------------------------------------------------------- *)

val simplify_CR_ss =
   hol_ss merge_ss
   CR_def_ss merge_ss
   TC_ss;

val CR_LEMMA =
prove((-+`!R:'a->'a->bool.
       CR R ==> !a c. TC R a c ==> !b. R a b ==> ?d. TC R b d /\ R c d`+-),
    GEN_TAC THEN PURE_ONCE_REWRITE_TAC [CR] THEN STRIP_TAC
    THEN TC_INDUCT_TAC THEN REPEAT STRIP_TAC THEN RES_TAC
    THENL [
       EXISTS_TAC (-+`d':'a`+-)
       THEN ASM_SIMP_TAC simplify_CR_ss,
       EXISTS_TAC (-+`d'':'a`+-)
       THEN ASM_SIMP_TAC simplify_CR_ss
       THEN MATCH_MP_TAC TC_TRANS
       THEN EXISTS_TAC (-+`d:'a`+-)
    ]
);


(* --------------------------------------------------------------------- *)
(* With a second rule induction, down the other "leg' of the diamond, we *)
(* can now prove that taking the transitive closure preserves the Church *)
(* Rosser property. The theorem is that if R is Church-Rosser, then:    *)
(*                                                                      *)
(*             a                                        a               *)
(*            / \                                      / \              *)
(*  if       /   \       then there exists d st:      /   \             *)
(*          /     \                                  /     \            *)
(*         b       c                                b       c           *)
(*                                                   \     /            *)
(*                                                    \   /             *)
(*                                                     \ /              *)
(*                                                      d               *)
(*                                                                      *)
(* The proof is by rule induction on TC R a b.                          *)
(* --------------------------------------------------------------------- *)

val TC_PRESERVES_CR_THM = 
prove((-+`!R:'a->'a->bool.
        CR R ==> 
           !a c. TC R a c ==> !b. TC R a b ==> ?d. TC R b d /\ TC R c d`+-),
    GEN_TAC THEN STRIP_TAC THEN TC_INDUCT_TAC
    THEN REPEAT STRIP_TAC
    THENL [
       IMP_RES_TAC CR_LEMMA THEN
       EXISTS_TAC (-+`d:'a`+-) THEN
       ASM_SIMP_TAC simplify_CR_ss,

       RES_TAC THEN 
       IMP_RES_TAC CR_LEMMA THEN
       EXISTS_TAC (-+`d':'a`+-) THEN
       ASM_SIMP_TAC simplify_CR_ss THEN
       MATCH_MP_TAC TC_TRANS THEN EXISTS_TAC (-+`d:'a`+-) THEN
       ASM_SIMP_TAC simplify_CR_ss
    ]
);

val TC_PRESERVES_CR =
prove((-+`!R:'a->'a->bool. CR R ==> CR (TC R)`+-),
    SIMP_TAC (simplify_CR_ss ++ [TC_PRESERVES_CR_THM])
);

(* ===================================================================== *)
(* Theorem: the parallel contraction relation ===> is Church-Rosser.     *)
(* ===================================================================== *)

(* --------------------------------------------------------------------- *)
(* We define a conversion EXPAND_PC_CASES_CONV for expanding with the    *)
(* cases theorem for ===>.  This is analogous to EXPAND_CASES_TAC above, *)
(* except that it's a conversion, and it is designed to succeed for terms *)
(* that contain at least one subterm (-+`U ===> V`+-) where U or         *)
(* V is a variable.  This condition means you can repeat                 *)
(* (REPEATC) this conversion, and the resulting conversion will always   *)
(* halt.                                                                 *)
(* --------------------------------------------------------------------- *)

fun EXPAND_PC_CASES_CONV tm =
          let val (_,[x,y]) = strip_comb tm 
          in if (is_var x andalso is_var y) 
             then raise HOL_ERR{origin_function="EXPAND_PC_CASES_CONV",
                                message="",origin_structure=""}
             else REWR_CONV PCcases tm
          end;

(* --------------------------------------------------------------------- *)
(* Now for the main theorem. The proof proceeds by strong rule induction *)
(* on the relation ===>.  The four cases in the induction are:          *)
(*                                                                      *)
(*  1) (-+`(w # y) ===> c ==> (?d. (x # z) ===> d /\ c ===> d)`+-)      *)
(*     [ (-+`w ===> x`+-) ]                                             *)
(*     [ (-+`!c. w ===> c ==> (?d. x ===> d /\ c ===> d)`+-) ]          *)
(*     [ (-+`y ===> z`+-) ]                                             *)
(*     [ (-+`!c. y ===> c ==> (?d. z ===> d /\ c ===> d)`+-) ]          *)
(*                                                                      *)
(*  2) (-+`(((s # x) # y) # z) ===> c ==>                               *)
(*      (?d. ((x # z) # (y # z)) ===> d /\ c ===> d)`+-)                *)
(*                                                                      *)
(*  3) (-+`((k # x) # y) ===> c ==> (?d. x ===> d /\ c ===> d)`+-)      *)
(*                                                                      *)
(*  4) (-+`x ===> c ==> (?d. x ===> d /\ c ===> d)`+-)                  *)
(*                                                                      *)
(* Cases 2,3 and 4 are solved by case analysis (using PCcases) on the   *)
(* antecedent, followed by straightforward search for the proof of the  *)
(* consequent using the tactics for ===>.  Case 1 is solved also by     *)
(* first analysing the antecedent by PCcases followed by search for the *)
(* proof.  In two sub-cases, however, one needs to do a case analysis   *)
(* on the strong induction assumption.  See the proof below for details.*)
(* ---------------------------------------------------------------------*)

val prove_CR_ss =
   hol_ss merge_ss
   CR_def_ss merge_ss
   TC_ss merge_ss
   PC_ss merge_ss
   CL_ss;
val CR_cases_ss = 
   prove_CR_ss 
   addconvs [
       mk_convdata("EXPAND_PC_CASES_CONV",SOME([],(-+`a ===> c`+-)),REDUCER,2,K EXPAND_PC_CASES_CONV)];

val kc_CASES_LEMMA = 
   UNDISCH (fst(EQ_IMP_RULE (SIMP_CONV CR_cases_ss (-+`(k#c) ===> x`+-))));
val sxy_CASES_LEMMA =
   UNDISCH(fst(EQ_IMP_RULE (SIMP_CONV CR_cases_ss (-+`(s#x')#y' ===> x`+-))));

val CR_THEOREM =
prove((-+`CR $===>`+-),
    SIMP_TAC simplify_CR_ss
    THEN  RULE_INDUCT_THEN PCsind STRIP_ASSUME_TAC STRIP_ASSUME_TAC THEN REPEAT GEN_TAC
    THENL [
       STRIP_TAC
       THEN EXISTS_TAC (-+`(c :cl)`+-)
       THEN ASM_SIMP_TAC prove_CR_ss,

       CONV_TAC (LHS_CONV (SIMP_CONV CR_cases_ss))
       THEN STRIP_TAC
       THENL [
          EXISTS_TAC (-+`(x :cl)`+-),
          EXISTS_TAC (-+`(c :cl)`+-),
          EXISTS_TAC (-+`(x :cl)`+-),
          EXISTS_TAC (-+`(z':cl)`+-)
       ] THEN ASM_SIMP_TAC prove_CR_ss,

       CONV_TAC (LHS_CONV (SIMP_CONV CR_cases_ss))
       THEN STRIP_TAC
       THENL [
          EXISTS_TAC (-+`((x#z)#(y#z))`+-),
          EXISTS_TAC (-+`((x#z)#(y#z))`+-),
          EXISTS_TAC (-+`((x#z')#(y#z'))`+-),
          EXISTS_TAC (-+`((x#z')#(z''#z'))`+-),
          EXISTS_TAC (-+`((z'''#z')#(z''#z'))`+-)
       ] THEN ASM_SIMP_TAC prove_CR_ss,

       CONV_TAC (LHS_CONV (SIMP_CONV CR_cases_ss))
       THEN STRIP_TAC
       THENL [
          EXISTS_TAC (-+`x#z`+-)
          THEN ASM_SIMP_TAC prove_CR_ss,

          ELIMINATE_TAC
          THEN DISJ_CASES_THEN STRIP_ASSUME_TAC kc_CASES_LEMMA
          THENL [
             EXISTS_TAC (-+`c:cl`+-),
             EXISTS_TAC (-+`z':cl`+-)
          ] THEN ASM_SIMP_TAC prove_CR_ss,

          ELIMINATE_TAC 
          THEN DISJ_CASES_THEN STRIP_ASSUME_TAC sxy_CASES_LEMMA THENL [
              EXISTS_TAC (-+`((x'#z)#(y'#z))`+-), 
              EXISTS_TAC (-+`((x'#z)#(z'#z))`+-), 
              EXISTS_TAC (-+`((z''#z)#(z'#z))`+-)
          ] THEN ASM_SIMP_TAC prove_CR_ss,

          RES_TAC THEN EXISTS_TAC (-+`d''#d`+-) THEN ASM_SIMP_TAC prove_CR_ss
       ]
    ]
);

(* --------------------------------------------------------------------- *)
(* We now do the following trivial proof.                                *)
(* --------------------------------------------------------------------- *)

val ss = hol_ss ++ [preduce,TC_PRESERVES_CR, CR_THEOREM];
val preduce_HAS_CR =
prove((-+`CR $===>*`+-),SIMP_TAC ss);

(* --------------------------------------------------------------------- *)
(* Q.E.D.                                                                *)
(* --------------------------------------------------------------------- *)

val ss = hol_ss ++ [preduce_HAS_CR, RED_EQ_PRED];
val CHURCH_ROSSER = prove(-+`CR $--->*`+-,SIMP_TAC ss);;

(* --------------------------------------------------------------------- *)
(* End of example.                                                       *)
(* --------------------------------------------------------------------- *)

close_theory();
export_theory();

@
