\chapter {Semantics of ML}
\label{MLsemantics}

The evaluation\index{evaluation, of ML constructs@evaluation, of \ML\ constructs}
of all \ML\ constructs takes place in the context of an {\it
environment\/}\index{environments, in ML evaluations@environments, in \ML\ evaluations} and a {\it store\/}\index{stores}.  The environment specifies what the
variables and constructors in use denote.  Variables\index{variables, in ML@variables, in \ML} may be bound either to
{\it values\/}\index{values, of ML variables@values, of \ML\ variables} or to {\it locations\/}\index{locations}.  The contents of locations---which
must be values---are specified in the {\it store\/}.  If a variable is
bound to a location then (and only then) is it {\it assignable\/}\index{assignable variables, in ML@assignable variables, in \ML}\index{variables, in ML@variables, in \ML!assignable}.
Thus bindings are held in the environment, whereas location contents are held in
the store.  Constructors may only be bound to values (constructor constants
or constructor functions) and this binding occurs when they are declared in
a concrete type definition (see Section~\ref{ML-concrete-types}).

The evaluation of \ML\ constructs may either {\it succeed\/} or {\it fail\/}.
In the case of success:

\begin {enumerate}

\item The evaluation of a declaration, $d$ say, changes the 
bindings\index{scope!of bindings}\index{bindings, in ML@bindings, in \ML!effect of declarations on}
in the environment of the identifiers declared in $d$.  If $d$ is
at top-level\index{declarations, in ML@declarations, in \ML!at top level}\index{top level, of ML@top level, of \ML!declarations at}\index{ML@\ML!top level of},
then the scope\index{bindings, in ML@bindings, in \ML!scope of} of the binding is everything following $d$.  In $d${\small\verb% in %}$e$ the scope of $d$ is
the evaluation of $e$, and so when this is finished the environment
reverts to its original state (see Section~\ref{ML-declarations}).

\item The evaluation of an expression yields a value: the value of the
expression (see Section~\ref{ML-expressions}).

\end {enumerate}


If an assignment is done during an evaluation, then the store will be
changed---we shall refer to these changes as {\it side
effects\/}\index{side effects, in ML@side effects, in \ML} of the evaluation.

\index{failure, in ML@failure, in \ML|(}
If the evaluation of a construct fails, then failure is signalled, and a string
is passed to the context which invoked the evaluation.  This  string is called
the {\it failure string\/}, and it normally indicates the cause of the failure.
During evaluation, failures  may  be  generated  either  {\it implicitly\/}\index{failure, in ML@failure, in \ML!implicit} by
certain error conditions, or {\it explicitly\/}\index{failure, in ML@failure, in \ML!explicit} by the construct
{\small\verb%failwith %}$e$\index{failwith@\ml{failwith}}
(which fails with $e$'s value as failure
string).  For  example,  the  evaluation  of  the expression {\small\verb%1/0%}
fails implicitly  with  failure  string  {\small\verb%`div`%},  whilst  that of
{\small\verb%failwith `%}$str${\small\verb%`%} fails explicitly with 
failure string
{\small\verb%`%}$str${\small\verb%`%}.  We shall say two  evaluations fail
 {\it similarly\/}\index{failure, in ML@failure, in \ML!similar} if
they both fail with the  same failure  string. 
 For example,  the evaluation of
{\small\verb%1/0%} and  {\small\verb%failwith `div`%}  fail  similarly.   Side
effects are not undone by failures.

If during the evaluation of a construct a failure is generated, then unless
the construct is a failure trap (\ie\ an expression built from
{\small\verb%?%}
and/or {\small\verb%!%}) the evaluation of the construct itself fails 
similarly.
Thus failures propagate up until trapped, or reaching top level. For
example, when evaluating {\small\verb%(1/0)+1000%}, the expression
{\small\verb%1/0%} is first
evaluated, and the failure which this evaluation
generates causes the evaluation of the
whole expression (viz.\ {\small\verb%(1/0)+1000%}) to fail with {\small\verb%`div`%}.  On
the other hand, the evaluation of {\small\verb%(1/0)?1000%} traps the failure
generated by the evaluation of {\small\verb%1/0%},
and succeeds with value {\small\verb%1000%}. (In
general, the evaluation of $e_1${\small\verb%?%}$e_2$ proceeds by first 
evaluating $e_1$, and if this succeeds with value $E$, then $E$ is
returned as the value of $e_1${\small\verb%?%}$e_2$; however, if $e_1$ fails,
then the result of evaluating $e_1${\small\verb%?%}$e_2$ is determined 
by evaluating $e_2$).
\index{failure, in ML@failure, in \ML|)}

In describing  evaluations\index{evaluation, of ML constructs@evaluation,
of \ML\ constructs!control flow in}, 
when  we  say  that  we  {\it pass  control\/} to a
construct, we mean that the outcome of the evaluation is  to be  the outcome of
evaluating the construct.  For example, if when evaluating 
$e_1${\small\verb%?%}$e_2$
the evaluation of $e_1$ fails, then we pass control to $e_2$.

Expressions and patterns can be optionally decorated with types by writing
{\small\verb%:%}$ty$\index{ type constraint, in ML@{\small\verb+:+} (type constraint, in \ML)} after them (\eg\ {\small\verb%[]:int list%}).  The effect 
of this
is to force the type checker\index{type checking, in ML@type checking, in \ML}\index{ML@\ML!type checking of}
to assign an instance of the asserted type to
the construct; this is useful as a way of constraining types more than the
type checker would otherwise (\ie\ more than context demands), and it
can also serve as helpful documentation.  Details of types and type
checking are given in Chapter~\ref{ML-types}, and will be ignored in 
describing the evaluation of \ML\ constructs in the rest of this section.

If we omit types, precedence information and those constructs which are
equivalent to others, then the syntax\index{syntax of ML@syntax
of \ML!short form}\index{ML@\ML!short form of syntax of} of \ML\ can be 
summarised by: 

\begin{hol}
{\small\verb%   %}$d${\small\verb% ::= let %}$b${\small\verb% | letref %}$b${\small\verb% | letrec %}$b$
\end{hol}

\begin{hol}
{\small\verb%   %}$b${\small\verb% ::= %}$p${\small\verb%=%}$e${\small\verb% | var %}$p_1 p_2
\ldots p_n${\small\verb%= %}$e${\small\verb% | %}$b_1${\small\verb% and %}$b_2 \ldots${\small\verb% and %}$b_n$
\end{hol}

\begin{hol}\index{wildcard, in ML@wildcard, in \ML}\index{ wildcard, in ML@{\small\verb+_+} (wildcard, in \ML)}
{\small\verb%   %}$p${\small\verb% ::= _ | %}$ce${\small\verb% | %}$var${\small\verb% | %}$con$ $p${\small\verb% | %}$p_1${\small\verb%.%}$p_2${\small\verb% | %}$p_1${\small\verb%,%}$p_2${\small\verb% | [] | [%}$p_1${\small\verb%;%}$p_2 \ldots${\small\verb% ;%}$p_n${\small\verb%]%}
\end{hol}

\noindent\begin{tabular}{@{}l}
{\small\verb%    %}$e${\small\verb% ::= %}$ce${\small\verb% | %}$var${\small\verb% | %}$con${\small\verb% | %}$e_1 e_2$\\
{}\\
{\small\verb%       | %}$px$ $e${\small\verb% | %}$e_1$ $ix$ $e_2${\small\verb% | %}$p${\small\verb%:=%}$e${\small\verb% | failwith %}$e$\\
{}\\
{\small\verb%       |  if %}$e_1${\small\verb% {then|loop} %}$e_{1}'$\\
{\small\verb%         {if %}$e_2${\small\verb% {then|loop} %}$e_{2}'$\\
{\small\verb%                     %}$\vdots$\\
{\small\verb%          if %}$e_n${\small\verb% {then|loop} %}$e_{n}'${\small\verb%} {{else|loop} %}$e'${\small\verb%}%}\\
{}\\
{\small\verb%       | %}$e${\small\verb% {??|!!} %}$e_1 e_{1}'$\\
{\small\verb%           {??|!!} %}$e_2 e_{2}'$\\
{\small\verb%              %}$\vdots$\\
{\small\verb%           {??|!!} %}$e_{n} e_{n}'${\small\verb% {{?|!|?\%}$id${\small\verb%|!\%}$id${\small\verb%} %}$e'${\small\verb%}%}\\
{}\\
{\small\verb%       | while %}$e_1${\small\verb% do %}$e_2$\\
{\small\verb%       | %}$e_1${\small\verb%;%}$e_2 \ldots${\small\verb% ;%}$e_n${\small\verb% | [] | [%}$e_1${\small\verb%;%}$e_2 \ldots${\small\verb% ;%}$e_n${\small\verb%] | %}$d${\small\verb% in %}$e$\\
{\small\verb%       | \%}$p_1 p_2 \ldots p_n${\small\verb%. %}$e$\\
{\small\verb%       | fun %}$p_1${\small\verb% . %}$e_1${\small\verb% | %}$p_2${\small\verb% . %}$e_2${\small\verb% | %}$\ldots${\small\verb% | %}$p_n${\small\verb% . %}$e_n$\\
\end{tabular}

\section{Declarations}\label{ML-declarations}

Any declaration must be one of the three kinds: {\small\verb%let %}$b$,
{\small\verb%letref %}$b$ or {\small\verb%letrec %}$b$, where $b$ is 
a binding.
Each such declaration is evaluated by first evaluating the binding $b$
to produce a (possibly empty) set of variable-value pairs, and then
extending the environment (in a manner determined by the kind of
declaration) so that each variable in this set of pairs denotes
its corresponding value.  The evaluation of bindings is described  below
in Section~\ref{eval-bindings}.

\begin {enumerate}

\item Evaluating {\small\verb%let %}$b$\index{let in@\ml{let} $\ldots$ \ml{in} $\ldots$!evaluation of} declares the variables specified in
$b$ to be an 
ordinary\index{ordinary variables, in ML@ordinary variables, in \ML} (\ie\ non assignable) variable, and binds (in the
environment) each one to the corresponding value produced by evaluating
$b$.  To understand what are the variables defined in a declaration
may require some knowledge about the environment.  For example, a
declaration {\small\verb%let f %}$x${\small\verb% = %}$e$ declares
$x$ if {\small\verb%f%} is a
constructor and declares {\small\verb%f%} as the function
{\small\verb%(\%}$x${\small\verb% . %}$e${\small\verb%)%} otherwise.

\item Evaluating {\small\verb%letref %}$b$\index{letref in@\ml{letref} $\ldots$ \ml{in} $\ldots$!evaluation of} declares the variables specified in
$b$ to be assignable\index{assignable variables, in ML@assignable variables, in \ML} and thus binds (in the environment) each one to a
new location, whose contents (in the store) is set to the corresponding
value.  The effect of subsequent assignments to the variables will be to
change the contents of the locations they are bound to.  Bindings (in the
environment) of variables to locations can only be changed by evaluating
another declaration to supersede the original one.

\item Evaluating {\small\verb%letrec %}$b$\index{letrec in@\ml{letrec} $\ldots$ \ml{in} $\ldots$!evaluation of} is similar to evaluating
{\small\verb%let %}$b$
except that:
\begin{enumerate}
\item The binding $b$ in {\small\verb%letrec %}$b$ must consist only of
function definitions.
\item These functions are made mutually recursive.
\end{enumerate}
For example, consider:
\begin{itemize}
\item {\small\verb%let f n = if n=0 then 1 else n*f(n-1)%}
\item {\small\verb%letrec f n = if n=0 then 1 else n*f(n-1)%}
\end{itemize}
The meaning of {\small\verb%f%} defined by the first case depends on whatever
{\small\verb%f%} is bound\index{bindings, in ML@bindings, in \ML!in function definitions|(} before the declaration is evaluated, whilst the
meaning of {\small\verb%f%} defined by the second case is independent 
of this (and is the factorial function).
\end{enumerate}

\subsection {The evaluation of bindings}\label{eval-bindings}

\index{bindings, in ML@bindings, in \ML!evaluation of|(}
There are three kinds of variable binding each of which, when evaluated,
produces a set of variable-value pairs (or fails):
\index{bindings, in ML@bindings, in \ML!kinds of|(}
\begin {enumerate}

\item {\it Simple bindings}
\index{bindings, in ML@bindings, in \ML!simple}
\index{simple bindings, in ML@simple bindings, in \ML}\\
which have the form $p${\small\verb%=%}$e$ where $p$ is a pattern and $e$
an expression\index{constant expressions, in ML@constant expressions, in \ML}.
\item {\it Function definitions}
\index{bindings, in ML@bindings, in \ML!multiple}
\index{multiple bindings, in ML@multiple bindings, in \ML}\\
which have the form $id$ $p_1 \ldots p_n${\small\verb% = %}$e$. 
This is just an abbreviation for the simple binding $id${\small\verb% = \%}$p_1 \ldots p_n${\small\verb%. %}$e$.
\item {\it Multiple bindings}\\
which have the form 
$b_1${\small\verb% and %}$b_2 \ldots${\small\verb% and %}$b_n$ where
$b_1,b_2 \ldots,b_n$ are simple bindings or function definitions.
As a function definition is just an abbreviation for a certain simple
binding, each $b_i$ ($0<i<n+1$) either is, or is an abbreviation for,
some simple binding $v_i = e_i$.  The multiple binding
$b_1${\small\verb% and %}$b_2 \ldots${\small\verb% and %}$b_n$ then abbreviates
$p_1${\small\verb%,%}$p_2 \ldots${\small\verb%,%}$p_n${\small\verb% = %}$e_1${\small\verb%,%}$e_2 \ldots e_n$, which is a simple binding.

\end {enumerate}\index{bindings, in ML@bindings, in \ML!kinds of|)}
\index{bindings, in ML@bindings, in \ML!evaluation of}

As function definitions and multiple bindings are abbreviations
for simple bindings we need only describe the evaluation of the latter.

A simple binding $p${\small\verb%=%}$e$ is evaluated by first evaluating $e$ to
obtain a value $E$ (if the evaluation fails then the evaluation of
$p${\small\verb%=%}$e$ fails similarly). Next the pattern $p$
 is {\it matched\/}\index{matching, of patterns, in ML@matching, of patterns, in \ML|(}
with $E$ to see if they have the same form (precise details are
given in
Section~\ref{matching-patterns}).  If so, then to each identifier\index{variables, in ML@variables, in \ML!in expression evaluation} in
$p$ there is a corresponding component of $E$.  
The evaluation of
$p${\small\verb%=%}$e$ then returns the set of each identifier paired with its
corresponding component.  If $p$ and $E$ don't match then the
evaluation of $p${\small\verb%=%}$e$ fails with failure string 
{\small\verb%`%}$pattern${\small\verb%`%}.\index{bindings, in ML@bindings, in \ML!in function definitions|)}\index{bindings, in ML@bindings, in \ML!evaluation of|)}


\subsection {Matching patterns and expression values}\label{matching-patterns}

\index{patterns, in ML@patterns, in \ML!matching with values|(}
\index{pattern matching, in ML evaluations@pattern matching, in \ML\ evaluations|(}
When a pattern $p$ is matched with a value $E$, either the match
succeeds and a set of identifier-value pairs is returned (each identifier
in $p$ being paired with the corresponding component of $E$), or
the match fails.  We describe, by cases on $p$, the conditions for
$p$ to match $E$ and the sets of pairs returned:

\begin{itemize}

\item {\tt\_}\index{wildcard, in ML@wildcard, in \ML}\index{ wildcard, in ML@{\small\verb+_+} (wildcard, in \ML)}\\
Always matches $E$. The empty set of pairs is returned.

\item $ce$\\
Matches $E$ only if $ce$ is equal to 
$E$. The empty set of pairs is returned.

\item $var$\index{identifiers, in ML@identifiers, in \ML!in expression evaluation}\index{type variables, in ML@type variables, in \ML}\\
Always matches $E$.
The set consisting of $var$ paired with $E$ is returned.

\item $con$ $p$\index{constructions, in ML@constructions, in \ML}\\
If $E$ is not a value built with constructor
$con$, the match fails.  Otherwise 
$E = con${\small\verb%(%}$E'${\small\verb%)%} and the
result is obtained by matching $p$ with $E'$.

\item $p_1${\tt .}$p_2$\\
$E$ must be a non-empty list $E_1${\small\verb%.%}$E_2$ such
that $p_1$ matches $E_1$ and $p_2$ matches $E_2$.  The
union of the sets of pairs returned from matching $p_1$ with $E_1$
and $p_2$ with $E_2$ is returned.

\item $p_1${\tt ,}$p_2$\\
$E$ must be a pair\index{pairs, in ML@pairs, in \ML!in expression evaluation} 
$E_1${\small\verb%,%}$E_2$ such that
$p_1$ matches $E_1$ and $p_2$ matches $E_2$.  The union
of the sets of pairs returned from matching $p_1$ 
with $E_1$ and $p_2$ with $E_2$ is returned.

\item {\tt [}$p_1${\tt ;}$p_2 \ldots${\tt ;}$p_n${\tt ]}\index{lists, in ML@lists, in \ML!in expression evaluation}\index{list constructor, in ML@list constructor, in \ML!in expression evaluation}\\ 
$E$ must be a list
{\small\verb%[%}$E_1${\small\verb%;%}$E_2 \ldots${\small\verb% ;%}$E_n${\small\verb%]%} of length $n$ such that for each $i$
(where $0<i<n+1$) $p_i$ matches $E_i$. The union of the sets
of pairs returned by matching $p_i$ with $E_i$ is produced.

\end {itemize}

Thus if  $p$  matches $E$,  then $p$ and
$E$ have a similar `shape', and each  identifier in $p$
corresponds to some component of $E$ (namely that component paired
with the identifier in the set returned by the match).

Here are some examples:

\begin{enumerate}

\item
{\small\verb%[%}$x${\small\verb%;%}$y${\small\verb%;%}$z${\small\verb%]%} matches {\small\verb%[%}$1${\small\verb%;%}$2${\small\verb%;%}$3${\small\verb%]%} with $x$, $y$ and
$z$ corresponding to {\small\verb%1%},
{\small\verb%2%} and {\small\verb%3%} respectively.

\item
{\small\verb%[%}$x${\small\verb%;%}$y${\small\verb%;%}$z${\small\verb%]%} 
doesn't match {\small\verb%[1;2]%}% or {\small\verb%[1;2;3;4]%}.

\item $x${\small\verb%.%}$y$ matches {\small\verb%[1;2;3]%} with $x$ and
$y$ corresponding to {\small\verb%1%} and {\small\verb%[2;3]%}
respectively.  
%({\small\verb%E1.[E2;E3 ... ;En]%} = {\small\verb%[E1;E2;E3 ... ;En]%})

\item
$x${\small\verb%.%}$y$ doesn't match {\small\verb%1%} or {\small\verb%[]%}.

\item $x${\small\verb%,%}$y$ matches {\small\verb%1,2%} with $x$ and $y$
 corresponding to {\small\verb%1%} and {\small\verb%2%} respectively.

\item
$x${\small\verb%,%}$y$ doesn't match {\small\verb%[1;2]%}.

\item
{\small\verb%(%}$x${\small\verb%,%}$y${\small\verb%),[(%}$z${\small\verb%.%}$w${\small\verb%);_]%} matches {\small\verb%(1,2),[[3;4;5];[6;7]]%} with
$x$, $y$, $z$ and $w$ corresponding to {\small\verb%1%},
{\small\verb%2%}, {\small\verb%3%} and {\small\verb%[4;5]%} respectively.

\end{enumerate}
\index{matching, of patterns, in ML@matching, of patterns, in \ML|)}
\index{pattern matching, in ML evaluations@pattern matching, in \ML\ evaluations|)}
\index{patterns, in ML@patterns, in \ML!matching with values|)}

\section {Expressions}\label{ML-expressions}
\index{expressions, in ML@expressions, in \ML!evaluation of|(}

If the evaluation of an expression terminates\index{evaluation, of ML constructs@evaluation, of \ML\ constructs!termination of},
then either it succeeds with
some value, or it fails\index{failure, in ML@failure, in
\ML}\index{failure, in ML@failure, in \ML!side effects of}; in either case assignments performed during the 
evaluation may cause side effects\index{side effects, in ML@side effects,
in \ML}. 
If the evaluation succeeds with some
value we shall say that value is {\it returned\/}.

We shall describe the evaluation of expressions by considering the various
cases, in the order in which they are listed in the syntax equations.

\begin{itemize}

\item $ce$\\
The appropriate constant\index{constant expressions, in ML@constant expressions, in \ML} value is returned.

\item $var$
\index{identifiers, in ML@identifiers, in \ML!evaluation of}
\index{type variables, in ML@type variables, in \ML}
\index{variables, in ML@variables, in \ML!evaluation of}
\index{variables, in ML@variables, in \ML!ordinary}
\index{ordinary variables, in ML@ordinary variables, in \ML}\\
The value associated with $var$ is returned.  If $var$ is
ordinary, then the value returned is the value bound to $var$ in the
environment\index{environments, in ML evaluations@environments, in \ML\ evaluations|(}.  If $var$ is assignable, then the value returned is the
contents of the location to which $var$ is bound.

\item $con$\index{constructions, in ML@constructions, in \ML}\\
The value associated with $con$ is returned.
(see Section~\ref{ML-concrete-types})

\item $e_1$ $e_2$\index{combinations, in ML@combinations, in \ML}\index{function application, in ML@function application, in \ML!evaluation of}\\
$e_1$ and $e_2$ are evaluated and the result of applying
the value of $e_1$ (which must be a function) to that of $e_2$ is
returned. Due to optimisations in the \ML\ compiler, the order of evaluation
may vary.

\item $px$ $e$
\index{prefixes, in ML@prefixes, in \ML}\\
$e$ is evaluated and then the result of applying 
$px$ to the value of $e$ is returned. 
 {\small\verb%-%}$e$ and {\small\verb%not %}$e$ have the
obvious meanings; {\small\verb%do %}$e$ evaluates $e$ for 
its side effects\index{side effects, in ML@side effects, in \ML}
and then returns void.

\item $e_1$ $ix$ $e_2$\index{infixes, in ML@infixes, in \ML}\\
$e_1${\small\verb%&%}$e_2$\index{conjunction, in ML@conjunction, in \ML}\index{ conjunction, in ML@{\small\verb+&+} (conjunction, in \ML)}
is equivalent to {\small\verb%if %}$e_1${\small\verb% then %}$e_2${\small\verb% else false%} (so sometimes only $e_1$ needs be evaluated to evaluate
 $e_1${\small\verb%&%}$e_2$)


$e_1${\small\verb% or %}$e_2$\index{disjunction, in ML@disjunction, in \ML}\index{or@\ml{or}} is equivalent to {\small\verb%if %}$e_1${\small\verb% then true else %}$e_2$ (so
sometimes only $e_1$ needs to be evaluated to evaluate
$e_1${\small\verb% or %}$e_2$)

Except when $ix$ is {\small\verb%&%} or {\small\verb%or%},
$e_1$ and $e_2$ are evaluated in that order, and the result of applying
$ix$ to their two values returned.

$e_1${\small\verb%,%}$e_2$\index{pairs, in ML@pairs, in \ML!evaluation of}
\index{ pair constructor, in ML@{\small\verb+,+} (pair constructor, in \ML)}
 returns the pair with first component the value of
$e_1$, and second component the value of $e_2$; 
the meaning of the other infixes are given in Chapter~\ref{MLprims}.

\item $p${\small\verb%:=%}$e$\index{assignments, in ML@assignments, in \ML!evaluation of}\index{ assignment, in ML@{\small\verb+:=+} (assignment, in \ML)}\\
Every variable in $p$ must be 
assignable\index{assignable variables, in ML@assignable variables, in \ML}\index{variables, in ML@variables, in \ML!assignable}
and bound to some location\index{locations} in
the environment.  The effect of the assignment is to update the contents of
these locations (in the store)\index{stores} with the values corresponding to the
variables produced by evaluating the binding $p${\small\verb%=%}$e$ 
(see Section~\ref{eval-bindings}).  If
the evaluation of $e$ fails, then no updating of locations occurs, and
the assignment fails similarly.  If the matching to $p$ fails, then
the assignment fails with {\small\verb%`%}$pattern${\small\verb%`%}.  The 
value of $p${\small\verb%:=%}$e$ is the value of $e$.

\item {\small\verb%failwith %}$e$
\index{failure, in ML@failure, in \ML|(}
\index{failure, in ML@failure, in \ML!constructs for|(}
\index{failwith@\ml{failwith}}\\
$e$ is evaluated and then a failure with $e$'s value (which must be a string)
 is generated.



\item \index{evaluation, of ML constructs@evaluation, of \ML\ constructs!control flow in|(}\index{if loop else@{\small if $\cdots$ loop $\cdots$ else $\cdots$}!evaluation of|(}\index{if loop loop@{\small if $\cdots$ loop $\cdots$ loop $\cdots$}|(}
 \mbox{}{\small\verb% if %}$e_1${\small\verb% {then|loop} %}$e_{1}'$\\
         \mbox{}{\small\verb%{if %}$e_2${\small\verb% {then|loop} %}$e_{2}'$\\
         \mbox{}{\small\verb%   %}$\vdots$\\
         \mbox{}{\small\verb% if %}$e_n${\small\verb% {then|loop} %}$e_{n}'${\small\verb%} {{else|loop} %}$e'${\small\verb%}%}\index{conditional loop construct, in ML@conditional/loop construct, in \ML!evaluation of}
\index{if then else@{\small if $\cdots$ then $\cdots$ else $\cdots$}}
\index{if then loop@{\small if $\cdots$ then $\cdots$ loop $\cdots$}}

\noindent $e_1${\small\verb%,%}$e_2${\small\verb%, %}$\ldots${\small\verb% ,%}$e_n$ are evaluated in turn until one of them,
$e_m$ say, returns true (each $e_i$ (for $0<i<n+1$) must
return either true or false).  When the phrase following $e_m$ is
{\small\verb%then %}$e_{m}'$ control is passed to $e_{m}'$; however when 
the phrase is {\small\verb%loop %}$e_{m}'$, then $e_{m}'$ is evaluated for 
its side effects,
and then control is passed back to the beginning of the whole expression
again (\ie\ to the beginning of {\small\verb%if %}$e_1 \ldots$).

In the case that all of $e_1${\small\verb%,%}$e_2 \ldots${\small\verb% ,%}$e_n$
 return false, and there is a
phrase following $e_{n}'$, then if this is {\small\verb%else %}$e'$ 
control is passed to $e'$, whilst if it is {\small\verb%loop %}$e'$ 
then $e'$ is
evaluated for its side effects and control is then passed back to the
beginning of the whole expression again.

In the case that all of $e_1${\small\verb%,%}$\ldots${\small\verb%,%}$e_n$
 return false, but no phrase
follows $e_{n}'$---\ie\ the option {\small\verb%{{else|loop} %}$e'${\small\verb%}%} is absent---then empty (the unique value of type 
{\small\verb%void%})\index{void@\ml{void}} is returned.
\index{if loop else@{\small if $\cdots$ loop $\cdots$ else $\cdots$}!evaluation of|)}
\index{if loop loop@{\small if $\cdots$ loop $\cdots$ loop $\cdots$}|)}


\item \mbox{}$e${\small\verb% {??|!!} %}$e_{1} e_{1}'$\\
      \mbox{}{\small\verb%  {??|!!} %}$e_2 e_{2}'$\\
      \mbox{}{\small\verb%    %}$\vdots$\\
      \mbox{}{\small\verb%  {??|!!} %}$e_n e_{n}'${\small\verb% {{?|!|?\%}$id${\small\verb%|!\%}$id${\small\verb%} %}$e'${\small\verb%}%}

\noindent $e$ is evaluated and if this succeeds its value is returned.

In the case that $e$ fails, with failure 
string\index{strings, in ML@strings, in \ML!to identify failures}
\index{failure, in ML@failure, in \ML!iterative selective trapping of}\index{failure, in ML@failure, in \ML!iterative trapping of}\index{failure, in ML@failure, in \ML!selective trapping of}\index{failure, in ML@failure, in \ML!trapping of}
 $str$ say, then
each of $e_1${\small\verb%,%}$e_2 \ldots${\small\verb% ,%}$e_n$ are evaluated
 in turn until one of them, $e_m$ say, returns a string list containing $str$
(each $e_i$
(for $0<i<n+1$) must return a string list).  If {\small\verb%??%}
immediately precedes $e_m$, then control is passed to $e_{m}'$;
however if {\small\verb%!!%} precedes it, then $e_{m}'$ is 
evaluated and
control is passed back to the beginning of the whole expression (\ie\ to
the beginning of $e${\small\verb% {??|!!} ... %}).

If none of $e_1${\small\verb%,%}$e_2 \ldots${\small\verb% ,%}$e_n$ returns 
a string list containing
$str$, and nothing follows $e_{n}'$ (\ie\ the option
{\small\verb%{{ ... }\ %}$e'${\small\verb%}%} is absent), then the whole 
expressions fails with $str$ (\ie\ fails similarly to $e$).

If none of $e_1$,$e_2 \ldots,e_n$ produces a string list containing
$str$, and {\small\verb%?\ %}$e'$ follows $e_{n}'$, 
then control is passed
to $e'$.  But if {\small\verb%!\ %}$e'$ follows $e_{n}'$, 
then $e'$ is evaluated, and control is passed back to the beginning of the 
whole expression.

If {\small\verb%?\%}$id$ $e'$ or {\small\verb%!\%}$id$ $e'$ follows
$e_{n}'$, then $e'$ is evaluated in an environment
in which $id$ is
bound to the failure string $str$ (\ie\ an evaluation equivalent to
{\small\verb%let %}$id${\small\verb%=%}$str${\small\verb% in %}$e'$ 
is done), and then depending on whether it
was {\small\verb%?\%} or {\small\verb%!\%} that occurred, the 
value of $e'$ is returned or control
is passed back to the beginning of the whole expression
respectively.\index{evaluation, of ML constructs@evaluation, of \ML\ constructs!control flow in|)}\index{failure, in ML@failure, in \ML!constructs for|)}\index{failure, in ML@failure, in \ML|)}


\item {\small\verb%while %}$e_1${\small\verb% do %}$e_2$\index{conditional loop construct, in ML@conditional/loop construct, in \ML!evaluation of|(}
\index{while construct, in ML@while construct, in \ML|(}
\index{while do@{\small\ml{while}$\cdots$\ml{do}$\cdots$}!evaluation of|(}\\
The evaluation of this expression always returns {\small\verb%()%} 
when it succeeds.
$e_1$ is evaluated first.  If the result is false the 
evaluation stops and returns {\small\verb%()%}.  
If the result is true $e_2$ is evaluated and then
the whole construct again.\index{conditional loop construct, in ML@conditional/loop construct, in \ML!evaluation of|)}\index{while construct, in ML@while construct, in \ML|)}\index{while do@{\small\ml{while}$\cdots$\ml{do}$\cdots$}!evaluation of|)}


\item $e_1${\small\verb%;%}$e_2 \ldots${\small\verb% ;%}$e_n$\index{sequences, in ML@sequences, in \ML}\index{sequencing!of ML expressions@of \ML\ expressions}\\
$e_1${\small\verb%,%}$e_2 \ldots${\small\verb% ,%}$e_n$ are evaluated in that
 order, and the value of $e_n$ is returned.

\item {\small\verb%[%}$e_1${\small\verb%;%}$e_2 \ldots${\small\verb% ;%}$e_n${\small\verb%]%}
\index{lists, in ML@lists, in \ML!evaluation of}\\
$e_1,e_2, \ldots ,e_n$ are evaluated in that order and the list of their values
returned.  {\small\verb%[]%} evaluates to the empty list.

\item $d${\small\verb% in %}$e$
\index{let in@\ml{let} $\ldots$ \ml{in} $\ldots$!evaluation of}\index{letref in@\ml{letref} $\ldots$ \ml{in} $\ldots$!evaluation of}\index{letrec in@\ml{letrec} $\ldots$ \ml{in} $\ldots$!evaluation of}\\
$d$ is evaluated\index{declarations, in ML@declarations, in \ML!evaluation of}\index{declarations, in ML@declarations, in \ML!local}, and then $e$ is 
evaluated in the extended
environment and its value returned.  The declaration $d$ is local to
$e$, so that after the evaluation of $e$, the former environment is restored.

\item {\small\verb%\%}$p_1 p_2 \ldots p_n${\small\verb%. %}$e$\index{function abstraction, in ML@function abstraction, in \ML!evaluation of}\index{ function abstraction binder, in ML@{\small\verb+\+} (function
abstraction binder, in \ML)}\\
The evaluation of {\small\verb%\%}-expressions always succeeds
and yields a function value.  The environment in which
the evaluation occurs (\ie\ in which the function value
is created) is called the
{\it definition environment\/}.
\begin{enumerate}
\item Simple {\small\verb%\%}-expressions: {\small\verb%\%}$p${\small\verb%. %}$e$\\
{\small\verb%\%}$p${\small\verb%. %}$e$ evaluates to that function which when
 applied to some
argument yields the result of evaluating $e$ in the
current (\ie\ application time) store, and in the environment
obtained from the definition environment by binding any
variables in $p$ to the corresponding components of the
argument (see 3.1.1).

\item Compound {\small\verb%\%}-expressions: {\small\verb%\%}$p_1 p_2 \ldots p_n${\small\verb%. %}$e$\\
A {\small\verb%\%}-expression with more than one parameter is curried\index{currying, in ML@currying, in \ML}
\ie\ {\small\verb%\%}$p_1 p_2 \ldots p_n${\small\verb%. %}$e$ is 
exactly equivalent to
{\small\verb%\%}$p_1${\small\verb%.(\%}$p_2 \ldots${\small\verb% .\%}$p_n${\small\verb%. %}$e${\small\verb%) %}$\ldots$ whose meaning is given by 1.~above.
\end{enumerate}

Thus the free variables\index{free variables, in ML@free variables, in \ML!binding of}
in a function keep the same binding they had in the
definition environment.  So if a free variable is non-assignable in that
environment, then its value is fixed to the value it has there.  On the
other hand, if a free variable is assignable in the definition environment,
then it will be bound to a location. Although that binding is fixed, the
contents of the location in the store is not, and can be subsequently
changed with assignments.

\item {\small\verb%fun %}$p_1${\small\verb% . %}$e_1${\small\verb% | %}$p_2${\small\verb% . %}$e_2${\small\verb% | %}$\ldots${\small\verb% | %}$p_n${\small\verb% . %}$e_n$
\index{function (pattern) selection abstraction, in ML@function (pattern) selection abstraction, in \ML}
\index{fun@{\ml{fun$\cdots$}\ml{"|}\ml{$\cdots$}}!evaluation of}
This expression evaluates to that function which when applied to some value
$E$, matches each $p_i$ in turn to $E$ until one succeeds. If
say $p_i$ matches $E$, then $e_i$ is evaluated in the
environment obtained from the definition environment by binding any
variable in $p_i$ to the corresponding components of $E$. If no
match succeeds, the evaluation fails with {\small\verb%`%}$pattern${\small\verb%`%}.

\end{itemize}
\index{expressions, in ML@expressions, in \ML!evaluation of|)}
\index{environments, in ML evaluations@environments, in \ML\ evaluations|)}
