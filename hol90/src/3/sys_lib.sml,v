head	1.4;
access;
symbols
	HOL97:1.2.2.3.0.2
	bpHOL97:1.2.2.3
	hol90_9_alpha:1.2.2.2
	hol90_pre8_for_multiple_compilers:1.2.0.2
	hol90_pre8_after_donalds_separate_compilation_changes:1.2
	hol90_8_after_merging_Konrad_Elsa:1.1.1.1
	hol90_7_cleaned_up_original_branchtag:1.1.1.1.0.2
	hol90_7_cleaned_up_original:1.1.1.1
	hol90_7_cleaned_up_original:1.1.1;
locks; strict;
comment	@# @;


1.4
date	96.01.04.15.59.31;	author drs1004;	state Exp;
branches;
next	1.3;

1.3
date	95.12.18.11.38.25;	author drs1004;	state Exp;
branches;
next	1.2;

1.2
date	95.10.31.15.08.03;	author drs1004;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	95.10.16.13.30.22;	author rjb;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.16.13.30.22;	author rjb;	state Exp;
branches;
next	;

1.2.2.1
date	96.08.23.15.54.14;	author rjb;	state Exp;
branches;
next	1.2.2.2;

1.2.2.2
date	96.09.03.15.58.13;	author drs1004;	state Exp;
branches;
next	1.2.2.3;

1.2.2.3
date	96.10.01.13.14.14;	author rjb;	state Exp;
branches
	1.2.2.3.2.1;
next	;

1.2.2.3.2.1
date	97.06.11.17.54.09;	author kxs;	state Exp;
branches;
next	1.2.2.3.2.2;

1.2.2.3.2.2
date	97.06.24.14.54.40;	author kxs;	state Exp;
branches;
next	1.2.2.3.2.3;

1.2.2.3.2.3
date	97.07.11.15.33.48;	author kxs;	state Exp;
branches;
next	1.2.2.3.2.4;

1.2.2.3.2.4
date	97.07.18.17.10.37;	author mn200;	state Exp;
branches;
next	;


desc
@@


1.4
log
@io transformers moved to 0/
@
text
@structure Sys_lib :Sys_lib_sig = 
struct

open Library;

(*-------------------------------------------------------------------------
 *    Taken out by DRS for the time being, as these are being managed
 *    by CM.  
 * 
 * val prim_hol_lib = prim_hol_lib
 * val basic_hol_lib = basic_hol_lib
 * 
 * 
 * val hol_lib = Library.new_library
 *         {name = "HOL",
 *          doc ="Arithmetic, lists, trees, and recursive types. Preloaded.",
 *          path = !Globals.HOLdir,
 *          parents = [basic_hol_lib],
 *          theories = ["HOL"],
 *          code =  ["3/define_type.sig","3/define_type.sml",
 *                   "3/gstack.sig",     "3/gstack.sml",
 *                   "3/psyntax.sig",    "3/rsyntax.sig", 
 *                   "3/psyntax.sml",    "3/rsyntax.sml"],
 *          help = [],
 *          loaded = "fn() => \
 *          \      ((* if Globals.remake_theory_files *) \
 *          \       then (Globals.theory_path := tl (!Globals.theory_path); \
 *          \             close_theory(); export_theory()) \
 *          \       else (); \
 *          \       Theory.delete_cache(); \
 *          \       Globals.use_init_file := true; \
 *          \ PP.install_pp[\"Goalstack\",\"goalstack\"] Goalstack.pp_goalstack; \
 *          \ PP.install_pp[\"Goalstack\",\"proofs\"] Goalstack.pp_proofs; \
 *          \       use_string \"open Goalstack; open Implicit\"; \
 *          \       use_string \"open Define_type Sys_lib Rsyntax\"; \
 *          \       Portable.interp := true; \
 *          \       Install.install (!Globals.HOLdir); \
 *          \       Save_hol.save_hol (\"hol90.\"^Portable.arch); \
 *          \       Portable.store_hol_in_HOLdir := false)"};
 * 	
 *-----------------------------------------------------------------------*)


fun sys_lib_path s = (!Globals.HOLdir)^"library/"^s^"/"

(*-------------------------------------------------------------------------
 * Make some system libraries known
 * 
 *-----------------------------------------------------------------------*)

val string_lib = new_library
         {name = "string",
          doc = "The system string library, by Mike Gordon and Tom Melham",
          path = sys_lib_path "string",
          parents = [(* hol_lib *)],
          theories = ["string"],
          code = ["string_conv.sml","ascii_conv.sml","string_rules.sml"],
          help = [],
          loaded = "fn () => Globals.assert_strings_defined()"};
	 

val num_lib = new_library
        {name="num",
         doc = "The system library supporting proofs about numbers, due to John Harrison",
         path = sys_lib_path "num",
         parents = [(* hol_lib *)],
         theories = [],
         code = ["num_lib.sig","num_lib.sml"],
         help = [],
         loaded = "fn() => ()"};
	

val reduce_lib = new_library
        {name = "reduce",
         doc = "The system library for normalizing {bool,num} terms, by John Harrison",
         path = sys_lib_path "reduce",
         parents = [num_lib],
         theories = [],
         code = ["dest.sig","dest.sml",
                 "boolconv.sig","boolconv.sml",
                 "arithconv.sig","arithconv.sml",
                 "redconv.sig","redconv.sml",
                 "reduce_ss.sml"],
         help = ["entries/"],
         loaded = "fn() => ()"};
	

val arith_lib = new_library
        {name = "arith",
         doc = "The system linear arithmetic decision procedure library, by Richard Boulton",
         path = sys_lib_path "arith",
         parents = [reduce_lib],
         theories = [],
         code =["int_extra.sig", "int_extra.sml", 
                "arith_cons.sig", "arith_cons.sml",
                "term_coeffs.sig", "term_coeffs.sml", 
                "conv.sig", "qconv.sml", 
                "theorems.sig", "theorems.sml", 
                "thm_convs.sig", "thm_convs.sml", 
                "norm_bool.sig", "norm_bool.sml", 
                "norm_arith.sig", "norm_arith.sml", 
                "norm_ineqs.sig", "norm_ineqs.sml", 
                "solve_ineqs.sig", "solve_ineqs.sml", 
                "solve.sig", "solve.sml", 
                "rationals.sig", "rationals.sml", 
                "sup-inf.sig", "sup-inf.sml",
                "streams.sig", "streams.sml", 
                "sol_ranges.sig", "sol_ranges.sml",
                "exists_arith.sig", "exists_arith.sml", 
                "sub_and_cond.sig", "sub_and_cond.sml",
                "prenex.sig", "prenex.sml",
                "instance.sig", "instance.sml",
                "gen_arith.sig", "gen_arith.sml", 
                "arith.sig", "arith.sml"],
         help = ["entries/"],
         loaded = "fn() => Portable.use_string \"open Arith\""};
	

val set_lib = new_library
        {name="set",
         doc = "The system library of sets, due to Tom Melham and P. Leveilley",
         path=sys_lib_path "set",
         parents=[num_lib],
         theories=["set"],
         code=["gspec.sig","gspec.sml",
               "set_ind.sig","set_ind.sml",
               "fset_conv.sig","fset_conv.sml",
	       "set_ss.sml",
	       "../theories/src/ld_set.sml",
	       "mk_structs.sml"],
         help=["entries/"],
         loaded = "fn() => ()"};
	
val pred_set_lib = new_library
        {name="pred_set",
         doc = "The library of sets-as-predicates, due to Tom Melham and Ton Kalker",
         path=sys_lib_path "pred_set",
         parents=[num_lib],
         theories=["pred_set"],
         code=["../../set/src/gspec.sig","../../set/src/gspec.sml",
               "../../set/src/set_ind.sig","../../set/src/set_ind.sml",
               "../../set/src/fset_conv.sig","../../set/src/fset_conv.sml",
	       "../../set/src/set_ss.sml",
	       "../theories/src/ld_pred_set.sml",
	       "mk_structs.sml"],
         help=["entries/"],
         loaded = "fn() => ()"};
	
val unwind_lib = new_library
        {name="unwind",
         doc = "The system library for unwinding hardware lines, by Richard Boulton",
         path=sys_lib_path "unwind",
         parents = [(* hol_lib *)],
         theories = [],
         code = ["unwinding.sig","unwinding.sml"],
         help = ["entries/"],
         loaded = "fn () => ()"};
	
(*-------------------------------------------------------------------------
 * 
 *-----------------------------------------------------------------------*)

val hol88_lib = new_library
        {name="hol88",
         doc = "A library for compatibility with hol88, by Konrad Slind",
         path=sys_lib_path "hol88",
         parents = [(* hol_lib *)],
         theories = [],
         code = ["compat.sig", "compat.sml"],
         help = [],
         loaded = "fn () => ()"};
	
val ind_def_lib = new_library
        {name="ind_def",
         doc = "The system inductive definition package, by Tom Melham",
         path=sys_lib_path "ind_def",
         parents = [hol88_lib],
         theories = [],
         code = ["inductive_def.sig","inductive_def.sml"],
         help = [],
         loaded = "fn () => ()"};
	
val taut_lib = new_library
        {name="taut",
         doc = "The system tautology checker library, by Richard Boulton",
         path=sys_lib_path "taut",
         parents = [(* hol_lib *)],
         theories = [],
         code = ["taut.sig","taut.sml","taut_ss.sml"],
         help = ["entries/"],
         loaded = "fn () => ()"};
	
val utils_lib = new_library
       {name="utils",
        doc = "A library of useful functions, by Elsa Gunter",
        path=sys_lib_path "utils",
        parents = [(* hol_lib *)],
        theories = [],
        code = ["functions.sig","functions.sml"],
        help = [],
        loaded = "fn () => ()"};
       
val group_lib = new_library
       {name="group",
        doc = "The system library of groups, by Elsa Gunter",
        path=sys_lib_path "group",
        parents = [utils_lib],
        theories = ["elt_gp"],
        code = ["group_fun.sig","group_fun.sml"],
        help = [],
        loaded = "fn () => ()"};
       
val integer_lib = new_library
       {name="integer",
        doc = "The system library of integers, by Elsa Gunter",
        path = sys_lib_path "integer",
        parents = [group_lib],
        theories = ["integer"],
        code = ["integer_tac.sig","integer_tac.sml"],
        help = [],
        loaded = "fn () => ()"};
       

val abs_theory_lib = new_library
       {name="abs_theory",
        doc = "A library for abstract theory operations, by Phil Windley and David Shepherd",
        path = sys_lib_path "abs_theory",
        parents = [(* hol_lib *)],
        theories = [],
        code = ["abs_theory.sml"],
        help = [],
        loaded = "fn () => ()"};
       
val unity_lib = new_library
       {name     = "unity",
        doc      = "A library defining Chandy and Misra's UNITY logic, due to Flemming Andersen",
        path     = sys_lib_path "unity",
        parents  = [(* hol_lib *)],
        theories = ["comp_unity"],
        code     = ["leadsto_induct0.sml"],
        help     = [],
        loaded   = "fn () => \
            \(Globals.tilde_symbols := (\"~*\" :: !Globals.tilde_symbols); \
            \ map add_definitions_to_sml \
            \     [\"state_logic\",\"unless\",\"ensures\",\"leadsto\"];())"};
       
val prog_logic_lib = new_library
        {name     = "prog_logic",
         doc      = "Various programming logics in HOL, by Mike Gordon, translator: Matthew Morley",
         path     = sys_lib_path "prog_logic",
         parents  = [string_lib],
         theories = ["prog_logic"],
         code     = ["syntax_functions.sml","translation.sml","hol_match.sml",
                     "bnd_conv.sml","hoare_logic.sml","halts_logic.sml",
                     "prog_logic.sml"],
         help     = [],
         loaded   = "fn () => ()"};
	
val pair_lib = new_library
       {name = "pair",
        doc = "A library for manipulating pairs, by J. Grundy, translated by D. Shepherd",
        path = sys_lib_path "pair",
        parents = [(* hol_lib *)],
        theories = ["pair_thms"],
        code = ["syn.sml","basic.sml","both1.sml","all.sml","exi.sml",
		"both2.sml","conv.sml","open_pair.sml"],
        help = ["entries/"],
        loaded = "fn() => ()"};
       
val real_lib = new_library
       {name = "real",
        doc = "The system library for real numbers, by John Harrison",
        path = sys_lib_path "real",
        parents = [(* hol_lib *)],
        theories = ["TRANSC"],
        code = [],
        help = ["entries/"],
        loaded = "fn() => ()"};
       
val wellorder_lib = new_library
       {name = "wellorder",
        doc = "Theorems about the Axiom of Choice and wellordered sets, by John Harrison",
        path = sys_lib_path "wellorder",
        parents = [(* hol_lib *)],
        theories = ["WELLORDER"],
        code = [],
        help = ["entries/"],
        loaded = "fn() => ()"};
       
val window_lib = new_library
        {name    = "window",
         doc     = "Support for transformational reasoning, by Jim Grundy",
         path    = sys_lib_path "window",
         parents = [(* hol_lib *)],
         theories= ["window"],
         code    = ["ml_ext.sml", "hol_ext.sml", "relations.sml", "rules.sml",
                    "basic_close.sml", "eq_close.sml", "imp_close.sml",
                    "win_core.sml", "win.sml", "history.sml", "signal.sml",
                    "defined.sml", "inter.sml", "tty.sml", "tactic.sml",
                    "window.sml"],
         help    = ["defs/","entries/","thms/"],
         loaded  = "fn () => ()"};
	
val list_lib = new_library
        {name    = "list",
         doc     = "Extended support for lists, by Paul Curzon and Wai Wong",
         path    = sys_lib_path "list",
         parents = [(* hol_lib *)],
         theories= ["List"],
         code    = ["list_conv.sig", "list_conv1.sml", "list_conv2.sml"],
         help    = ["defs/","entries/","thms/"],
         loaded  = "fn () => ()"};
	
val res_quan_lib = new_library
        {name    = "res_quan",
         doc     = "Support for restricted quantification, by Wai Wong",
         path    = sys_lib_path "res_quan",
         parents = [(* hol_lib *)],
         theories= ["res_quan"],
         code    = ["cond_rewr.sig", "cond_rewr.sml",
                    "res_rules.sig", "res_rules.sml"],
         help    = ["entries/", "thms/"],
         loaded  = "fn () => ()"};
	
val word_lib = new_library
        {name    = "word",
         doc     = "Support for bit vectors, by Wai Wong",
         path    = sys_lib_path "word",
         parents = [num_lib, res_quan_lib, list_lib],
         theories= ["word"],
         code    = ["word_convs.sig", "word_convs.sml"],
         help    = ["entries/", "defs/", "thms/"],
         loaded  = "fn () => ()"};
	
val option_lib = new_library
        {name    = "option",
         doc     = "The trivial option datatype, by Donald Syme",
         path    = sys_lib_path "option",
         parents = [],
         theories= ["option"],
         code    = ["option_ss.sml"],
         help    = ["entries/", "defs/", "thms/"],
         loaded  = "fn () => ()"};
	
val pfun_lib = new_library
        {name    = "pfun",
         doc     = "A theory of partial functions, by Donald Syme",
         path    = sys_lib_path "pfun",
         parents = [option_lib],
         theories= ["pfun"],
         code    = ["pfun_ss.sml"],
         help    = ["entries/", "defs/", "thms/"],
         loaded  = "fn () => ()"};
	
val fmap_lib = new_library
        {name    = "fmap",
         doc     = "A theory of finite maps, by Donald Syme and Graham Collins",
         path    = sys_lib_path "fmap",
         parents = [],
         theories= ["fmap"],
         code    = ["fmap_ss.sml"],
         help    = ["entries/", "defs/", "thms/"],
         loaded  = "fn () => ()"};
	


end;
@


1.3
log
@Preterm and other changes, see 7.changes
@
text
@d7 35
a41 2
   Taken out by DRS for the time being, as these are being managed
   by CM.  
a42 2
val prim_hol_lib = prim_hol_lib
val basic_hol_lib = basic_hol_lib
d44 1
a44 35

val hol_lib = 
   (* if Globals.remake_theory_files *)
   (* then *)Library.new_library
        {name = "HOL",
         doc ="Arithmetic, lists, trees, and recursive types. Preloaded.",
         path = !Globals.HOLdir,
         parents = [basic_hol_lib],
         theories = ["HOL"],
         code =  ["3/define_type.sig","3/define_type.sml",
                  "3/gstack.sig",     "3/gstack.sml",
                  "3/psyntax.sig",    "3/rsyntax.sig", 
                  "3/psyntax.sml",    "3/rsyntax.sml"],
         help = [],
         loaded = "fn() => \
         \      ((* if Globals.remake_theory_files *) \
         \       then (Globals.theory_path := tl (!Globals.theory_path); \
         \             close_theory(); export_theory()) \
         \       else (); \
         \       Theory.delete_cache(); \
         \       Globals.use_init_file := true; \
         \ PP.install_pp[\"Goalstack\",\"goalstack\"] Goalstack.pp_goalstack; \
         \ PP.install_pp[\"Goalstack\",\"proofs\"] Goalstack.pp_proofs; \
         \       use_string \"open Goalstack; open Implicit\"; \
         \       use_string \"open Define_type Sys_lib Rsyntax\"; \
         \       Portable.interp := true; \
         \       Install.install (!Globals.HOLdir); \
         \       Save_hol.save_hol (\"hol90.\"^Portable.arch); \
         \       Portable.store_hol_in_HOLdir := false)"}
   else let val hlib = Library.find_library "HOL"
        in Library.move_library(hlib, !Globals.HOLdir);
           hlib
        end;
*)

d46 4
d51 1
a51 6
(* Make some system libraries known *)
fun sys_lib_path s = (!Globals.HOLdir)^"library/"^s^"/"

val string_lib = 
   (* if Globals.remake_theory_files *)
   (* then *)Library.new_library
d59 2
a60 2
          loaded = "fn () => Globals.assert_strings_defined()"}
    (* else Library.find_library "string" *)
d62 1
a62 3
val num_lib = 
   (* if Globals.remake_theory_files *)
   (* then *)Library.new_library
d70 2
a71 2
         loaded = "fn() => ()"}
   (* else Library.find_library "num"; *)
d73 1
a73 3
val reduce_lib = 
   (* if Globals.remake_theory_files *)
   (* then *)Library.new_library
d77 1
a77 1
         parents = [(* hol_lib *)],
d83 1
a83 1
                 "reduce.sml"],
d85 2
a86 2
         loaded = "fn() => ()"}
   (* else Library.find_library "reduce"; *)
d88 1
a88 3
val arith_lib =
   (* if Globals.remake_theory_files *)
   (* then *)Library.new_library
d116 2
a117 2
         loaded = "fn() => Portable.use_string \"open Arith\""}
    (* else Library.find_library "arith"; *)
d119 1
a119 3
val set_lib = 
   (* if Globals.remake_theory_files *)
   (* then *)Library.new_library
d127 4
a130 1
               "fset_conv.sig","fset_conv.sml"],
d132 3
a134 6
         loaded = "fn() => ()"}
   (* else Library.find_library "set"; *)

val pred_set_lib = 
   (* if Globals.remake_theory_files *)
   (* then *)Library.new_library
d140 6
a145 3
         code=["gspec.sig","gspec.sml",
               "set_ind.sig","set_ind.sml",
               "fset_conv.sig","fset_conv.sml"],
d147 3
a149 6
         loaded = "fn() => ()"}
   (* else Library.find_library "pred_set"; *)

val unwind_lib = 
   (* if Globals.remake_theory_files *)
   (* then *)Library.new_library
d157 7
a163 6
         loaded = "fn () => ()"}
   (* else Library.find_library"unwind"; *)
         
val hol88_lib = 
   (* if Globals.remake_theory_files *)
   (* then *)Library.new_library
d171 3
a173 6
         loaded = "fn () => ()"}
   (* else Library.find_library "hol88"; *)

val ind_def_lib = 
   (* if Globals.remake_theory_files *)
   (* then *)Library.new_library
d181 3
a183 6
         loaded = "fn () => ()"}
   (* else Library.find_library "ind_def"; *)
         
val taut_lib = 
   (* if Globals.remake_theory_files *)
   (* then *)Library.new_library
d189 1
a189 1
         code = ["taut.sig","taut.sml"],
d191 3
a193 6
         loaded = "fn () => ()"}
   (* else Library.find_library "taut"; *)

val utils_lib = 
   (* if Globals.remake_theory_files *)
   (* then *)Library.new_library
d201 3
a203 6
        loaded = "fn () => ()"}
   (* else Library.find_library "utils"; *)

val group_lib = 
   (* if Globals.remake_theory_files *)
   (* then *)Library.new_library
d211 3
a213 6
        loaded = "fn () => ()"}
    (* else Library.find_library"group"; *)

val integer_lib = 
   (* if Globals.remake_theory_files *)
   (* then *)Library.new_library
d221 2
a222 2
        loaded = "fn () => ()"}
   (* else Library.find_library "integer"; *)
d224 1
a224 3
val abs_theory_lib = 
   (* if Globals.remake_theory_files *)
   (* then *)Library.new_library
d232 3
a234 6
        loaded = "fn () => ()"}
   (* else Library.find_library "abs_theory"; *)

val unity_lib = 
   (* if Globals.remake_theory_files *)
   (* then *)Library.new_library
d243 5
a247 8
               \(Globals.tilde_symbols := (\"~*\" :: !Globals.tilde_symbols); \
               \ map add_definitions_to_sml \
               \     [\"state_logic\",\"unless\",\"ensures\",\"leadsto\"];())"}
   (* else Library.find_library "unity"; *)

val prog_logic_lib = 
   (* if Globals.remake_theory_files *)
   (* then *)Library.new_library
d257 3
a259 6
         loaded   = "fn () => ()"}
   (* else Library.find_library "prog_logic"; *)

val pair_lib = 
   (* if Globals.remake_theory_files *)
   (* then *)Library.new_library
d268 3
a270 6
        loaded = "fn() => ()"}
    (* else Library.find_library "pair"; *)

val real_lib = 
   (* if Globals.remake_theory_files *)
   (* then *)Library.new_library
d278 3
a280 6
        loaded = "fn() => ()"}
    (* else Library.find_library "real"; *)

val wellorder_lib = 
   (* if Globals.remake_theory_files *)
   (* then *)Library.new_library
d288 3
a290 6
        loaded = "fn() => ()"}
    (* else Library.find_library "wellorder"; *)

val window_lib = 
   (* if Globals.remake_theory_files *)
   (* then *)new_library
d302 3
a304 6
         loaded  = "fn () => ()"}
   (* else Library.find_library"window"; *)

val list_lib = 
   (* if Globals.remake_theory_files *)
   (* then *)new_library
d312 3
a314 6
         loaded  = "fn () => ()"}
   (* else Library.find_library"list"; *)

val res_quan_lib = 
   (* if Globals.remake_theory_files *)
   (* then *)new_library
d323 3
a325 6
         loaded  = "fn () => ()"}
   (* else Library.find_library"res_quan"; *)

val word_lib = 
   (* if Globals.remake_theory_files *)
   (* then *)new_library
d333 33
a365 2
         loaded  = "fn () => ()"}
   (* else Library.find_library"word"; *)
@


1.2
log
@First phase of hol90.8 development.  hol90 now compiles using NJSML-CM
108.5, with separate compilation of libraries.  System dependencies
have been isolated in the makefiles and "portable.sml".

This involved a large number of enhancments to the source files,
most of which are documented in the 7.changes file (or will be shortly).
See also the correpsonding email corrspondence between RJB, KLS, TFM,
JRH and DRS that happened during this development.
@
text
@d126 1
a126 1
         loaded = "fn() => Lib.eval_string \"open Arith\""}
@


1.2.2.1
log
@Added lib entries for the new libraries.
Modified loaded functions to work with Poly/ML.
Added a dummy lib entry for hol_lib.
@
text
@d42 1
a42 1
   (* else let val hlib = Library.find_library "HOL"
d45 1
a45 1
        end; *)
d47 1
a47 11
(* Dummy for contrib libraries *)
val hol_lib = 
    Library.new_library
        {name = "HOL",
         doc ="Arithmetic, lists, trees, and recursive types. Preloaded.",
         path = !Globals.HOLdir,
         parents = [(* basic_hol_lib *)],
         theories = ["HOL"],
         code =  [],
         help = [],
         loaded = "fn() => ()"};
d53 1
a53 1
val lite_lib = 
d56 9
a64 11
        {name = "lite",
         doc = "The system library to allow HOL-Lite code to be used in hol90, by Donald Syme",
         path = sys_lib_path "lite",
         parents = [(* hol_lib *)],
         theories = [],
         code = ["Lib.sig","Lib.sml",
                 "Trace.sml",
                 "Equal.sig","Equal.sml"],
         help = [],
         loaded = "fn() => ()"}
   (* else Library.find_library "lite"; *)
d66 1
a66 1
val ho_match_lib = 
d69 3
a71 74
        {name = "ho_match",
         doc = "The system library for higher order matching and rewriting, by John Harrison",
         path = sys_lib_path "ho_match",
         parents = [lite_lib],
         theories = [],
         code = ["Ho_net.sig","Ho_net.sml",
                 "Ho_match.sig","Ho_match.sml",
                 "Rewrite.sig","Rewrite.sml",
                 "Theorems.sig","Theorems.sml",
                 "Resolve.sig","Resolve.sml"],
         help = [],
         loaded = "fn() => ()"}
   (* else Library.find_library "ho_match"; *)

val refute_lib = 
   (* if Globals.remake_theory_files *)
   (* then *)Library.new_library
        {name = "refute",
         doc = "The system library to support refutation procedures, by John Harrison",
         path = sys_lib_path "refute",
         parents = [lite_lib,ho_match_lib],
         theories = [],
         code = ["AC.sig","AC.sml",
                 "Canon.sig","Canon.sml"],
         help = [],
         loaded = "fn() => ()"}
   (* else Library.find_library "refute"; *)

val fol_lib = 
   (* if Globals.remake_theory_files *)
   (* then *)Library.new_library
        {name = "fol",
         doc = "The system library of shadow syntax for FOL terms in NNF, by John Harrison",
         path = sys_lib_path "fol",
         parents = [lite_lib],
         theories = [],
         code = ["FOL.sig","FOL.sml",
                 "FOL_HOL.sig","FOL_HOL.sml"],
         help = [],
         loaded = "fn() => ()"}
   (* else Library.find_library "fol"; *)

val tab_lib = 
   (* if Globals.remake_theory_files *)
   (* then *)Library.new_library
        {name = "tab",
         doc = "The system tableau-based first order theorem prover library, by John Harrison",
         path = sys_lib_path "tab",
         parents = [lite_lib,refute_lib,fol_lib],
         theories = [],
         code = ["Tab.sig","Tab.sml"],
         help = [],
         loaded = "fn() => ()"}
   (* else Library.find_library "tab"; *)

val meson_lib = 
   (* if Globals.remake_theory_files *)
   (* then *)Library.new_library
        {name = "meson",
         doc = "The system MESON model elimination library, by John Harrison",
         path = sys_lib_path "meson",
         parents = [lite_lib,ho_match_lib,refute_lib,fol_lib],
         theories = [],
         code = ["Meson.sig","Meson.sml"],
         help = [],
         loaded = "fn() => ()"}
   (* else Library.find_library "meson"; *)

val decision_lib =
   (* if Globals.remake_theory_files *)
   (* then *)Library.new_library
        {name = "decision",
         doc = "The system decision procedure library, by Richard Boulton",
         path = sys_lib_path "decision",
d74 1
a74 23
         code =["lazy_thm.sig", "lazy_thm.sml",
                "lazy_rules.sml",
                "conv.sig", "qconv.sml",
                "support.sml",
                "norm_convs.sml",
                "norm_bool.sml",
                "decide.sml",
                "type_info.sml",
                "congruence.sml",
                "cong_pairs.sml",
                "cong_types.sml",
                "arith/theorems.sig", "arith/theorems.sml",
                "arith/thm_convs.sig", "arith/thm_convs.sml",
                "arith/arith_cons.sig", "arith/arith_cons.sml",
                "arith/ineq_coeffs.sig", "arith/ineq_coeffs.sml",
                "arith/arith.sig", "arith/arith.sml",
                "taut.sig", "taut.sml",
                "num.sml",
                "prop.sml",
                "pair.sml",
                "types.sml",
                "uninterp.sml",
                "user.sml"],
d77 1
a77 1
    (* else Library.find_library "decision"; *)
a128 125
val simp_lib = 
   (* if Globals.remake_theory_files *)
   (* then *)Library.new_library
        {name = "simp",
         doc = "The system conditional/contextual simplifier library, by Donald Syme",
         path = sys_lib_path "simp",
         parents = [lite_lib,ho_match_lib,refute_lib,arith_lib],
         theories = [],
         code = ["Opening.sig","Opening.sml",
                 "Travrules.sig","Travrules.sml",
                 "Cond_rewr.sig","Cond_rewr.sml",
                 "Traverse.sig","Traverse.sml",
                 "Simplifier.sig","Simplifier.sml",
                 "Unify.sig","Unify.sml",
                 "Sequence.sig","Sequence.sml",
                 "Satisfy.sig","Satisfy.sml",
                 "Unwind.sig","Unwind.sml",
                 "Simpsets.sig","Simpsets.sml",
                 "Termtable.sig","Termtable.sml",
                 "Cache.sig","Cache.sml",
                 "arith_ss.sig","arith_ss.sml"],
         help = [],
         loaded = "fn() => ()"}
   (* else Library.find_library "simp"; *)

val automate_lib = 
   (* if Globals.remake_theory_files *)
   (* then *)Library.new_library
        {name = "automate",
         doc = "The system library for proof automation, by Richard Boulton",
         path = sys_lib_path "automate",
         parents = [ho_match_lib,tab_lib,meson_lib,decision_lib,simp_lib],
         theories = [],
         code = [],
         help = [],
         loaded = "fn() => Lib.eval_string \"open Simplifier Theorems " ^
                                            "open arith_ss " ^
(*                                            "open Arith " ^ *)
                                            "open Simpsets " ^
(*                                            "open Ho_rewrite " ^ *)
                                            "open Meson " ^
                                            "open Tab " ^
                                            "open DecisionUser " ^
(*                                            "open Resolve " ^ *)
(*                                            "open Trace " ^ *)
                                            "val arith_ss = hol_ss;\""}
   (* else Library.find_library "automate"; *)

val ind_def_new_lib = 
   (* if Globals.remake_theory_files *)
   (* then *)Library.new_library
        {name = "ind_def_new",
         doc = "The new system inductive/co-inductive definition package, by John Harrison",
         path = sys_lib_path "ind_def_new",
         parents = [lite_lib,ho_match_lib,refute_lib],
         theories = [],
         code = ["jrh-ind-defs.sig","jrh-ind-defs.sml"],
         help = [],
         loaded = "fn() => ()"}
   (* else Library.find_library "ind_def_new"; *)

val tfl_lib =
   (* if Globals.remake_theory_files *)
   (* then *)Library.new_library
        {name = "tfl",
         doc = "The system well-founded recursive function definition library, by Konrad Slind",
         path = sys_lib_path "tfl",
         parents = [arith_lib],
         theories = [],
         code =["mask.sig", "mask.sml",
                "utils.sig", "utils.sml",
                "usyntax.sig", "usyntax.sml",
                "rw.sig", "rw.sml", 
                "thms.sig", "thms.sml", 
                "rules.sig", "rules.sml", 
                "hol_datatype.sig", "hol_datatype.sml", 
                "thry.sig", "thry.sml", 
                "tfl.sig", "tfl.sml", 
                "Q.sig", "Q.sml", 
                "post.sml"],
         help = [],
         loaded = "fn() => Lib.eval_string \"open Tfl open RW infix 4 |-> " ^
                              "val Term = Parse.term_parser " ^
                              "val Type = Parse.type_parser;\""}
    (* else Library.find_library "tfl"; *)

val string_lib = 
   (* if Globals.remake_theory_files *)
   (* then *)Library.new_library
         {name = "string",
          doc = "The system string library, by Mike Gordon and Tom Melham",
          path = sys_lib_path "string",
          parents = [(* hol_lib *)],
          theories = ["string"],
          code = ["string_conv.sml","ascii_conv.sml","string_rules.sml"],
          help = [],
          loaded = "fn () => Globals.assert_strings_defined()"}
    (* else Library.find_library "string" *)

val option_lib = 
   (* if Globals.remake_theory_files *)
   (* then *)Library.new_library
         {name = "option",
          doc = "The system library for an ML-like option type, by Donald Syme",
          path = sys_lib_path "option",
          parents = [simp_lib],
          theories = ["option"],
          code = ["option_ss.sml"],
          help = [],
          loaded = "fn () => ()"}
    (* else Library.find_library "option" *)

val num_lib = 
   (* if Globals.remake_theory_files *)
   (* then *)Library.new_library
        {name="num",
         doc = "The system library supporting proofs about numbers, due to John Harrison",
         path = sys_lib_path "num",
         parents = [(* hol_lib *)],
         theories = [],
         code = ["num_lib.sig","num_lib.sml"],
         help = [],
         loaded = "fn() => ()"}
   (* else Library.find_library "num"; *)

a223 22
val retrieve_lib = 
   (* if Globals.remake_theory_files *)
   (* then *)Library.new_library
       {name = "retrieve",
        doc = "Theorem Retrieval Library, by R.J.Boulton, ported by D.R.Syme",
        path = sys_lib_path "retrieve",
        parents = [(* hol_lib *)],
        theories = [],
        code = ["exceptions.sig","exceptions.sml",
                "sets.sig","sets.sml",
                "extract.sig","extract.sml",
                "struct.sig","struct.sml",
                "name.sig","name.sml",
                "matching.sig","matching.sml",
                "sidecond.sig","sidecond.sml",
                "search.sig","search.sml",
                "user.sig","user.sml",
                "retrieve.sml"],
        help = ["entries/"],
        loaded = "fn () => ()"}
   (* else Library.find_library "retrieve"; *)

@


1.2.2.2
log
@I needed to make
reduce a parent library of simp:
@
text
@d240 1
a240 1
         parents = [lite_lib,ho_match_lib,refute_lib,reduce_lib,arith_lib],
@


1.2.2.3
log
@Corrected `doc' field of ind_def_new_lib.
@
text
@d286 1
a286 1
         doc = "The new system inductive definition package, by John Harrison",
@


1.2.2.3.2.1
log
@Changes made so that HOL builds on SMLNJ 109.26.
@
text
@d36 2
a37 2
         \       Lib.use_string \"open Goalstack; open Implicit\"; \
         \       Lib.use_string \"open Define_type Sys_lib Rsyntax\"; \
d231 1
a231 1
         loaded = "fn() => Lib.use_string \"open Arith\""}
d256 1
a256 1
         loaded = "fn() => Lib.use_string \"open arith_ss\""}
d269 1
a269 1
         loaded = "fn() => Lib.use_string \"open Simplifier Theorems " ^
d315 1
a315 1
         loaded = "fn() => Lib.use_string \"open Tfl open RW infix 4 |-> " ^
@


1.2.2.3.2.2
log
@Change to get meson_lib to depend on taut_lib
@
text
@d136 13
d259 23
a440 35
val meson_lib = 
   (* if Globals.remake_theory_files *)
   (* then *)Library.new_library
        {name = "meson",
         doc = "The system MESON model elimination library, by John Harrison",
         path = sys_lib_path "meson",
         parents = [lite_lib,ho_match_lib,refute_lib,fol_lib,taut_lib],
         theories = [],
         code = ["jrhtactics.sml", "canon_port.sml","Meson.sig","Meson.sml"],
         help = [],
         loaded = "fn() => ()"}
   (* else Library.find_library "meson"; *)

val automate_lib = 
   (* if Globals.remake_theory_files *)
   (* then *)Library.new_library
        {name = "automate",
         doc = "The system library for proof automation, by Richard Boulton",
         path = sys_lib_path "automate",
         parents = [ho_match_lib,tab_lib,meson_lib,decision_lib,simp_lib],
         theories = [],
         code = [],
         help = [],
         loaded = "fn() => Lib.use_string \"open Simplifier Theorems " ^
                                            "open arith_ss " ^
(*                                            "open Arith " ^ *)
                                            "open Simpsets " ^
(*                                            "open Ho_rewrite " ^ *)
                                            "open Meson " ^
                                            "open Tab " ^
                                            "open DecisionUser " ^
(*                                            "open Resolve " ^ *)
(*                                            "open Trace " ^ *)
                                            "val arith_ss = hol_ss;\""}
   (* else Library.find_library "automate"; *)
@


1.2.2.3.2.3
log
@Updates to make HOP CM-friendly. gstack.sml.0 deleted because it was just a
security copy.
@
text
@a3 2
type lib = Library.lib;

d6 1
a6 1
(*----------------------------------------------------------------------------
d46 1
a46 1
 *---------------------------------------------------------------------------*)
d72 2
a73 3
                 "Trace.sig", "Trace.sml",
                 "Equal.sig","Equal.sml",
                 "liteLib.sml"],
a88 1
                 "Resolve.sig","Resolve.sml",
d90 1
a90 1
                 "ho_matchLib.sml"],
d92 1
a92 1
         loaded = "fn () => ()"}
d103 2
a104 1
         code = ["AC.sig","AC.sml", "Canon.sig","Canon.sml", "refuteLib.sml"],
d118 1
a118 2
                 "FOL_HOL.sig","FOL_HOL.sml",
                 "folLib.sml"],
d129 1
a129 1
         parents = [lite_lib,fol_lib,refute_lib],
d131 1
a131 1
         code = ["tabLib.sig","tabLib.sml"],
a135 15
val meson_lib = 
   (* if Globals.remake_theory_files *)
   (* then *)Library.new_library
        {name = "meson",
         doc = "The system MESON model elimination library, by John Harrison",
         path = sys_lib_path "meson",
         parents = [refute_lib],
         theories = [],
         code = ["jrhtactics.sml", 
                 "canon_port.sig","canon_port.sml",
                  "mesonLib.sig","mesonLib.sml"],
         help = [],
         loaded = "fn() => ()"}
   (* else Library.find_library "meson"; *)

d144 23
a166 30
         code = ["lazy_thm.sig", "lazy_thm.sml",
                 "lazy_rules.sml",
                 "conv.sig", "qconv.sml",
                 "support.sml",
                 "norm_convs.sml",
                 "norm_bool.sml",
                 "decide.sml",
                 "type_info.sml",
                 "congruence.sml",
                 "cong_pairs.sml",
                 "cong_types.sml",
                 "arith/theorems.sig", "arith/theorems.sml",
                 "arith/thm_convs.sig", "arith/thm_convs.sml",
                 "arith/arith_cons.sig", "arith/arith_cons.sml",
                 "arith/ineq_coeffs.sig", 
                 (case SysParams.MLdialect 
                    of SysParams.NinetySeven => "arith/ineq_coeffs.sml"
                     | SysParams.Ninety      => "arith/ineq_coeffs.90.sml"),
                 "arith/arith.sig", 
                 (case SysParams.MLdialect 
                    of SysParams.NinetySeven => "arith/arith.sml"
                     | SysParams.Ninety      => "arith/arith.90.sml"),
                 "taut.sig", "taut.sml",
                 "num.sml",
                 "prop.sml",
                 "pair.sml",
                 "types.sml",
                 "uninterp.sml",
                 "user.sml",
                 "decisionLib.sml"],
d168 1
a168 1
         loaded = "fn () => ()"}
d183 1
a183 1
                 "reduceLib.sml"],
d216 1
a216 2
                "arith.sig", "arith.sml",
                "arithLib.sml"],
d218 1
a218 1
         loaded = "fn() => Lib.use_string \"open arithLib.Arith\""}
d227 1
a227 1
         parents = [ho_match_lib,refute_lib,arith_lib],
d241 1
a241 2
                 "arith_ss.sig","arith_ss.sml",
                 "simpLib.sml"],
a245 26

(*
val automate_lib = 
   (* if Globals.remake_theory_files *)
   (* then *)Library.new_library
        {name = "automate",
         doc = "The system library for proof automation, by Richard Boulton",
         path = sys_lib_path "automate",
         parents = [ho_match_lib,tab_lib,meson_lib,decision_lib,simp_lib],
         theories = [],
         code = [],
         help = [],
         loaded = "fn() => Lib.use_string \"open Simplifier Theorems " ^
                                            "open arith_ss " ^
(*                                            "open Arith " ^ *)
                                            "open Simpsets " ^
(*                                            "open Ho_rewrite " ^ *)
                                            "open Meson " ^
                                            "open Tab " ^
                                            "open DecisionUser " ^
(*                                            "open Resolve " ^ *)
(*                                            "open Trace " ^ *)
                                            "val arith_ss = hol_ss;\""}
   (* else Library.find_library "automate"; *)
*)

d254 1
a254 1
         code = ["IndDef.sig","IndDef.sml"],
d266 16
a281 17
         theories = ["WF"],
         code = ["mask.sig", "mask.sml",
                 "utils.sig", "utils.sml",
                 "usyntax.sig", "usyntax.sml",
                 "rw.sig", "rw.sml", 
                 "loaded.sml",
                 "thms.sig", "thms.sml", 
                 "rules.sig", "rules.sml", 
                 "hol_datatype.sig", "hol_datatype.sml", 
                 "thry.sig", "thry.sml", 
                 "tfl.sig", 
                 (case SysParams.MLdialect 
                    of SysParams.NinetySeven => "tfl.sml"
                     | SysParams.Ninety      => "tfl.90.sml"),
                 "tflLib.sml"],
         help = [],
         loaded = "fn() => ()"}
d292 1
a292 2
          code = ["loaded.sml", "string_conv.sml","ascii_conv.sml",
                  "stringLib.sml"],
d305 1
a305 1
          code = ["loaded.sml","optionLib.sml"],
d318 1
a318 1
         code = ["numLib.sig","numLib.sml"],
d331 1
a331 2
         code=["loaded.sml",
               "gspec.sig","gspec.sml",
d333 1
a333 2
               "fset_conv.sig","fset_conv.sml",
               "setLib.sml"],
d346 1
a346 2
         code=["loaded.sml",
               "gspec.sig","gspec.sml",
d348 1
a348 2
               "fset_conv.sig","fset_conv.sml",
               "pred_setLib.sml"],
d361 1
a361 1
         code = ["unwindLib.sig","unwindLib.sml"],
d374 1
a374 1
         code = ["compat.sig", "compat.sml", "hol88Lib.sml"],
d387 1
a387 1
         code = ["ind_defLib.sig", "ind_defLib.sml"],
d400 1
a400 1
         code = ["tautLib.sig","tautLib.sml"],
d448 1
a448 1
        code = ["utilsLib.sig","utilsLib.sml"],
d470 1
a470 1
                "retrieveLib.sml"],
d483 1
a483 1
        code = ["loaded.sml","group_fun.sig","group_fun.sml"],
d496 1
a496 3
        code = ["loaded.sml",
                "integer_tac.sig","integer_tac.sml",
                "integerLib.sml"],
d509 1
a509 1
        code = ["abs_theory.sml", "abs_theoryLib.sml"],
d522 1
a522 1
        code     = ["loaded.sml","leadsto_induct0.sml", "unityLib.sml"],
d538 1
a538 2
         code     = ["loaded.sml",
                     "syntax_functions.sml","translation.sml","hol_match.sml",
d540 1
a540 1
                     "prog_logicLib.sml"],
d553 2
a554 3
        code = ["loaded.sml",
                "syn.sml","basic.sml","both1.sml","all.sml","exi.sml",
		"both2.sml","conv.sml","pairLib.sig", "pairLib.sml"],
d567 1
a567 1
        code = ["realLib.sml"],
d580 1
a580 1
        code = ["wellorderLib.sml"],
d582 1
a582 1
        loaded = "fn () => ()"}
d593 1
a593 3
         code    = ["loaded.sig", "loaded.sml",
                    "ml_ext.sig", "ml_ext.sml", "hol_ext.sig", "hol_ext.sml", 
                    "relations.sml", "rules.sml",
d597 1
a597 1
                    "windowLib.sig", "windowLib.sml"],
d610 1
a610 3
         code    = ["loaded.sml",
                    "list_conv.sig", "list_conv1.sml", "list_conv2.sml",
                    "listLib.sml"],
d623 2
a624 4
         code    = ["loaded.sml",
                    "cond_rewr.sig", "cond_rewr.sml",
                    "res_rules.sig", "res_rules.sml",
                    "res_quanLib.sig", "res_quanLib.sml"],
d637 1
a637 2
         code    = ["loaded.sml","word_convs.sig", "word_convs.sml",
                    "wordLib.sml"],
a640 30


val mutrec_lib = new_library
   {name = "mutrec",
    doc = "Mutually recursive type definition library, by E. Gunter",
    path = sys_lib_path "mutrec",
    parents = [utils_lib, num_lib],
    theories = [],
    code = ["mask.sml", "type_info.sml",
             "mut_rec_type_input.sig",
             "mut_rec_ty.sig", "mut_rec_ty.sml",
             "recftn.sml",
             "cons_thms.sig", "cons_thms.sml",
             "total_mut_rec_type_def.sml"],
     help = [],
     loaded = "fn () => ()"}


val nested_rec_lib = new_library
    {name = "nested_rec",
  doc = "Nested recursive type definition library, by H. Goguen and E. Gunter",
     path = sys_lib_path "nested_rec",
  parents = [mutrec_lib],
 theories = [],
     code = ["mask.sml", "gen_funs.sig","gen_funs.sml","exists_funs.sml",
             "table.sig","table.sml","entries.sml",
             "def_type.sig", "make_type_op.sml", "def_type.sml",
             "nested_rec_def.sml"],
     help = [],
   loaded = "fn () => ()"};
@


1.2.2.3.2.4
log
@Modified source to remove duplicate (wrong) definition of meson_lib,
and also removed commented out definition for automate_lib.
@
text
@d1 1
a1 1
structure Sys_lib :Sys_lib_sig =
d10 1
a10 1
   by CM.
d16 1
a16 1
val hol_lib =
d26 1
a26 1
                  "3/psyntax.sig",    "3/rsyntax.sig",
d50 1
a50 1
val hol_lib =
d65 1
a65 1
val lite_lib =
d81 1
a81 1
val ho_match_lib =
d99 1
a99 1
val refute_lib =
d112 1
a112 1
val fol_lib =
d127 1
a127 1
val tab_lib =
d140 14
d177 2
a178 2
                 "arith/ineq_coeffs.sig",
                 (case SysParams.MLdialect
d181 2
a182 2
                 "arith/arith.sig",
                 (case SysParams.MLdialect
d197 1
a197 1
val reduce_lib =
d222 1
a222 1
         code =["int_extra.sig", "int_extra.sml",
d224 10
a233 10
                "term_coeffs.sig", "term_coeffs.sml",
                "conv.sig", "qconv.sml",
                "theorems.sig", "theorems.sml",
                "thm_convs.sig", "thm_convs.sml",
                "norm_bool.sig", "norm_bool.sml",
                "norm_arith.sig", "norm_arith.sml",
                "norm_ineqs.sig", "norm_ineqs.sml",
                "solve_ineqs.sig", "solve_ineqs.sml",
                "solve.sig", "solve.sml",
                "rationals.sig", "rationals.sml",
d235 1
a235 1
                "streams.sig", "streams.sml",
d237 1
a237 1
                "exists_arith.sig", "exists_arith.sml",
d241 1
a241 1
                "gen_arith.sig", "gen_arith.sml",
d248 1
a248 1
val simp_lib =
d275 26
a300 1
val ind_def_new_lib =
d324 1
a324 1
                 "rw.sig", "rw.sml",
d326 6
a331 6
                 "thms.sig", "thms.sml",
                 "rules.sig", "rules.sml",
                 "hol_datatype.sig", "hol_datatype.sml",
                 "thry.sig", "thry.sml",
                 "tfl.sig",
                 (case SysParams.MLdialect
d339 1
a339 1
val string_lib =
d353 1
a353 1
val option_lib =
d366 1
a366 1
val num_lib =
d379 1
a379 1
val set_lib =
d396 1
a396 1
val pred_set_lib =
d413 1
a413 1
val unwind_lib =
d425 2
a426 2

val hol88_lib =
d439 1
a439 1
val ind_def_lib =
d451 2
a452 2

val taut_lib =
d465 1
a465 2

val meson_lib =
d471 1
a471 1
         parents = [lite_lib, ho_match_lib, refute_lib, fol_lib, taut_lib],
d473 1
a473 3
         code = ["jrhtactics.sml",
                 "canon_port.sig","canon_port.sml",
                  "mesonLib.sig","mesonLib.sml"],
d478 1
a478 1
val automate_lib =
d500 1
a500 1
val utils_lib =
d513 1
a513 1
val retrieve_lib =
d535 1
a535 1
val group_lib =
d548 1
a548 1
val integer_lib =
d563 1
a563 1
val abs_theory_lib =
d576 1
a576 1
val unity_lib =
d592 1
a592 1
val prog_logic_lib =
d608 1
a608 1
val pair_lib =
d623 1
a623 1
val real_lib =
d636 1
a636 1
val wellorder_lib =
d649 1
a649 1
val window_lib =
d658 1
a658 1
                    "ml_ext.sig", "ml_ext.sml", "hol_ext.sig", "hol_ext.sml",
d668 1
a668 1
val list_lib =
d683 1
a683 1
val res_quan_lib =
d699 1
a699 1
val word_lib =
@


1.1
log
@Initial revision
@
text
@d3 7
d15 2
a16 2
   if Globals.remake_theory_files
   then Library.new_library
d28 1
a28 1
         \      (if Globals.remake_theory_files \
d38 1
a38 1
         \       System.Control.interp := true; \
d40 2
a41 1
         \       Save_hol.save_hol (\"hol90.\"^Globals.arch))"}
d46 1
d51 1
a51 1
fun sys_lib_path s = (!HOLdir)^"library/"^s^"/"
d54 2
a55 2
   if Globals.remake_theory_files
   then Library.new_library
d59 1
a59 1
          parents = [hol_lib],
d64 1
a64 1
    else Library.find_library "string"
d67 2
a68 2
   if Globals.remake_theory_files
   then Library.new_library
d72 1
a72 1
         parents = [hol_lib],
d77 1
a77 1
   else Library.find_library "num";
d80 2
a81 2
   if Globals.remake_theory_files
   then Library.new_library
d85 1
a85 1
         parents = [hol_lib],
d94 1
a94 1
   else Library.find_library "reduce";
d97 2
a98 2
   if Globals.remake_theory_files
   then Library.new_library
d127 1
a127 1
    else Library.find_library "arith";
d130 2
a131 2
   if Globals.remake_theory_files
   then Library.new_library
d142 1
a142 1
   else Library.find_library "set";
d145 2
a146 2
   if Globals.remake_theory_files
   then Library.new_library
d157 1
a157 1
   else Library.find_library "pred_set";
d160 2
a161 2
   if Globals.remake_theory_files
   then Library.new_library
d165 1
a165 1
         parents = [hol_lib],
d170 1
a170 1
   else Library.find_library"unwind";
d173 2
a174 2
   if Globals.remake_theory_files
   then Library.new_library
d178 1
a178 1
         parents = [hol_lib],
d183 1
a183 1
   else Library.find_library "hol88";
d186 2
a187 2
   if Globals.remake_theory_files
   then Library.new_library
d196 1
a196 1
   else Library.find_library "ind_def";
d199 2
a200 2
   if Globals.remake_theory_files
   then Library.new_library
d204 1
a204 1
         parents = [hol_lib],
d209 1
a209 1
   else Library.find_library "taut";
d212 2
a213 2
   if Globals.remake_theory_files
   then Library.new_library
d217 1
a217 1
        parents = [hol_lib],
d222 1
a222 1
   else Library.find_library "utils";
d225 2
a226 2
   if Globals.remake_theory_files
   then Library.new_library
d235 1
a235 1
    else Library.find_library"group";
d238 2
a239 2
   if Globals.remake_theory_files
   then Library.new_library
d248 1
a248 1
   else Library.find_library "integer";
d251 2
a252 2
   if Globals.remake_theory_files
   then Library.new_library
d256 1
a256 1
        parents = [hol_lib],
d261 1
a261 1
   else Library.find_library "abs_theory";
d264 2
a265 2
   if Globals.remake_theory_files
   then Library.new_library
d269 1
a269 1
        parents  = [hol_lib],
d277 1
a277 1
   else Library.find_library "unity";
d280 2
a281 2
   if Globals.remake_theory_files
   then Library.new_library
d292 1
a292 1
   else Library.find_library "prog_logic";
d295 2
a296 2
   if Globals.remake_theory_files
   then Library.new_library
d300 1
a300 1
        parents = [hol_lib],
d306 1
a306 1
    else Library.find_library "pair";
d309 2
a310 2
   if Globals.remake_theory_files
   then Library.new_library
d314 1
a314 1
        parents = [hol_lib],
d319 1
a319 1
    else Library.find_library "real";
d322 2
a323 2
   if Globals.remake_theory_files
   then Library.new_library
d327 1
a327 1
        parents = [hol_lib],
d332 1
a332 1
    else Library.find_library "wellorder";
d335 2
a336 2
   if Globals.remake_theory_files
   then new_library
d340 1
a340 1
         parents = [hol_lib],
d349 1
a349 1
   else Library.find_library"window";
d352 2
a353 2
   if Globals.remake_theory_files
   then new_library
d357 1
a357 1
         parents = [hol_lib],
d362 1
a362 1
   else Library.find_library"list";
d365 2
a366 2
   if Globals.remake_theory_files
   then new_library
d370 1
a370 1
         parents = [hol_lib],
d376 1
a376 1
   else Library.find_library"res_quan";
d379 2
a380 2
   if Globals.remake_theory_files
   then new_library
d389 1
a389 1
   else Library.find_library"word";
@


1.1.1.1
log
@Sources of hol90.7 as released, cleaned up by R.J.Boulton and D.R.Syme.

Summary of changes:

 * "contrib" directory not included
 * Machine-generatable files deleted, e.g. .dvi, .ps, .thms, .holsig, .hol_lib
 * Some directory restructuring in "library", in particular help files for
   ML functions have been put in a help/entries subdirectory in cases where
   they were originally in the help directory itself.
@
text
@@
