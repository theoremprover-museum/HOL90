head	4.1;
access;
symbols
	HOL90-7:4.1;
locks; strict;
comment	@% @;


4.1
date	94.09.10.03.45.16;	author jim;	state Exp;
branches;
next	1.2;

1.2
date	94.09.09.16.28.03;	author jim;	state Exp;
branches;
next	1.1;

1.1
date	94.09.07.13.10.27;	author jim;	state Exp;
branches;
next	;


desc
@The Description chapter of the window library manual.
@


4.1
log
@Version released with HOL90.7
@
text
@\newcommand{\hand}{\tt/\symbol{"5C}}
\newcommand{\hor}{\tt\symbol{"5C}/}
\newcommand{\hnot}{\tt\symbol{"7E}}

\newcommand{\nn}[1]{#1n}

\index{<==@@{{\ptt <==} (backward implication)}|see{{\ptt PMI\_DEF}}}

\chapter{Statement of Rights}

Jim Grundy, hereafter referred to as `the Author', retains the
copyright and all other legal rights to the software contained in
the window library, hereafter referred to as `the Software'.
The Software is made available free of charge on an `as is' basis.
No guarantee, either express or implied, of maintenance, reliability,
merchantability or suitability for any purpose is made by the Author.

The user is granted the right to make personal or internal use
of the Software provided that both:
\begin{enumerate}
    \item   The Software is not used for commercial gain.
    \item   The user shall not hold the Author liable for any consequences
            arising from use of the Software.
\end{enumerate}
The user is granted the right to further distribute the Software
provided that both:
\begin{enumerate}
    \item   The Software and this statement of rights is not modified.
    \item   The Software does not form part or the whole of a system
            distributed for commercial gain.
\end{enumerate}
The user is granted the right to modify the Software for personal or
internal use provided that all of the following conditions are
observed:
\begin{enumerate}
    \item   The user does not distribute the modified software.
    \item   The modified software is not used for commercial gain.
    \item   The Author retains all rights to the modified software.
\end{enumerate}

Anyone seeking a license to use this software for commercial purposes
is invited to contact the Author.

\chapter{The window Library}

This manual describes the use of the window library.
The window library has been provided to facilitate a style of reasoning called
window inference.
Window inference should prove more useful than goal directed reasoning in
situations where fine manipulations are required,
when a proof is more easily progressed forwards than backwards,
or when a proof makes extensive use of contextual information.
Users interested in transformational design, refinement, calculational proof
and equational reasoning should find the window library interesting.

For more details on window inference, see:
\begin{center}
    \begin{minipage}{0.8\columnwidth}
	\small\noindent
	Jim Grundy.
	Window Inference in the HOL System.
	In Phillip J. Windley, Mylar Archer, Karl N. Levitt and
	Jeffrey J. Joyce, editors,
	{\it The Proceedings of the International Tutorial and Workshop on
	the HOL Theorem Proving System and its Applications},
	University of California at Davis, 28--30 August 1991.
	IEEE Computer Society / ACM SIGDA, IEEE Computer Society Press,
	10662 Los Vaqueros Circle, PO Box 3014,
	Los Alamitos CA 907020-1264, United States, 1992.
    \end{minipage}
\end{center}
\begin{center}
    \begin{minipage}{0.8\columnwidth}
	\small\noindent
	Jim Grundy.
	A Window Inference Tool for Refinement.
	In Cliff B. Jones, B. Tim Denvir and Roger C. F. Shaw, editors,
	{\it Proceedings of the 5th Refinement Workshop},
	Lloyd's Register, London, 8--10 January 1992.
	Springer-$\!$Verlag, London, 1992.
    \end{minipage}
\end{center}
\begin{center}
    \begin{minipage}{0.8\columnwidth}
	\small\noindent
	Jim Grundy.
	{\it A Method of Program Refinement}.
	PhD Thesis.
	Technical Report 318.
	University of Cambridge, Computer Laboratory, New Museums Site,
	Pembroke Street, Cambridge CB2 3QG, England.
    \end{minipage}
\end{center}

\section{Window Inference}

Window inference is a style of reasoning where the user may transform an
expression by restricting attention to a subexpression and transforming it.
While restricting attention to a subexpression, the user can transform the
subexpression without affecting the remainder of the enclosing expression.
Also, while transforming a subexpression, the user can make assumptions based
on the context of the subexpression.
For example, suppose a user wishes to transform the expression
\ml{`A \hand\ B`};
this may be done by transforming \ml{`A`} under the assumption \ml{`B`}.
It is possible to assume \ml{`B`} while transforming \ml{`A`},
because were \ml{`B`} false,
the enclosing expression \ml{`A \hand\ B`} would be false regardless of
\ml{`A`}.
Using contextual information in the transformation of subexpressions adds a
degree of complexity to the proof tree.
The advantage of the window-inference technique is that the user is shielded
from this added complexity.

In the window inference style of proof,
a user starts with an expression \ml{`P`} and transforms it to \ml{`Q`} such
that \ml{`P R Q`} for some relation
\ml{`R`};\footnote{\ml{`R`} denotes a preorder; or reflexive,
transitive relation.}
thus creating a proof that \ml{|- P R Q}.
Such a proof need be neither strictly forward nor backward.
Window inference encompasses both backward and forward reasoning.
The user may start with the expression \ml{`P`} and transform it to
\ml{`T`}(true) while preserving the relation
\ml{`<==`}\index{PMI\_DEF@@{\ptt PMI\_DEF}|nn}\footnote
{\ml{PMI\_DEF} \ml{|- !a, b. (a <== b) = (b ==> a)}}.
Such a process would build the theorem \ml{|- P <== T},
and would constitute a backward proof of \ml{`P`}.
Alternatively,
the user may start with the expression \ml{`T`} and transform it to
\ml{`P`} while preserving the relation \ml{`==>`}.
Such a process would build the theorem \ml{|- T ==> P},
and would constitute a forward proof of \ml{`P`}.

\section{Getting Started}	\label{sec:start}

Before you can use window inference in HOL you must load the
window library.
To load the window library, issue the following command:
\begin{hol}\begin{alltt}
    load_library{lib=window_lib,theory="foo"};
\end{alltt}\end{hol}
It is not always possible to load the window library.
This is because the library defines a small theory {\tt win}.
If you have loaded another theory before attempting to load the window
library, and you are not in draft mode, then you will not be able to 
load the window library.
If this happens, try \ml{load\_library\_in\_place}.

Within a window inference system,
    reasoning is conducted with a stack of windows.
Each window is comprised of a {\it focus}\index{focus},
$f$, that is the expression to be transformed,
a set of formulae $\Gamma$ called the {\it assumptions}\index{assumptions},
that can be assumed true in the context of the focus, and a
relation\index{relation} $R$\/ that
must relate the focus and the expression to which it is transformed.
(Note that the type of the focus is not restricted to booleans as is the
case with goals in the subgoal package.)
Such a window will be written as follows.
\begin{hol}\begin{alltt}
     ! \(\Gamma\)
   \(R\!\) * \(f\)
\end{alltt}\end{hol}\index{"!@@{{\ptt "!} (assumption prefix)}}

To begin using the system,
you create a window stack that contains a single window.
The focus of that window should be the expression you want to transform,
the assumptions of the window should be those things you wish to assume,
and the relation of the window should be 
the relation you wish to preserve as you transform the focus.
For example, suppose you wish to find something that implies
\ml{`(A \hand\ (B \hand\ C)) \hand\ D`} under the assumption \ml{`\hnot C`}.
To create an appropriate stack, you should use the command:
\begin{boxed}\begin{verbatim}
   BEGIN_STACK : string -> term -> term list -> thm list -> unit
\end{verbatim}\end{boxed}\index{BEGIN\_STACK@@{\ptt BEGIN\_STACK}|(}
The first parameter is the name that will be associated with the stack.
The second parameter is a term containing both the focus and the relation
to be preserved.
The third parameter is the list of terms that you wish to assume.
The last parameter is a list of theorems that might be relevant to the proof.
The function of the last parameter will be explained in section~\ref{sec:lem},
until then we will give this parameter the empty list.
\setcounter{sessioncount}{1}
\begin{session}\begin{verbatim}
- BEGIN_STACK "intro" (--`($<==) ((A /\ (B /\ C)) /\ D)`--) [--`~C`--] [];

    ! ~C
<== * (A /\ B /\ C) /\ D
val it = () : unit
\end{verbatim}\end{session}
As a side effect, the
\ml{BEGIN\_STACK}\index{BEGIN\_STACK@@{\ptt BEGIN\_STACK}|)}
command prints the top window of the stack.
To print the top window at any time use the
\ml{PRINT\_STACK}\index{PRINT\_STACK@@{\ptt PRINT\_STACK}|(}
command.
\begin{boxed}\begin{verbatim}
   PRINT_STACK : unit -> unit
\end{verbatim}\end{boxed}\index{PRINT\_STACK@@{\ptt PRINT\_STACK}|)}

Initially, the user may choose one of \ml{`=`}, \ml{`==>`} or \ml{`<==`} as
the relation to be preserved by a window.
However the system can be tailored to preserve any preorder.
Details of how to declare new relations for use with the system are
given in section~\ref{sec:rel}.

Each window holds a theorem.
To obtain the theorem held by the current window use the following command:
\begin{boxed}\begin{verbatim}
   WIN_THM : unit -> thm
\end{verbatim}\end{boxed}\index{WIN\_THM@@{\ptt WIN\_THM}|(}
Initially (before you have transformed the focus) this theorem 
will simply state that the original focus of the window is related to itself.
\begin{session}\begin{verbatim}
   - WIN_THM ();
   val it = |- (A /\ B /\ C) /\ D <== (A /\ B /\ C) /\ D : thm
\end{verbatim}\end{session}\index{WIN\_THM@@{\ptt WIN\_THM}|)}

\section{Transforming the Focus}

Once you have a window, the next thing you want to do is transform it.
Each transformation of a focus $f_n$ to $f_{n+1}$ must be justified by a 
theorem of the following form:
\begin{alltt}
   \(\Gamma\) |- \(f\sb{n}\) \(R\) \(f\sb{n+1}\)
\end{alltt}
Where $\Gamma$ is a subset of the assumptions of the window, and
$R$\/ is the relation which is being preserved by the window.
The relation could, in fact, be any relation which the
system knows to be as strong as $R$.
The system already knows that equality is as strong as any reflexive relation.
For the definition of {\it stronger\/} see section~\ref{sec:rel}.

To take a theorem of the form above and use it to transform a window stack,
use the command:
\begin{boxed}\begin{verbatim}
   TRANSFORM_WIN : thm -> win_stack -> win_stack
\end{verbatim}\end{boxed}\index{TRANSFORM\_WIN@@{\ptt TRANSFORM\_WIN}}
To apply such a command to the current window stack, use the \ml{DO} command:
\begin{boxed}\begin{verbatim}
   DO : (win_stack -> win_stack) -> unit
\end{verbatim}\end{boxed}\index{DO@@{\ptt DO}}
To make life easier,
the following commands are provided for transforming the focus of a
window.
These commands automatically generate a theorem of the correct form and
use it to transform the window.\footnote{Other versions of rewriting
are described in chapter~\ref{chap:ref}.}
\begin{boxed}\begin{verbatim}
   MATCH_TRANSFORM_WIN : thm -> win_stack -> win_stack
   REWRITE_WIN : thm list -> win_stack -> win_stack
   CONVERT_WIN : conv -> win_stack -> win_stack
   RULE_WIN : (thm -> thm) -> win_stack -> win_stack
   THM_RULE_WIN : (thm -> thm) -> win_stack -> win_stack
   FOC_RULE_WIN : (term -> thm) -> win_stack -> win_stack
   TACTIC_WIN : tactic -> win_stack -> win_stack
\end{verbatim}\end{boxed}\index{MATCH\_TRANSFORM\_WIN@@{\ptt MATCH\_TRANSFORM\_WIN}}\index{REWRITE\_WIN@@{\ptt REWRITE\_WIN}}\index{CONVERT\_WIN@@{\ptt CONVERT\_WIN}}\index{RULE\_WIN@@{\ptt RULE\_WIN}}\index{THM\_RULE\_WIN@@{\ptt THM\_RULE\_WIN}}\index{FOC\_RULE\_WIN@@{\ptt FOC\_RULE\_WIN}}\index{TACTIC\_WIN@@{\ptt TACTIC\_WIN}}
We shall stick to using rewriting in our examples because its function should
be familiar.
We can rewrite the focus of the window created in the
previous section with the assumption of that window.
\begin{session}\begin{verbatim}
   - DO (PURE_REWRITE_WIN [ASSUME (--`~C`--)]);
   
       ! ~C
   <== * (A /\ B /\ F) /\ D
   val it = () : unit
   - WIN_THM ();;
   val it = [~C] |- (A /\ B /\ C) /\ D <== (A /\ B /\ F) /\ D : thm
\end{verbatim}\end{session}

If you decide that the last thing you did was a mistake,
then you can use the \ml{UNDO} command to undo it.
\begin{boxed}\begin{verbatim}
   UNDO : unit -> unit
\end{verbatim}\end{boxed}\index{UNDO@@{\ptt UNDO}}
You can use \ml{UNDO} several times if you want.
If you decide that \ml{UNDO} was a mistake, then you can use \ml{REDO}.
\begin{boxed}\begin{verbatim}
   REDO :  unit -> unit
\end{verbatim}\end{boxed}\index{UNDO@@{\ptt UNDO}}

\section{Opening subwindows}\index{OPEN\_WIN@@{\ptt OPEN\_WIN}|(}
If you wish to concentrate your attention on some subterm of the focus,
you should open a window on that subterm.
This is accomplished with the command:
\begin{boxed}\begin{verbatim}
   OPEN_WIN : path -> win_stack -> win_stack
\end{verbatim}\end{boxed}
\ml{OPEN\_WIN} takes as an argument a \ml{path} that describes the
position of the desired subterm within the focus.
A \ml{path}\index{path@@{\ptt path}} is a list made up of the following
constructors: \ml{RATOR}, \ml{RAND} and \ml{BODY}.
You should think of using each element in the list to select
an ever decreasing subterm until the list is exhausted.

For example, if we wished to concentrate on the subterm \ml{`B \hand\ F`} in
the previous window, we should open a subwindow at \ml{[RATOR,RAND,RAND]}.
\begin{session}\begin{verbatim}
   - DO (OPEN_WIN [RATOR,RAND,RAND]);
   
       ! ~C
       ! D
       ! A
   <== * B /\ F
   val it = () : unit
\end{verbatim}\end{session}

A subwindow will have all the assumptions of the parent window,
plus any additional assumptions that follow from the context of the subwindow.
The one exception to this rule is when a window is opened inside the body of a
binder.
In this case, all assumptions with free occurrences of the variable bound
by the binder will be hidden.
(In the future this may be handled by renaming.)

The relation in the subwindow may not be the same as the relation in the
parent window.   The system will choose the weakest relation for the
subwindow that it knows will preserve the relation of the parent window.
To learn how the system makes these choices refer to section~\ref{sec:win}.

Having got a subwindow you will want to transform it, and then close it.
To close a subwindow, use the function:
\begin{boxed}\begin{verbatim}
   CLOSE_WIN : win_stack -> win_stack
\end{verbatim}\end{boxed}\index{CLOSE\_WIN@@{\ptt CLOSE\_WIN}|(}
We continue our example by transforming the subwindow with rewriting,
and then closing it.
Once back in the parent window, we check the theorem proved so far.
\begin{session}\begin{verbatim}
   - DO (REWRITE_WIN []);
   
       ! ~C
       ! D
       ! A
   <== * F
   val it = () : unit
   - DO CLOSE_WIN;
   
       ! ~C
   <== * (A /\ F) /\ D
   val it = () : unit
   - WIN_THM ();
   val it = [~C] |- (A /\ B /\ C) /\ D <== (A /\ F) /\ D : thm
\end{verbatim}\end{session}\index{CLOSE\_WIN@@{\ptt CLOSE\_WIN}|)}

If opening a particular window proves to be a mistake,
you can return to the parent window with the \ml{UNDO\_WIN} command.
\begin{boxed}\begin{verbatim}
   UNDO_WIN : win_stack -> win_stack
\end{verbatim}\end{boxed}\index{UNDO\_WIN@@{\ptt UNDO\_WIN}}
Alternatively, you can use the \ml{UNDO}\index{UNDO@@{\ptt UNDO}} command
to back up to the point where you opened the
window.\index{OPEN\_WIN@@{\ptt OPEN\_WIN}|)}

\section{Lemmas}\index{lemma|(}	\label{sec:lem}

The window stack can hold a set of theorems which are considered relevant
to the current problem.
The last parameter of the \ml{CREATE\_WIN} command is the initial list of
theorems that should be considered relevant to the window stack.
In section~\ref{sec:start} we created a window with an empty list of 
relevant theorems.

If the hypotheses of a theorem are a subset of the assumptions of a window,
then that theorem is said to be {\it applicable\/} in the context of that
window.
When a window is printed, the conclusions of those theorems held
by the stack that are applicable to the window are printed 
with the assumptions of the window.
Such conclusions are called the
{\it lemmas}\/ of the window.
Lemmas may be used in the same way as the assumptions.
We will refer to lemmas and assumptions collectively as the {\it context}
of a window.
When printed, lemmas are prefixed with
`\ml{|}'\index{"|@@{{\ptt "|} (lemma prefix)}} rather than `\ml{!}' to
distinguish them from assumptions.

As an example,
suppose we wish to simplify the term \ml{`A \hand\ B`} given that we 
have a theorem \ml{a\_then\_b} which states that \ml{A |- B}.
We create a window stack which has a window with \ml{`A \hand\ B`} as its
focus, and which stores the theorem \ml{A |- B} in the stack as a
potentially relevant theorem.
\setcounter{sessioncount}{1}
\begin{session}\begin{verbatim}
   - BEGIN_STACK "lemma-ex" (--`($=) (A /\ B)`--) [] [a_then_b];
   
   = * A /\ B
   val it = () : unit
\end{verbatim}\end{session}
If we now open a subwindow on \ml{`B`} we enter a context in which the
stored theorem is applicable.
We can then use the conclusion of the stored theorem to rewrite the focus
of the subwindow.
\begin{session}\begin{verbatim}
   - DO (OPEN_WIN [RAND]);
   
     ! A
     | B
   = * B
   val it = () : unit
   - DO (REWRITE_WIN [ASSUME (--`B:bool`--)]);
   
     ! A
     | B
   = * T
   val it = () : unit
   - DO CLOSE_WIN;
   
   = * A /\ T
   val it = () : unit
\end{verbatim}\end{session}

You can add more theorems to the set of relevant theorems during the course of
a proof by using the
\ml{ADD\_THEOREM}\index{ADD\_THEOREM@@{\ptt ADD\_THEOREM}} command.
\begin{boxed}\begin{verbatim}
   ADD_THEOREM : thm -> win_stack -> win_stack
\end{verbatim}\end{boxed}

\subsection{Windows on the Context}

Sometimes you might want to make use of a fact that follows indirectly from
the context of a window.
To allow this style of reasoning we provide a command for opening subwindows
on subterms in the context.
You can now open a window on some fact in the context and attempt to 
derive a new fact from it.
When you close such a window, a theorem is added to the set of theorems
held by the window stack so that the fact you derived becomes a lemma.

The command to open a subwindow in the context is:
\begin{boxed}\begin{verbatim}
   OPEN_CONTEXT : term * path -> win_stack -> win_stack
\end{verbatim}\end{boxed}\index{OPEN\_CONTEXT@@{\ptt OPEN\_CONTEXT}}
The first parameter is the term in the context you wish to open a window on,
the second is the path to the desired focus within that term.
More often than not, the path will be empty (denoting the entire expression).

For example, consider the window below:
\setcounter{sessioncount}{1}
\begin{session}\begin{verbatim}
   - PRINT_STACK ();
   
       ! A = Z
       ! (A /\ B) /\ A
   <== * (Z /\ B) /\ A
   val it = () : unit
\end{verbatim}\end{session}
If we open a subwindow on the first \ml{`A`} in the assumption
\ml{`(A \hand\ B) \hand\ A`}, 
we can use the assumption \ml{`A = Z`} to rewrite the \ml{`A`} to a \ml{`Z`}.
The resulting lemma could then be used to simplify the focus to \ml{`T`}.
\begin{session}\begin{verbatim}
   - DO (OPEN_CONTEXT((--`(A /\ B) /\ A`--),[RATOR,RAND,RATOR,RAND]));
   
       ! A = Z
       ! (A /\ B) /\ A
       ! A
       ! B
   ==> * A
   val it = () : unit
\end{verbatim}\end{session}
Note that we are now preserving the relation \ml{`==>`},
this is because we are trying to derive a new fact that follows from 
the assumption we opened a subwindow on.
\begin{session}\begin{verbatim}
    - DO (REWRITE_WIN [ASSUME (--`(A:bool) = Z`--)]);

	! A = Z
	! (A /\ B) /\ A
	! A
	! B
    ==> * Z
    val it = () : unit
    - DO CLOSE_WIN;

	! A = Z
	! (A /\ B) /\ A
	| (Z /\ B) /\ A
    <== * (Z /\ B) /\ A
    val it = () : unit
\end{verbatim}\end{session}\index{lemma|)}

\section{Conjectures}	\label{sec:con}

The window stack carries with it a set of goals, called 
{\it suppositions}\index{supposition},
which the user supposes to be true.
A supposition of the form \ml{P ?- C} means that the user believes that
\ml{`C`} follows from \ml{`P`}.
Initially the set of suppositions associated with a window stack is empty.
Suppositions can be added to the stack with the command:
\begin{boxed}\begin{verbatim}
   ADD_SUPPOSE : goal -> win_stack -> win_stack
\end{verbatim}\end{boxed}\index{ADD\_SUPPOSE@@{\ptt ADD\_SUPPOSE}}
The command \ml{CONJECTURE `C`} is a shorthand for adding a supposition with
conclusion \ml{`C`} and assumptions the same as those of the top window.
\begin{boxed}\begin{verbatim}
   CONJECTURE : term -> win_stack -> win_stack
\end{verbatim}\end{boxed}\index{CONJECTURE@@{\ptt CONJECTURE}}

If the premises of any supposition are a subset of the assumptions of a window,
then that supposition is said to be
{\it applicable}\index{applicable}\/ in the context of that
window.
When a window is printed, the conclusions of those suppositions that
are held by the stack and which are applicable are printed with the 
assumptions and lemmas of the window.
The conclusions of such suppositions are called the 
{\it conjectures}\index{conjectures}\/ of the
window.
Conjectures are part of the context of a window.
When printed, conjectures are prefixed with
`\ml{?}'\index{?@@{{\ptt ?} (conjecture prefix)}} to distinguish them
from the other elements of the context.

Conjectures may be used like the other elements of the context,
except that once, used\index{conjectures!used} a conjecture must be proved.
Once a conjecture has been used, its prefix will change from `\ml{?}' to
`\ml{\$}'\index{\$@@{{\ptt \$} (used conjecture prefix)}}.
If you have used a conjecture in a subwindow, and that conjecture is not
part of the context of the parent window,
or if the subwindow is inside the body of the abstraction and the variable
bound by the abstraction occurs free in the conjecture,
then that conjecture {\it must\/}
be proved before you can be allowed to close the subwindow.
Such conjectures are called {\it bad\/}
conjectures\index{conjectures!bad}.
Bad conjectures are prefixed with
`\ml{@@}'\index{"@@@@{{\ptt "@@} (bad conjecture prefix)}}.
All conjectures used at the very bottom of the window stack are considered bad
because they appear as extra assumptions in the theorem held by that window.

Consider the window below:
\setcounter{sessioncount}{1}
\begin{session}\begin{verbatim}
   - BEGIN_STACK "suppose-ex" (--`($=) ((A \/ ~A) \/ B)`--) [] [];
   
   = * (A \/ ~A) \/ B
   val it = () : unit
\end{verbatim}\end{session}
If we assume that we can prove \ml{`A \hor\ \hnot A`},
we can simplify the focus, and then return to prove our assumption later.
\begin{session}\begin{verbatim}
   - DO (CONJECTURE (--`A \/ ~A`--));
   
     ? A \/ ~A
   = * (A \/ ~A) \/ B
   val it = () : unit
   - DO (REWRITE_WIN [ASSUME (--`A \/ ~A`--)]);
   
     @@ A \/ ~A
   = * T
   val it = () : unit
   - WIN_THM ();
   val it = [A \/ ~A] |- (A \/ ~A) \/ B = T : thm
\end{verbatim}\end{session}

If you open a subwindow in the context of a window,
and in that subwindow you use a conjecture,
when you return to the parent window you may find that the conjecture is no
longer considered to have been used.
This is because the conjecture has {\it not\/} been used to transform the
focus of this window.
However, if you use the lemma generated by the subwindow,
all conjectures used in generating that lemma will then be used.

To remove a usage of a conjecture, you must introduce a lemma that is
the same as the conjecture.
You can do this by adding a theorem to the set of relevant theorems directly,
by deriving the desired lemma from the context
(using the conjecture to derive the required lemma will not work),
or by using the command \ml{ESTABLISH}\index{ESTABLISH@@{\ptt ESTABLISH}}.
\begin{boxed}\begin{verbatim}
   ESTABLISH : term -> win_stack -> win_stack
\end{verbatim}\end{boxed}
\ml{ESTABLISH `C`} opens a new subwindow with \ml{`C`} as its focus and
\ml{`<==`} as the relation it preserves.
If you can transform the focus of this subwindow to \ml{`T`} and then
close the window, \ml{`C`} will become a lemma in the parent window.

So, to continue our example, we must now prove the conjecture we have used:
\begin{session}\begin{verbatim}
   - DO (ESTABLISH (--`A \/ ~A`--));
   
   <== * A \/ ~A
   val it = () : unit
   - DO (REWRITE_WIN [EXCLUDED_MIDDLE]);
   
   <== * T
   val it = () : unit
   - DO CLOSE_WIN;
   
     | A \/ ~A
   = * T
   val it = () : unit
   - WIN_THM ();
   val it = |- (A \/ ~A) \/ B = T : thm
\end{verbatim}\end{session}

\section{Window Stacks}

We have already used the
\ml{BEGIN\_STACK}\index{BEGIN\_STACK@@{\ptt BEGIN\_STACK}} command
introduced in section~\ref{sec:start} to create a window stack.
It is possible to work with several window stacks at the same time.
When you create a new stack with
\ml{BEGIN\_STACK}\index{BEGIN\_STACK@@{\ptt BEGIN\_STACK}}
it becomes the current stack.
You can set the current stack to another stack by using the
command \ml{SET\_STACK}\index{SET\_STACK@@{\ptt SET\_STACK}}:
\begin{boxed}\begin{verbatim}
   SET_STACK : string -> unit
\end{verbatim}\end{boxed}
The first parameter of 
\ml{SET\_STACK}\index{SET\_STACK@@{\ptt SET\_STACK}} is the name of
the stack that you wish to be the current stack.

If you have finished working with a particular stack,
it can be destroyed with the 
\ml{END\_STACK}\index{END\_STACK@@{\ptt END\_STACK}} command.
\begin{boxed}\begin{verbatim}
   END_STACK : string -> unit
\end{verbatim}\end{boxed}
The first parameter of the 
\ml{END\_STACK}\index{END\_STACK@@{\ptt END\_STACK}} command is the name
of the stack you wish to destroy.
It is possible, and in fact usual, to destroy the current stack, 
leaving yourself with no current stack.

The command \ml{CURRENT\_NAME}\index{CURRENT\_NAME@@{\ptt CURRENT\_NAME}}
returns the name of the current stack, if there is one.
\begin{boxed}\begin{verbatim}
   CURRENT_NAME : unit -> string
\end{verbatim}\end{boxed}
THe \ml{CURRENT\_STACK}\index{CURRENT\_STACK@@{\ptt CURRENT\_STACK}}
command can be used to retrieve the current stack itself.
\begin{boxed}\begin{verbatim}
   CURRENT_STACK : unit -> win_stack
\end{verbatim}\end{boxed}

The \ml{ALL\_STACKS}\index{ALL\_STACKS@@{\ptt ALL\_STACKS}} command
can be used to find out the names of all the stacks in the system.
\begin{boxed}\begin{verbatim}
   ALL_STACKS : unit -> string list
\end{verbatim}\end{boxed}

\section{Interfacing with the Subgoal Package}

Most proof done with \HOL\ uses the subgoal package,
    and for most applications the subgoal package remains the most appropriate
    tool.
However it is possible to mix the two proof styles.

The following functions form the interface between subgoal proof and
window-inference proof.
\begin{boxed}\begin{verbatim}
   BEGIN_STACK_TAC : thm list -> tactic
   END_STACK_TAC : unit -> tactic
\end{verbatim}\end{boxed}\index{BEGIN\_STACK\_TAC@@{\ptt BEGIN\_STACK\_TAC}}\index{END\_STACK\_TAC@@{\ptt END\_STACK\_TAC}}
The idea behind these tactics is to open a window on the current goal,
use window inference to transform it, then substitute the transformed goal
back into the subgoal package.
A list of theorems can be supplied to {BEGIN\_STACK\_TAC} to use as the set
of theorems that might be relevant to the transformation.

Here is a simple example.
Suppose we had as our current goal the term \ml{`A \hand\ B \hand\ F`}.
\setcounter{sessioncount}{1}
\begin{session}\begin{verbatim}
   - set_goal ([],(--`A /\ B /\ F`--));
   val it =
     New goal stack.
     
     (--`A /\ B /\ F`--)
     ____________________________
         
     
     
     There is 1 currently incomplete proof attempt.
      : proof_attempts
\end{verbatim}\end{session}
If we wanted to rewrite just the subterm \ml{`B \hand\ F`} to \ml{`F`} we
can do this by opening a window on that subterm.
\begin{session}\begin{verbatim}
   - expand (BEGIN_STACK_TAC []);
   OK..
   
   <== * A /\ B /\ F
   1 subgoal:
   val it =
     (--`A /\ B /\ F`--)
     ____________________________
         
     
     
     There is 1 currently incomplete proof attempt.
      : proof_attempts
   - DO (OPEN_WIN [RAND]);
   
       ! A
   <== * B /\ F
   val it = () : unit
\end{verbatim}\end{session}
Having opened at window on the desired subterm, we can rewrite it without
effecting the remainder of the goal.
\begin{session}\begin{verbatim}
   - DO (REWRITE_WIN []);
   
       ! A
   <== * F
   val it = () : unit
\end{verbatim}\end{session}
The \ml{END\_STACK\_TAC} tactic then takes the reasoning done in the 
window stack and applies it to the goal.
\ml{END\_STACK\_TAC}, will not work if you have made any changes to the
goal since creating the stack.
\begin{session}\begin{verbatim}
   - expand (END_STACK_TAC ());
   OK..
   1 subgoal:
   val it =
     (--`A /\ F`--)
     ____________________________
         
     
     
     There is 1 currently incomplete proof attempt.
      : proof_attempts
\end{verbatim}\end{session}

\section{Adding New Window Rules}	\label{sec:win}

To allow the opening and closing of subwindows,
the system chains together several inference rules on behalf of the user.
These rules are called {\it window rules}, and the system keeps them
in a data base together with some information about them.

The system has a full set of rules for opening and closing
subwindows on \HOL\ terms.
These rules are capable of preserving the following relations:
\ml{`=`}, \ml{`==>`} and \ml{`<==`}.
The rules in the system exploit the contextual
information available when windowing on the positions 
marked with `\ml{\_}' in the following
terms: \ml{`\_\hand\_`}, \ml{`\_\hor\_`}, \ml{`\_==>\_`}, \ml{`\_<==\_`},
\ml{`\_=>\_|\_`}, \ml{`(\\\_.\_)\_`}, and \ml{let\_=\_in\_}.
However, if you would like the system to preserve other relations,
or exploit the contextual information available inside other terms,
then you will have to add some rules to the database.

Each window rule must be of type \ml{:term -> (thm -> thm)}.
A rule should take the focus of the parent window and the theorem held
by the child window, and return the theorem required to transform the parent
window.
For example, the window rule \ml{IMP\_CONJ1\_CLOSE} as depicted below is used
when opening a subwindow at \ml{`A`} in \ml{`A \hand\ B`} while preserving
\ml{`==>`} in the parent window.
\begin{verbatim}
          B |- A ==> A'
   ---------------------------  IMP_CONJ1_CLOSE `A /\ B` 
    |- (A /\ B) ==> (A' /\ B)
\end{verbatim}
Each rule in the system is a package of the following information:
\begin{itemize}
	\item	The path from the focus of the parent window to the focus
		of the child window.
		In the case of \ml{IMP\_CONJ1\_CLOSE} this is 
		\ml{[RATOR,RAND]}.
	\item	A function from the focus of the parent window to boolean.
		The function is true if the rule is applicable to the focus.
		\ml{IMP\_CONJ1\_CLOSE} only works on conjunctions,
		so it is stored with the function \ml{is\_conj}.
	\item	A function that takes the focus of the parent window and
		the relation that we want to preserve in the parent window,
		and returns the relation that this rule will preserve in
		the child window.
		\ml{IMP\_CONJ1\_CLOSE} always preserves \ml{`==>`} in the
		child window.
	\item	A function that takes the focus of the parent window and
		the relation that we want to preserve in the parent window,
		and returns the relation that this rule will preserve in
		the parent window.
		\ml{IMP\_CONJ1\_CLOSE} always preserves \ml{`==>`} in the
		parent window.
	\item	A function that takes the focus of the parent window,
		and returns the new assumptions of the child window.

		The assumptions of a window are represented by a list of
		theorems, each of which has just one hypothesis.
		An assumption {\it a}\/ is typically represented by the
		theorem \ml{\(a\) |- \(a\)}.
		However, consider a window with focus
		\ml{`\(a\) \hand\ \(b\) \hand\ \(c\)`}.
		If you were to open a subwindow at \ml{`\(a\)`} in such a 
		window, you might expect the subwindow to have two new
		assumptions, \ml{`\(b\)`} and \ml{`\(c\)`}.
		However we might also expect that when opening a window at the
		first operand of a conjunction, it would gain the second
		operand of the conjunction (namely \ml{`\(b\) \hand\ \(c\)`})
		 as an assumption.
		To avoid this a conflict of expectations, the following
		theorems should be added when opening the window:
		\ml{\(b\) \hand\ \(c\) |- \(b\)} and
		\ml{\(b\) \hand\ \(c\) |- \(c\)}.
		The system then knows that \ml{`\(b\) \hand\ \(c\)`} can
		be assumed true, and that from that it can derive the
		\ml{`\(b\)`} and \ml{`\(c\)`}.
		Only the conclusions of these theorems 
		(namely \ml{`\(b\)`} and \ml{`\(c\)`}) will be displayed as
		assumptions, but you will be able to use all three.

	\item   A function that takes the focus of the parent window,
		and returns the list of variables that appear
		bound in the parent window, but which are free in the
		child window.
		That is, if the window rule opens inside the body of 
		a binder, it returns the list of variables bound by
		the binder, otherwise the empty list is returned.
\end{itemize}
To add a window rule to the system, use the function
\ml{store\_rule}\index{store\_rule@@{\ptt store\_rule}|(}.
\begin{boxed}\begin{verbatim}
   store_rule : window_rule -> rule_id
\end{verbatim}\end{boxed}\index{store\_rule@@{\ptt store\_rule}|)}
Where \ml{window\_rule} is defined as:
\begin{verbatim}
   type window_rule =  (   path
                       *   (term -> bool)
                       *   (term -> term -> term)
                       *   (term -> term -> term)
                       *   (term -> (thm list))
                       *   (term -> (thm -> thm))
                       );
\end{verbatim}\index{window\_rule@@{\ptt window\_rule}}
Namely, a tuple of those components just described, and the window rule 
itself.
For example, \ml{IMP\_CONJ1\_CLOSE} was added to the system with the
following command:
\begin{verbatim}
   store_rule
       (
           [RATOR,RAND],
           is_conj,
           K (K imp_tm),
           K (K imp_tm),
           (fn tm => SMASH (ASSUME (rand tm))),
           IMP_CONJ1_CLOSE
       );
\end{verbatim}
(Note that \ml{SMASH} is new inference rule introduced by the window library.
 \ml{SMASH} is similar to \ml{CONJUNCTS}.)

The \ml{rule\_id} that it returned by \ml{store\_rule} can be used to 
remove the rule from the system at a later time.  To do this, you
should use the \ml{kill\_rule} command.
\begin{boxed}\begin{verbatim}                            
   kill_rule : rule_id -> unit
\end{verbatim}\end{boxed}\index{kill\_rule@@{\ptt kill\_rule}}


When opening a window it will usually be the case that there are several
possible lists of window rules that could have been chained together 
to open a window at the required position.
The system uses the following heuristics to decide which of two potential
lists of rules is the {\it better}:
\begin{enumerate}
	\item	The system considers the child window which would result from
		using each of possible lists of rules.
		\begin{itemize}	
			\item	If the relation required to be preserved by one
				child window is known to be weaker than that
				required by the other, the list of rules
				which produced the window with the weaker
				relation is chosen.
			\item	Otherwise, the list of rules which produced
				the child window with the most hypotheses is
				chosen.
		\end{itemize}
	\item	If step 1 can not distinguish between the lists of rules then
		the choice between them is somewhat arbitrary.
		In such a case the lists are compared one rule at
		a time until one is found which is regarded as being more
		{\it specific}\/ than the other.
		\begin{itemize}
			\item	Rules which follow a longer path are regarded as
				more specific.
			\item	Rules which preserve a weaker relation in the
				parent window are regarded as more specific.
			\item	Rules which preserve a weaker relation in the
				child window are regarded as more specific.
			\item	Rules which create more assumptions in the
				child window are regarded as more specific.
			\item	Rules which were more recently added to the
				system are regarded as more specific.
		\end{itemize}
\end{enumerate}

\section{Adding New Relations}	\label{sec:rel}

Before the window library can be used to preserve a relation, the
system must know that the relation is reflexive and transitive.
The system is already aware that the following relations are reflexive
and transitive: \ml{`=`}, \ml{`==>`} and \ml{`<==`}.

To tell the system that some relation is reflexive and transitive, use
\ml{add\_relation}\index{add\_relation@@{\ptt add\_relation}|(}.
\begin{boxed}\begin{verbatim}
   add_relation : thm * thm -> unit
\end{verbatim}\end{boxed}
\ml{add\_relation} takes a pair of theorems, which should be of the same form
as \ml{EQ\_REFL} and \ml{EQ\_TRANS}, and stores these theorems for use by
the system.
For example, to tell the system that implication was reflexive and transitive
we defined two theorems
\ml{IMP\_REFL\_THM}\index{IMP\_REFL\_THM@@{\ptt IMP\_REFL\_THM}|(}
and
\ml{IMP\_TRANS\_THM}\index{IMP\_TRANS\_THM@@{\ptt IMP\_TRANS\_THM}|(}
of the following form:
\begin{verbatim}
   IMP_REFL_THM = |- !x. x ==> x

   IMP_TRANS_THM = |- !x y z. (x ==> y) /\ (y ==> z) ==> x ==> z
\end{verbatim}
and then issued the command:
\begin{verbatim}
   add_relation (IMP_REFL_THM, IMP_TRANS_THM);
\end{verbatim}\index{IMP\_TRANS\_THM@@{\ptt IMP\_TRANS\_THM}|)}\index{IMP\_REFL\_THM@@{\ptt IMP\_REFL\_THM}|)}\index{add\_relation@@{\ptt add\_relation}|)}

\subsection{Relative Strengths}

We say that some relation, $r_1$,
is {\it stronger}\index{stronger}\/ than another relation, $r_2$, 
if whenever some $x$ and $y$ are related by $r_1$
they are also related by $r_2$.
Note that stronger is a reflexive relation.

If the system knows that $r_1$ is stronger than $r_2$ then
it will allow you use theorems of the form 
\begin{alltt}
   |- \(f\sb{n}\) \(r\sb{1}\) \(f\sb{n+1}\)
\end{alltt}
to transform the focus of a window which is supposed to be preserving
the relation $r_2$.
Furthermore, if you ask the system to open a subwindow 
in the focus of a window that is supposed to be preserving the relation
$r_2$, and the system has no window rule for that case, it can substitute
a window rule that preserves $r_1$.

Every relation used with the window library must be reflexive.
From this we can deduce that equality is stronger than any relation that can be
used with system.
The window library knows this, so when adding some new relation,
there is no need to state that equality is stronger than it.
However, if you plan on adding two new relations to the system,
say \ml{`r1`} and \ml{`r2`}, such that \ml{`r1`} is stronger than \ml{`r2`},
you will need to tell the system about that.

First you should prove the following theorem \ml{WEAKEN\_r1\_r2}:
\begin{verbatim}
    WEAKEN_r1_r2 = |- !x y. (x r1 y) ==> (x r2 y)
\end{verbatim}
then call
\ml{add\_weak}\index{add\_weak@@{\ptt add\_weak}|(}
to add the theorem to the system:
\begin{boxed}\begin{verbatim}
   add_weak : thm -> unit
\end{verbatim}\end{boxed}
as in:
\begin{verbatim}
   add_weak WEAKEN_r1_r2;;
\end{verbatim}\index{add\_weak@@{\ptt add\_weak}|)}

\section{Future Changes}

It is my intention to keep the interface of the window library fluid
for the first couple to releases so that I can capitalise on
the feedback I get from people's experiences with using it.
While I hope that the vast majority of the code is bug-free,
I will not be too surprised to learn otherwise.
If you do have a suggestion for improving the system, or find a bug, please
contact me.   I will endeavor to provide bug fixes as soon as possible.
When reporting a bug, please be sure to tell me what versions of the 
window inference system and \HOL\ you are using.
The constant \ml{window\_version} contains the version number of the window
system.
I can be contacted at:
\begin{center}
    \begin{tabular}{l@@{\hspace{10mm}}ll}
	Jim Grundy					& phone:	&
	    +61$\;$8$\:$259$\,$6162		\\
	Information Technology Division		   	& fax:		&
	    +61$\;$8$\:$259$\,$5980		\\
	Building 171 Laboratories Area			& texel:	&
	    AA82799				\\
	PO Box 1500					& email:	&
	    Jim.Grundy@@dsto.defence.gov.au	\\
	Salisbury~~SA~~5108				& 		&
	    jim@@grundy-j.apana.org.au		\\
	AUSTRALIA					&		& \\
    \end{tabular}
\end{center}

\section{Bugs}

    Opening a window inside a \ml{let} expression will not work properly
	for \ml{let} expressions involving tuples of variables or
	that use the \ml{and} construct.

\section*{Acknowledgments}
    I would like to thank Andy Gordon, Mats Larsson, Laurent Thery and
	Joakim von Wright, all of whom have found bugs in earlier versions of
	the system, and suggested many improvements.
@


1.2
log
@Updated the description for the HOL90 version.
@
text
@@


1.1
log
@Initial revision
@
text
@d41 1
a41 1
Anyone seeking a licence to use this software for commercial purposes
d47 2
a48 2
The window library has been provided to facilitate a style of 
reasoning called {\it window inference}.
d50 1
a50 2
situations where
very fine grain manipulations are required,
d53 2
a54 2
Users interested in transformational design, refinement and equational 
reasoning should find the window library interesting.
d58 35
a92 14
	\begin{minipage}{0.8\columnwidth}
		\small
		\noindent
		Jim Grundy.
		Window Inference in the HOL System.
		In Phil J. Windley, Mylar Archer, Karl N. Levitt and
		Jeff J. Joyce, editors,
		{\it The Proceedings of the International Tutorial and Workshop on
		the HOL Theorem Proving System and its Applications},
		University of California at Davis, 28--30 August 1991.
		IEEE Computer Society / ACM SIGDA, IEEE Computer Society Press,
		10662 Los Vaqueros Circle, PO Box 3014,
		Los Alamitos CA 907020-1264, United States, 1992.
	\end{minipage}
d104 6
a109 6
\ml{"A \hand\ B"};
this may be done by transforming \ml{"A"} under the assumption \ml{"B"}.
It is possible to assume \ml{"B"} while transforming \ml{"A"},
because were \ml{"B"} false,
the enclosing expression \ml{"A \hand\ B"} would be false regardless of
\ml{"A"}.
d112 1
a112 1
The advantage of the window inference technique is that the user is shielded
d116 5
a120 4
a user starts with an expression \ml{"P"} and transforms it to \ml{"Q"} such
that \ml{"Q R P"} for some relation \ml{"R"}\footnote
{\ml{"R"} denotes an infix, reflexive, transitive relation.};
thus creating a proof that \ml{|- Q R P}.
d123 9
a131 2
The user may start with the expression \ml{"P"} and transform it to
\ml{"T"}(true) while preserving the relation \ml{"==>"}.
d133 1
a133 9
and would constitute a backward proof of \ml{"P"}.
Alternatively,
the user may start with the expression \ml{"T"} and transform it to
\ml{"P"} while preserving the relation
\ml{"<=="}\index{PMI\_DEF@@{\ptt PMI\_DEF}|nn}\footnote
{\ml{PMI\_DEF} \ml{|- !a, b. (a <== b) = (b ==> a)}}.
Such a process would build the theorem
\ml{|- P <== T},
and would constitute a forward proof of \ml{"P"}.
d141 1
a141 1
	load_library `window`;;
d144 1
a144 1
This is because the library contains a small theory called {\tt win}.
d148 1
a148 3
If this happens, a new function
\ml{load\_window}\index{load\_window@@{\ptt load\_window}} is defined which
can be used to complete the loading process if \HOL\ is placed in draft mode.
d150 2
a151 1
Within a window inference system reasoning is conducted with a stack of windows.
d158 1
a158 1
(Note that the type of the focus is not restricted to \ml{:bool} as is the
d167 1
a167 1
you create a window stack which contains a single window.
d173 2
a174 2
\ml{"(A \hand\ (B \hand\ C)) \hand\ D"} under the assumption \ml{"\hnot C"}.
To create such a stack, you should use the command:
d176 1
a176 1
   BEGIN_STACK : string -> term -> term list -> thm list -> void
d187 5
a191 4
   #BEGIN_STACK `intro` "(==>) ((A /\ (B /\ C)) /\ D)" ["~C"] [];;
       ! ~C
   ==> * (A /\ B /\ C) /\ D
   () : void
d193 1
a193 1
As a side effect the
d200 1
a200 1
   PRINT_STACK : void -> void
d203 1
a203 1
Initially the user may choose one of \ml{"="}, \ml{"==>"} or \ml{"<=="} as
d205 2
a206 3
However the system can be tailored to preserve any reflexive, transitive
relation.
Details of how to declare a new relation for use with the system are
d212 1
a212 1
   WIN_THM : void -> thm
d217 2
a218 2
   #WIN_THM();;
   |- (A /\ B /\ C) /\ D ==> (A /\ B /\ C) /\ D
d223 1
a223 1
Once you have a window the next thing you want to do is transform it.
d227 1
a227 1
   \(\Gamma\) |- \(f\sb{n+1}\) \(R\) \(f\sb{n}\)
d229 1
a229 1
Where $\Gamma$ is some subset of the assumptions of the window, and
d236 1
a236 1
To take a theorem of the form above and use it to transform a window,
d239 1
a239 1
   TRANSFORM_WIN : thm -> void
d241 4
d249 1
a249 1
use it to transform the window:\footnote{Other versions of rewriting
d252 8
a259 9
   MATCH_TRANSFORM_WIN: thm -> void
   REWRITE_WIN : thm list -> void
   PURE_REWRITE_WIN : thm list -> void
   CONVERT_WIN : conv -> void
   RULE_WIN : (thm -> thm) -> void
   THM_RULE_WIN : (thm -> thm) -> void
   FOC_RULE_WIN : (term -> thm) -> void
   TACTIC_WIN : tactic -> void
\end{verbatim}\end{boxed}\index{MATCH\_TRANSFORM\_WIN@@{\ptt MATCH\_TRANSFORM\_WIN}}\index{REWRITE\_WIN@@{\ptt REWRITE\_WIN}}\index{PURE\_REWRITE\_WIN@@{\ptt PURE\_REWRITE\_WIN}}\index{CONVERT\_WIN@@{\ptt CONVERT\_WIN}}\index{RULE\_WIN@@{\ptt RULE\_WIN}}\index{THM\_RULE\_WIN@@{\ptt THM\_RULE\_WIN}}\index{FOC\_RULE\_WIN@@{\ptt FOC\_RULE\_WIN}}\index{TACTIC\_WIN@@{\ptt TACTIC\_WIN}}
d265 2
a266 1
   #PURE_REWRITE_WIN [ASSUME "~C"];;
d268 4
a271 5
   ==> * (A /\ B /\ F) /\ D
   () : void

   #WIN_THM ();;
   ~C |- (A /\ B /\ F) /\ D ==> (A /\ B /\ C) /\ D
d277 6
a282 1
   UNDO : void -> void
d285 1
a285 1
\section{Opening subwindows}
d290 2
a291 2
   OPEN_WIN : path -> void
\end{verbatim}\end{boxed}\index{OPEN\_WIN@@{\ptt OPEN\_WIN}|(}
d299 2
a300 2
For example, if we wished to concentrate on the subterm \ml{"B \hand\ F"} in
the previous window, we should open a subwindow at \ml{[RATOR; RAND; RAND]}:
d302 2
a303 1
   #OPEN_WIN [RATOR; RAND; RAND];;
d307 2
a308 2
   ==> * B /\ F
   () : void
d312 3
a314 3
plus any additional assumptions which follow from the context of the subwindow.
The one exception to this rule is when a window is opened inside the body of an
abstraction.
d316 1
a316 1
by the abstraction will be hidden.
d321 1
a321 1
subwindow which it knows will preserve the relation of the parent window.
d327 1
a327 1
   CLOSE_WIN : void -> void
d333 2
a334 1
   #REWRITE_WIN [];;
d338 3
a340 2
   ==> * F
   () : void
a341 1
   #CLOSE_WIN ();;
d343 4
a346 5
   ==> * (A /\ F) /\ D
   () : void
   
   #WIN_THM ();;
   ~C |- (A /\ F) /\ D ==> (A /\ B /\ C) /\ D
d352 1
a352 1
   UNDO_WIN : void -> void
d355 2
a356 2
if the \ml{OPEN\_WIN}\index{OPEN\_WIN@@{\ptt OPEN\_WIN}|)}
was the last command you made.
d363 1
a363 1
theorems which should be considered relevant to the window stack.
d383 1
a383 1
suppose we wish to simplify the term \ml{"A \hand\ B"} given that we 
d385 1
a385 1
We create a window stack which has a window with \ml{"A \hand\ B"} as its
d390 2
a391 1
   #BEGIN_STACK `lemma-ex` "(=) (A /\ B)" [] [a_then_b];;
d393 1
a393 1
   () : void
d395 1
a395 1
If we now open a subwindow on \ml{"B"} we enter a context in which the
d400 2
a401 1
   #OPEN_WIN [RAND];;
d405 2
a406 1
   () : void
a407 1
   #REWRITE_WIN [ASSUME "B:bool"];;
d411 2
a412 1
   () : void
a413 1
   #CLOSE_WIN ();;
d415 1
a415 1
   () : void
d422 1
a422 1
   ADD_THEOREM : thm -> void
a423 6
You can also recover the list of theorems held by the window stack for
use with another proof by using the
\ml{LEMMA\_THMS}\index{LEMMA\_THMS@@{\ptt LEMMA\_THMS}} command.
\begin{boxed}\begin{verbatim}
   LEMMA_THMS : void -> thm list
\end{verbatim}\end{boxed}\index{lemma|)}
d433 1
a433 1
When you close such a window a theorem is added to the set of theorems
d438 1
a438 1
   OPEN_CONTEXT : term -> path -> void
d447 2
a448 1
   #PRINT_STACK ();;
d451 2
a452 2
   ==> * (Z /\ B) /\ A
   () : void
d454 4
a457 4
If we open a subwindow on the first \ml{"A"} in the assumption
\ml{"(A \hand\ B) \hand\ A}, 
we can use the assumption \ml{"A = Z"} to rewrite the \ml{"A"} to a \ml{"Z"}.
The resulting lemma could then be used to simplify the focus to \ml{"T"}.
d459 2
a460 1
   #OPEN_CONTEXT "(A /\ B) /\ A" [RATOR; RAND; RATOR; RAND];;
d465 2
a466 2
   <== * A
   () : void
d468 1
a468 1
Note that we are now preserving the relation \ml{"<=="},
d472 16
a487 15
   #REWRITE_WIN [ASSUME "A:bool = Z:bool"];;
       ! A = Z
       ! (A /\ B) /\ A
       ! A
       ! B
   <== * Z
   () : void
   
   #CLOSE_WIN ();;
       ! A = Z
       ! (A /\ B) /\ A
       | (Z /\ B) /\ A
   ==> * (Z /\ B) /\ A
   () : void
\end{verbatim}\end{session}
d495 2
a496 2
\ml{"C"} follows from \ml{"P"}.
Initially the set of suppositions associated with the window stack is empty.
d499 1
a499 1
   ADD_SUPPOSE : (goal -> void)
d501 2
a502 2
The command \ml{CONJECTURE "C"} is a shorthand for adding a supposition with
conclusion \ml{"C"} and assumptions the same as those of the current window.
d504 1
a504 1
   CONJECTURE : (term -> void)
d511 1
a511 1
When a window is printed, the conclusions of those suppositions which
d522 2
a523 2
Conjectures may be used like the other elements of the context, except once
used\index{conjectures!used} a conjecture must be proved.
a535 5
A list of the bad conjectures of the current window can be obtained with 
the command:
\begin{boxed}\begin{verbatim}
   BAD_CONJECTURES : void -> term list
\end{verbatim}\end{boxed}\index{BAD\_CONJECTURES@@{\ptt BAD\_CONJECTURES}}
d542 2
a543 1
   #BEGIN_STACK `suppose-ex` "(=) ((A \/ ~A) \/ B)" [] [];;
d545 1
a545 1
   () : void
d547 1
a547 1
If we assume that we can prove \ml{"A \hor\ \hnot A"},
d550 2
a551 1
   #CONJECTURE "A \/ ~A";;
d554 2
a555 1
   () : void
a556 1
   #REWRITE_WIN [ASSUME "A \/ ~A"];;
d559 3
a561 4
   () : void

   #WIN_THM ();;
   A \/ ~A |- T = (A \/ ~A) \/ B
d571 1
a571 2
all conjectures used in generating that lemma will then be
considered to have been used.
d580 1
a580 1
   ESTABLISH : term -> void
d582 4
a585 4
\ml{ESTABLISH "C"} opens a new subwindow with \ml{"C"} as its focus and
\ml{"==>"} as the relation it preserves.
If you can transform the focus of this subwindow to \ml{"T"} and then
close the window, \ml{"C"} will become a lemma in the parent window.
d589 15
a603 17
#ESTABLISH "A \/ ~A";;
    ? A \/ ~A
==> * A \/ ~A
() : void

#REWRITE_WIN [EXCLUDED_MIDDLE];;
    ? A \/ ~A
==> * T
() : void

#CLOSE_WIN ();;
  | A \/ ~A
= * T
() : void

#WIN_THM ();;
|- T = (A \/ ~A) \/ B
d618 1
a618 1
   SET_STACK : string -> void
d628 1
a628 1
   END_STACK : string -> void
d639 6
a644 1
   CURRENT_NAME : void -> string
d646 1
d650 1
a650 1
   ALL_STACKS : void -> void
d653 1
a653 95
\subsection{The xlabel Library Component}

If you are running the HOL and the window system from within an Xterminal
(an X windows pseudo-terminal),
then the xlabel library component may be of help to you.
The xlabel library component will set the title bar of the Xterminal
to contain the name of the current stack, and maintain the title whenever the
the current stack is changed.
To load the xlabel component, first load the library as described in
section~\ref{sec:start}, then type the following:
\begin{hol}\begin{alltt}
	load_library `window:xlabel`;;
\end{alltt}\end{hol}

\section{Batch Proof}

Once you have completed a proof with the window system, you may wish to
reuse part or all of that proof.
Until now, the proof has been developed as a series of operations on a stack
of windows.
Proofs can be repeated noninteractively without using the window stack.
Each of the interactive commands we have seen so far
(except the undo and stack related commands)
has a batch equivalent.
The batch commands have the same name as their interactive
counterparts, except they are in lowercase.

A batch command to transform a window
takes the original window as an argument and returns the transformed window.
All such commands will have the basic type \ml{:window -> window}.
Batch analogues to commands which create subwindows
have an argument of the transformation function to apply to the subwindow.
They then take the original parent window as an argument,
open a subwindow in the parent,
apply the transformation function to the subwindow,
and close the subwindow,
returning the transformed parent window.
All of these commands will have the basic type 
\ml{:(window -> window) -> window -> window}.
The batch commands use of the \ML\ run-time stack 
mirrors the use of the window stack during interactive proof.

As an illustration of batch proof, we now repeat the first proof of
section~\ref{sec:start}.
\setcounter{sessioncount}{1}
\begin{session}\begin{verbatim}
   #let w1 = create_win "(==>) (A /\ (B /\ C))" ["~C"] [] [];;
   w1 = (|- A /\ B /\ C ==> A /\ B /\ C, ["~C"], [], []) : window
\end{verbatim}\end{session}
The \ml{create\_win} command creates a window with the specified 
relation and focus.   Its other parameters specify lists of assumptions
to make and theorems that might be relevant to the window.
\ml{create\_win} is the noninteractive analogue of \ml{BEGIN\_STACK}.
\begin{session}\begin{verbatim}
   #let w2 = ((pure_rewrite_win [ASSUME "~C"]) CB
   #          (open_win [RAND] (rewrite_win []))) w1;;
   w2 = (~C |- A /\ F ==> A /\ B /\ C, ["~C"], [], []) : window
   
   #win_thm w2;;
   ~C |- A /\ F ==> A /\ B /\ C
\end{verbatim}\end{session}
(Note that \ml{CB}\index{CB@@{\ptt CB}} is new to release 2.0 of \HOL:
\ml{f CB g = g o f}.)
Since this particular combination of commands is quite common,
the one command \ml{transform} has been created for this situation.
\begin{boxed}\begin{verbatim}
   transform : (term -> term list -> thm list -> (window -> window) -> thm
\end{verbatim}\end{boxed}\index{transform@@{\ptt transform}}
\ml{transform} creates a window, transforms it and returns the resulting
theorem.
\setcounter{sessioncount}{1}
\begin{session}\begin{verbatim}
   #transform "(==>) (A /\ (B /\ C))" ["~C"] []
   #          ((pure_rewrite_win [ASSUME "~C"]) CB
   #           (open_win [RAND] (rewrite_win [])));;
   ~C |- A /\ F ==> A /\ B /\ C
\end{verbatim}\end{session}

To interface between interactive and batch proof the following
functions are provided:
\begin{boxed}\begin{verbatim}
   TOP_WIN : void -> window
   APPLY_TRANSFORM : (window -> window) -> void
\end{verbatim}\end{boxed}\index{TOP\_WIN@@{\ptt TOP\_WIN}}\index{APPLY\_TRANSFORM@@{\ptt APPLY\_TRANSFORM}}
\ml{TOP\_WIN} returns the window on the top of the window stack.
\ml{APPLY\_TRANSFORM} applies a window transformation function to the top of
the stack.
All the interactive transformation commands can be described with
\ml{APPLY\_TRANSFORM}.
For example,
\begin{alltt}
   REWRITE_WIN thms \(=\) APPLY_TRANSFORM (rewrite_win thms)
\end{alltt}

\section{The tactic Library Component}
d655 3
a657 2
Most proof done with \HOL\ uses the subgoal package.
For most applications the subgoal package remains the most appropriate tool.
a658 5
If you would like to use window inference from within the subgoal package
you should load the tactic library component as follows:
\begin{hol}\begin{alltt}
	load_library `window:tactic`;;
\end{alltt}\end{hol}
d660 2
a661 2
The tactic library component contains the following functions for 
mixing the window inference and subgoal proof styles:
d663 8
a670 13
   BEGIN_STACK_TAC : string -> path -> thm list -> tactic
   END_STACK_TAC : tactic
   open_TAC : path -> thm list -> (window -> window) -> tactic
\end{verbatim}\end{boxed}\index{BEGIN\_STACK\_TAC@@{\ptt BEGIN\_STACK\_TAC}}\index{CLOSE\_STACK\_TAC@@{\ptt CLOSE\_STACK\_TAC}}\index{open\_TAC@@{\ptt open\_TAC}}
\ml{BEGIN\_STACK\_TAC} and \ml{END\_STACK\_TAC} are for interactive use only and
should be used to develop a proof.
Once developed, a proof can be repeated with \ml{open\_TAC}.
The idea behind these tactics is to open a window inside the current goal,
so as to transform some subterm of the goal.
The path parameter of both \ml{OPEN\_TAC} and \ml{open\_TAC} is the path
through the goal to the focus of the required subwindow.
The list of theorems is the list of theorems that might be relevant to
the proof.
d672 2
a673 2
Here is a simple interactive example.
Suppose we had as our current goal the term \ml{"A \hand\ B \hand\ F"}.
d676 11
a686 4
   #set_goal ([], "A /\ B /\ F");;
   "A /\ B /\ F"
   
   () : void
d688 2
a689 2
If we wanted to rewrite just the subterm \ml{"B \hand\ F"} to \ml{"F"} we
can do this by opening a window on the subterm.
d691 1
a691 1
   #expand (BEGIN_STACK_TAC `tac-ex` [RAND] []);;
a692 2
   ==> * B /\ F
   "A /\ B /\ F"
d694 15
a708 1
   () : void
d710 1
a710 1
Having opened at window on the desired subterm we can rewrite it without
d713 5
a717 3
   #REWRITE_WIN [];;
   ==> * F
   () : void
d724 1
a724 2
   #expand (END_STACK_TAC `tac-ex`);;
   ==> * F
d726 9
a734 18
   "A /\ F"
   
   () : void
\end{verbatim}\end{session}
The same example is repeated here with the window inference performed
noninteractively.
\setcounter{sessioncount}{1}
\begin{session}\begin{verbatim}
   #set_goal ([], "A /\ (B /\ F)");;
   "A /\ B /\ F"
   
   () : void
   
   #expand (open_TAC [RAND] [] (rewrite_win []));;
   OK..
   "A /\ F"
   
   () : void
d741 1
a741 1
These rules are called {\it window rules\/} and the system keeps them
d747 1
a747 1
\ml{"="}, \ml{"==>"} and \ml{"<=="}.
d751 2
a752 2
terms: \ml{"\_\hand\_"}, \ml{"\_\hor\_"}, \ml{"\_==>\_"}, \ml{"\_<==\_"},
\ml{"\_=>\_|\_"}, \ml{"(\\\_.\_)\_"}, and \ml{let\_=\_in\_}.
d758 1
a758 1
A rule should take, the focus of the parent window and the theorem held
d761 3
a763 3
For example, the window rule \ml{IMP\_CONJ1\_CLOSE} as defined below is used
when opening a subwindow at \ml{"A"} in \ml{"A \hand\ B"} while preserving
\ml{"==>"} in the parent window.
d765 3
a767 3
          B |- A' ==> A
   ---------------------------  IMP_CONJ1_CLOSE "A /\ B" 
    |- (A' /\ B) ==> (A /\ B)
d769 1
a769 1
Each rule in the system is packaged with the following information:
d774 3
a776 4
		\ml{[RATOR; RAND]}.
	\item	A function from the focus of the parent window to \ml{bool}.
		The function is true iff the rule is applicable to the
		focus.
d779 1
a779 1
	\item	A function which takes the focus of the parent window and
d783 1
a783 1
		\ml{IMP\_CONJ1\_CLOSE} always preserves \ml{"==>"} in the
d785 1
a785 1
	\item	A function which takes the focus of the parent window and
d789 1
a789 1
		\ml{IMP\_CONJ1\_CLOSE} always preserves \ml{"==>"} in the
d791 2
a792 3
	\item	A function which takes the focus and assumptions of the
		parent window, and returns the assumptions of the 
		child window.
d795 1
a795 1
		theorems each of which has just one hypothesis.
d799 2
a800 2
		\ml{"\(a\) \hand\ \(b\) \hand\ \(c\)"}.
		If you were to open a subwindow at \ml{"\(a\)"} in such a 
d802 5
a806 5
		assumptions, \ml{"\(b\)"} and \ml{"\(c\)"}.
		However a batch command would probably expect that when
		opening a window at the first operand of a conjunction, it
		would gain the second operand of the conjunction
		(namely \ml{"\(b\) \hand\ \(c\)"}) as an assumption.
d811 1
a811 1
		The system then knows that \ml{"\(b\) \hand\ \(c\)"} can
d813 1
a813 1
		\ml{"\(b\)"} and \ml{"\(c\)"}.
d815 2
a816 2
		(namely \ml{"\(b\)"} and \ml{"\(c\)"}) will be displayed as
		assumptions to the user during interactive proof.
d818 2
a819 2
	\item   A function which takes the focus of the parent window
		and returns the list of variables which appear
d823 2
a824 2
		an abstraction, it returns the list of variables bound by
		the abstraction, otherwise the empty list is returned.
d829 1
a829 1
   store_rule : window_rule -> void
d833 7
a839 8
   lettype window_rule = (  path
                         #  (term -> bool)
                         #  (term -> term -> term)
                         #  (term -> term -> term)
                         #  (term -> ((thm list) -> (thm list)))
                         #  (term -> (term list))
                         #  (term -> (thm -> thm))
                         );;
d846 9
a854 8
   store_rule   (   [RATOR; RAND]
                ,   is_conj
                ,   (\foc.\rel. "==>")
                ,   (\foc.\rel. "==>")
                ,   (\foc.\hyps. (SMASH (ASSUME (rand foc)))@@hyps)
                ,   (\foc. [])
                ,   IMP_CONJ1_CLOSE
                );;
d859 8
d868 1
a868 1
possible lists of window rules which could have been chained together 
d909 1
a909 1
and transitive: \ml{"="}, \ml{"==>"} and \ml{"<=="}.
d914 1
a914 1
   add_relation : (thm # thm) -> void
d917 1
a917 1
as \ml{EQ\_REFL} and \ml{EQ\_TRANS} and stores these theorems for use by
d932 1
a932 1
   add_relation (IMP_REFL_THM, IMP_TRANS_THM);;
d946 1
a946 1
   |- \(f\sb{n+1}\) \(r\sb{1}\) \(f\sb{n}\)
d951 1
a951 1
in the focus of a window which is supposed to be preserving the relation
d953 1
a953 1
a window rule which preserves $r_1$.
d958 1
a958 2
The window library knows this, so,
when adding some new relation,
d961 1
a961 1
say \ml{"r1"} and \ml{"r2"}, such that \ml{"r1"} is stronger than \ml{"r2"},
d972 1
a972 1
   add_weak : thm -> void
d981 1
a981 22
Some changes to the window library are currently being considered.
These changes include:
\begin{itemize}
	\item	The window rules for opening inside the body of abstractions
		may be changed so that they rename
		bound variables rather than hiding assumptions in which
		the bound variables occur.
	\item	I may add the ability to weaken the premises of
		a supposition.
		This would be an alternative to compelling the user to prove
		used conjectures.
	\item	It may be possible to specify a path to a subterm with
		pattern matching.
	\item	Some functions which are currently considered {\it internal\/}
		to the system may be documented in future releases.
\end{itemize}

The window library is still work in progress.
It has been released to solicit comment as much as to provide a service.
As people begin to use the software I expect various infelicities to be brought
to light.
It is my intention to keep the interface fluid
d987 2
a988 2
contact me.   I will endeavour to provide bug fixes as soon as possible.
When reporting a bug, please be sure to tell me which versions of the 
d994 13
a1006 9
	\begin{tabular}{l@@{\hspace{10mm}}ll}
		Jim Grundy				&			&								\\
		University of Cambridge	& phone:	&	+44$\;$223$\:$33$\,$4760	\\
		Computer Laboratory		& fax:		&	+44$\;$223$\:$33$\,$4678	\\
		New Museums Site		& telex:	&	CAMSPLG 81240				\\
		Pembroke Street			& email:	&	jg@@cl.cam.ac.uk				\\
		Cambridge\ \ {\small CB}2 3{\small QG}	&	&						\\
		UNITED KINGDOM			&			&								\\
	\end{tabular}
d1011 8
a1018 8
	Opening a window inside a \ml{let} expression will not work properly
		for \ml{let} expressions involving tuples of variables or
		which use the \ml{and} construct.

\section*{Acknowledgements}
	I would like to thank Andy Gordon, Mats Larsson, Laurent Thery and
		Joakim von Wright, all of whom have found bugs in earlier versions of
		the system, and suggested many improvements.
@
