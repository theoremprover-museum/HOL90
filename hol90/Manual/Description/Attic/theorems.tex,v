head	1.3;
access;
symbols
	HOL97:1.3.2.2.0.2
	bpHOL97:1.3.2.2
	hol90_9_alpha:1.3.2.2
	hol90_pre8_for_multiple_compilers:1.3.0.2
	hol90_manual_after_dons_changes:1.2;
locks; strict;
comment	@% @;


1.3
date	96.09.04.19.01.44;	author drs1004;	state dead;
branches
	1.3.2.1;
next	1.2;

1.2
date	96.09.04.18.46.12;	author drs1004;	state Exp;
branches;
next	1.1;

1.1
date	96.02.27.15.12.01;	author drs1004;	state Exp;
branches;
next	;

1.3.2.1
date	96.09.04.19.04.00;	author drs1004;	state Exp;
branches;
next	1.3.2.2;

1.3.2.2
date	96.09.06.09.53.26;	author rjb;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Moving Manual changes to main devlopment branch (hol0_pre8 etc.)
@
text
@\chapter{Theorems and Theories of the HOL Logic in ML}
\label{avra_theorems}
% I have added this section in a hurry 9 Nov 89.  Was missing!

In this chapter, the description of the 
concrete representation of the \HOL\ logic is continued.
This involves describing the \ML\ functions that comprise the 
representation of theorems (Section~\ref{avra_theorems});
the representation of theories
(Section~\ref{theoryfns}); and the primitive methods
for extending theories (Section~\ref{theory-extension}).
The reader is assumed to be familiar
with the material from Section~\ref{TypesTerms}.

%; the basic \HOL\ theories that are built into the
%\HOL\ system (Sections~\ref{HOL-theory} and \ref{rules}); and the methods for
%extending theories (throughout Section~\ref{HOL-ancestry} and in
%Section~\ref{types-package}).  

\section{Theorems}

In the formal description of the \HOL\ logic in
Chapter~\ref{logic}, the notion of deduction is introduced in terms
of {\it sequents\/}\index{sequents!in natural deduction}, where a sequent
is a pair whose second component is a formula being
asserted (a conclusion)\index{conclusions!of sequents}, 
and whose first component is a set of formulas (hypotheses)\index{hypotheses!of sequents}.
Based on this is the notion of a {\it deductive system\/}\index{natural deduction}\index{deductive systems}: a set of pairs,
whose second component is a sequent, and
whose first component is a sequent list\footnote{Note that these sequents
form a list, not a set; that is, are ordered.}.
The concept of a sequent {\it following from\/}\index{follows from, in natural deduction}
a set of sequents via a
deductive system is then defined: a sequent follows from a set of sequents if
the sequent
is the last element of some chain of sequents, each of whose
elements is either in the set, or itself follows from the set along with
earlier elements of the chain, via the deductive system.

A notation for `follows from' is then introduced.
That a
sequent $(\{t_1,\ldots,t_n\},\ t)$ follows from
a set of sequents $\Delta$, via a deductive system ${\cal D}$, is
denoted\index{turnstile notation|(} by: $t_1,\ldots,t_n\vdash_{{\cal D},\Delta} t$.
(Note that
where either ${\cal D}$ or $\Delta$ is clear by context, their mention
could be omitted; and where the set of hypotheses was empty,
its mention could be omitted.)

A sequent that follows from the empty set of sequents via
a deductive system is called a {\it theorem\/} of that deductive system.
That is, a theorem\index{theorems, in natural deduction} is the last element of a {\it proof\/}\index{proof!in natural deduction} (in the sense
of Chapter~\ref{logic}) from the empty
set of sequents. When a pair $(L,(\Gamma,t))$ belongs to a deductive system,
and the list $L$ is empty, 
then the sequent $(\Gamma,t)$ is called an {\it axiom\/}\index{axioms!in
natural deduction}. 
Any pair $(L,(\Gamma,t))$ belonging to 
a deductive system is called a {\it primitive inference\/}\index{inference, in natural deduction}\index{primitive inference, in natural deduction}
of the system, with hypotheses\footnote{Note that
"hypotheses' and "conclusion' are also used for the components
of sequents.} $L$ and 
conclusion $(\Gamma,t)$.

A formula\index{formulas as terms, in HOL logic@@formulas as terms, in \HOL\ logic}
 in the abstract is represented concretely in \HOL\ by
a term whose \HOL\ type is {\small\verb%(==`:bool`==)%}.
Therefore, a term\index{terms, in HOL logic@@terms, in \HOL\ logic!as logical formulas} of type {\small\verb%(==`:bool`==)%} is used to represent
a member of the set of hypotheses of a sequent;
and likewise to represent the
conclusion of a sequent.
Sets in this context
are represented by lists, so the set of hypotheses of a sequent\index{sequents!representation of, in HOL logic@@representation of, in \HOL\ logic}
is represented by a list of {\small\verb%(==`:bool`==)%}-typed terms.

A theorem in the abstract is represented concretely in the \HOL\
system by a value with the \ML\ abstract type
{\small\verb%thm%}\index{thm@@\ml{thm}}. 
The type {\small\verb%thm%} has a primitive destructor function

\begin{boxed}
\index{dest_thm@@\ml{dest\_thm}|pin}
\begin{verbatim}
   dest_thm : thm -> (term list * term)
\end{verbatim}\end{boxed}

\noindent which returns a pair consisting of the hypothesis\index{hypotheses!of theorems} list and
the conclusion\index{conclusions!of theorems}, respectively, of a theorem.
From this, two destructor\index{theorems, in HOL logic@@theorems, in \HOL\ logic!destructors for} functions are derived


\begin{boxed}
\index{hyp@@\ml{hyp}|pin}
\index{concl@@\ml{concl}|pin}
\begin{verbatim}
   hyp   : thm -> term list
   concl : thm -> term
\end{verbatim}\end{boxed}

\noindent for extracting the hypothesis list and the conclusion, respectively,
of a theorem. The \ML\ type {\small\verb%thm%} does not have
a primitive constructor function.  In this way, the \ML\ type system protects
the \HOL\ logic
from the arbitrary and unrecorded construction 
of theorems, which would compromise
the consistency\index{consistency, of HOL logic@@consistency, of \HOL\ logic} of the logic. (Functions which return theorems as values,
\eg\ functions representing primitive inferences,
are discussed first in Section~\ref{rules}, and further in 
Chapter\ref{derived-rules}.)

It was mentioned in Chapter~\ref{logic} that the deductive system of \HOL\
includes five axioms\footnote{This is
a simplification: 
%each inference rule corresponds to an infinite family of elements
%of the deductive system, and
the axioms are written in an extension 
of the basic logic. See Section~\ref{axioms-and-rules}.}.
In that Chapter, the axioms were presented in abstract form.
The concrete representation of the axioms in \HOL\ is given
in Section~\ref{HOL-theory}.
% and of the inference rules, in 
%Section~\ref{rules}. 
To anticipate, the axiom \ml{BOOL\_CASES\_AX}
mentioned in Chapter~\ref{logic} is printed in \HOL\ as follows
(where \ml{T} and \ml{F} 
are the \HOL\ logic's constants representing truth and
falsity, respectively):

\begin{hol}
\index{F@@\ml{F}!axiom for}
\begin{verbatim}
   |- !t. (t = T) \/ (t = F)
\end{verbatim}\end{hol}

\noindent Note the special print format\index{printing, in HOL logic@@printing, in \HOL\ logic!of theorems},
 with the approximation
to the abstract $\vdash$ notation\index{theorem notation, in HOL logic@@theorem notation, in \HOL\ logic|(}, \ml{|-}, used to indicate \ML\ type
{\small\verb%thm%} status;
the absence of \HOL\ quotation marks\index{ theorem marker, in HOL logic@@\ml{(--`|-} (theorem marker, in \HOL\ logic)} 
 in the \ml{|-} context; and
the absence of type information following the printed term.
The session below illustrates
the use of the destructor functions:

\setcounter{sessioncount}{1}
\begin{session}\begin{verbatim}
- val th = BOOL_CASES_AX;
val th = |- !t. (t = T) \/ (t = F) : thm

- hyp th;
val it = [] : term list

- concl th;
val it = (--`!t. (t = T) \/ (t = F)`--) : term

- type_of it;
val it = (==`:bool`==) : typ
\end{verbatim}\end{session}\index{turnstile notation|)}

\noindent In addition to the print conventions mentioned above,
the printing of theorems prints hypotheses\index{printing, in HOL logic@@printing, in \HOL\ logic!of hypotheses of theorems}
 as periods (\ie\ full stops or
dots).  When set, the flag \ml{show\_assums}
prints theorems with hypotheses shown in full. 
These points are illustrated with a
theorem inferred, for example purposes, from another axiom mentioned
in Chapter~\ref{logic}: \ml{SELECT\_AX}.

\setcounter{sessioncount}{1}
\begin{session}\begin{verbatim}
- UNDISCH (SPEC_ALL SELECT_AX);
val it = . |- P($@@ P) : thm

- show_assums := true;
val it = () : unit

- UNDISCH (SPEC_ALL SELECT_AX);
val it = [P x] |- P($@@ P) : thm
\end{verbatim}\end{session}\index{theorem notation, in HOL logic@@theorem notation, in \HOL\ logic|)}

\section{The core of the HOL logic in ML}

\label{axioms-and-rules}

Upon startup, the \HOL\ system contains \ML\ functions and values
which implement the axioms and inference rules of the \HOL\ logic
as described in Section~\ref{HOL-logic}.  The axioms are values
of \ML\ type \ml{thm}.
The rules of inference are
\ML\ functions which can create \ml{thm} under certain conditions.
These objects together, constitute the core of the
\HOL\ logic.  


%\footnote{To simplify the porting of the LCF theorem-proving
%tools to the HOL system, the HOL logic was made as like PP$\lambda$ (the logic
%built-in to LCF) as possible.} the particular axiomatization\index{axioms!non-primitive, of HOL logic@@non-primitive, of \HOL\ logic} of
%higher order logic it uses differs from the classical
%axiomatization due to Church\index{Church, A.} \cite{Church}.  The biggest difference is that
%in Church's formulation type variables\index{type variables, in HOL logic@@type variables, in \HOL\ logic!differences from classical} are in the meta-language, whereas
%in the \HOL\ logic they are part of the object language.

There are three primitive constants
\index{constants, in HOL logic@@constants, in \HOL\ logic!primitive logical}\index{primitive constants, of HOL logic@@primitive constants, of \HOL\ logic}
 upon which the inference rules and five axioms are built:
{\small\verb%=%}\index{ equality, in HOL logic@@\ml{=} (equality, in \HOL\ logic)}\index{equality, in HOL logic@@equality, in \HOL\ logic}
 (equality, an infix), {\small\verb%==>%}\index{ implication, in HOL logic@@{\small\verb+==>+} (implication, in \HOL\ logic)} (implication, an
infix) and {\small\verb%@@%}\index{ choice function, in HOL logic@@{\small\verb+(--`@@+} (choice function, in \HOL\ logic)}\index{choice operator, in HOL logic@@choice operator, in \HOL\ logic} (choice, a binder).  Equality\index{equality, in HOL logic@@equality, in \HOL\ logic}\index{implication, in HOL logic@@implication, in \HOL\ logic}
 and implication
are standard predicate calculus notions, but choice is more exotic:
if $t$ is a term having type $\sigma${\small\verb%->bool%}, 
then {\small\verb%@@x.%}$t${\small\verb% x%} (or, equivalently,
{\small\verb%$@@%}$t$) denotes {\it some\/} member of the set whose
characteristic\index{characteristic predicate, of type definitions}
 function is $t$. If the set is empty, then
{\small\verb%@@x.%}$t${\small\verb% x%} denotes an arbitrary member of the
set denoted by $\sigma$. The constant {\small\verb%@@%} is a higher order
version of Hilbert's\index{Hilbert, D.}\index{epsilon operator}
 $\hilbert$-operator; it is related to the constant
$\iota$ in Church's formulation of higher order logic. For more details,
see Church's\index{Church, A.} original paper \cite{Church}, Leisenring's\index{Leisenring, A.} book 
on Hilbert's $\hilbert$-symbol \cite{Leisenring}, or
Andrews' textbook on type theory \cite{Andrews}.

Several logical constants are needed to introduce the
axioms of the \HOL\ system - these are introduced by the
constant specification mechanism described in
Section~\ref{constant-specification}.  They include
\index{logical constants, in HOL logic@@logical constants, in \HOL\ logic} {\small\verb%T%}\index{truth values, in HOL logic@@truth values, in \HOL\ logic!constants for}\index{T@@\ml{T}!defined in terms of primitives} (truth), {\small\verb%F%}\index{F@@\ml{F}!defined in terms of primitives} (falsity),
{\small\verb%~%} (negation)\index{ negation, in HOL logic@@{\small\verb+~+} (negation, in \HOL\ logic)}, {\small\verb%/\%} (conjunction)\index{ conjunction, in HOL logic@@{\small\verb+/\+} (conjunction, in \HOL\ logic)}\index{conjunction, in HOL logic@@conjunction, in \HOL\ logic!defined in terms of primitives},
{\small\verb%\/%} (disjunction)\index{ disjunction, in HOL logic@@{\small\verb+\/+} (disjunction, in \HOL\ logic)}\index{disjunction, in HOL logic@@disjunction, in \HOL\ logic!defined in terms of primitives}, {\small\verb%!%} (universal
quantification)\index{ universal quantifier, in HOL logic@@{\small\verb+"!+} (universal quantifier, in \HOL\ logic)}\index{universal quantifier, in HOL logic@@universal quantifier, in \HOL\ logic!defined in terms of primitives}, {\small\verb%?%} (existential quantification)\index{ existential quantifier, in HOL logic@@{\small\verb+?+} (existential quantifier, in \HOL\ logic)}\index{existential quantifier, in HOL logic@@existential quantifier, in \HOL\ logic!defined in terms of primitives}
and {\small\verb%?!%} (unique existence quantifier)\index{ exists unique, in HOL logic@@{\small\verb+?(--`!+} (exists unique, in \HOL\ logic)}\index{exists unique, in HOL logic@@exists unique, in \HOL\ logic!defined in terms of primitives}.
These can all
be defined in terms of equality\index{equality, in HOL logic@@equality, in \HOL\ logic}, 
implication and choice.  The definitions
listed below are fairly standard; each one is preceded by its \ML\ name.
(Later definitions sometimes use earlier ones.) 


\begin{hol}
\index{truth values, in HOL logic@@truth values, in \HOL\ logic!definition of}
\index{T_DEF@@\ml{T\_DEF}}
\index{T@@\ml{T}!definitional axiom for}
\index{disjunction, in HOL logic@@disjunction, in \HOL\ logic!definitional axiom for}
\index{conjunction, in HOL logic@@conjunction, in \HOL\ logic!definitional axiom for}
\index{iff, in HOL logic@@iff, in \HOL\ logic!definitional axiom for}
\index{F@@\ml{F}!axiom for}
\index{F@@\ml{F}!definitional axiom for}
\index{ exists unique, in HOL logic@@{\small\verb+?"!+} (exists unique, in \HOL\ logic)}
\index{T_DEF@@\ml{T\_DEF}}
\index{FORALL_DEF@@\ml{FORALL\_DEF}}
\index{EXISTS_DEF@@\ml{EXISTS\_DEF}}
\index{AND_DEF@@\ml{AND\_DEF}}
\index{OR_DEF@@\ml{OR\_DEF}}
\index{F_DEF@@\ml{F\_DEF}}
\index{conjunction, in HOL logic@@conjunction, in \HOL\ logic!definitional axiom for}
\index{disjunction, in HOL logic@@disjunction, in \HOL\ logic!definitional axiom for}
\index{equality, in HOL logic@@equality, in \HOL\ logic!primitive axiom for}
\index{existential quantifier, in HOL logic@@existential quantifier, in \HOL\ logic!definitional axiom for}
\index{universal quantifier, in HOL logic@@universal quantifier, in \HOL\ logic!definitional axiom for}
\begin{verbatim}
   T_DEF              |- T   = ((\x:bool. x)=(\x. x))

   FORALL_DEF         |- $!  = \P:'a->bool. P=(\x. T)

   EXISTS_DEF         |- $?  = \P:'a->bool. P($@@ P)

   AND_DEF            |- $/\ = \t1 t2. !t. (t1 ==> t2 ==> t) ==> t

   OR_DEF             |- $\/ = \t1 t2. !t. (t1 ==> t) ==> (t2 ==> t) ==> t

   F_DEF              |- F   = !t. t

   ONE_ONE_DEF        |- ONE_ONE f = (!x1 x2. (f x1 = f x2) ==> (x1 = x2))

   ONTO_DEF           |- ONTO f    = (!y. ?x. y = f x)
\end{verbatim}\end{hol}


\subsection{Axioms of the HOL logic}

The five\index{universal quantifier, in HOL logic@@universal quantifier, in \HOL\ logic!in four primitive axioms}
axioms of the \HOL\ logic are now represented by the following
values:

\begin{hol}
\index{BOOL_CASES_AX@@\ml{BOOL\_CASES\_AX}}
\index{IMP_ANTISYM_AX@@\ml{IMP\_ANTISYM\_AX}}
\index{ETA_AX@@\ml{ETA\_AX}}
\index{SELECT_AX@@\ml{SELECT\_AX}}
\index{implication, in HOL logic@@implication, in \HOL\ logic!primitive axiom for}
\index{choice function, in HOL logic@@{\small\verb+"@@+} (choice function, in \HOL\ logic)}
\index{choice axiom}
\index{choice operator, in HOL logic@@choice operator, in \HOL\ logic!primitive axiom for}
\index{INFINITY_AX@@\ml{INFINITY\_AX}}
\index{axiom of infinity}
\index{existential quantifier, in HOL logic@@existential quantifier, in \HOL\ logic!in infinity axiom}
\begin{verbatim}
   BOOL_CASES_AX   |- !t. (t = T) \/ (t = F)

   IMP_ANTISYM_AX  |- !t1 t2. (t1 ==> t2) ==> (t2 ==> t1) ==> (t1 = t2)

   ETA_AX          |- !t. (\x. t x) = t

   SELECT_AX       |- !P:'a->bool x. P x ==> P($@@ P)

   INFINITY_AX     |- ?f:ind->ind. ONE_ONE f /\ ~(ONTO f)
\end{verbatim}\end{hol}

\noindent \ml{INFINITY\_AX} is the {\it Axiom of Infinity\/}\index{axiom of infinity}. 
This axiom states that the set denoted by the type
\ml{ind} is infinite. 
It says this by asserting that there exists a one-to-one map from {\small\verb%ind%} to
itself that is not onto. This implies that the type {\small\verb%ind%}
denotes an infinite set.\index{axioms!primitive, of HOL logic@@primitive, of \HOL\ logic|)}

These five axioms, the rules of inference in
Section~\ref{rules} are, together, sufficient for
developing all of standard mathematics. Thus, in principle, the user of the
\HOL\ system should never need to make a non-definitional\index{axioms!dispensibility of adding}\index{definitional theories} theory. In
practice, it is often tempting to take the `risk' of introducing new
axioms because deriving them conservatively can be tedious---proving that
`axioms' follow from definitions amounts to proving their consistency.

\subsection{Primitive rules of inference of the HOL logic}
\label{rules}

\index{inference rules, of HOL logic@@inference rules, of \HOL\ logic!primitive|(}
The primitive rules of inference of the logic were described abstractly
in Section~\ref{HOLrules}. The descriptions relied on meta-variables
$t$, $t_1$, $t_2$, and so on.
In the \HOL\ logic, infinite families of primitive
inferences are grouped together and thought of as single primitive inference
schemes.\index{families of inferences, in HOL logic@@families of inferences, in \HOL\ logic}  Each family contains all the concrete instances of one
particular inference `pattern'. These can be produced, in
abstract form, by instantiating the meta-variables in Section~\ref{HOLrules}
to concrete terms.

In \HOL, primitive inference schemes are represented
by \ML\ functions that return theorems as values.
That is, for particular \HOL\ terms, the \ML\ functions return
the instance of the theorem at those terms. The \ML\ functions
are part of the \ML\ abstract type
 \ml{thm}\index{thm@@\ml{thm}}:
although \ml{thm} has no primitive constructors, it has (eight)
operations which return theorems as values: \ml{ASSUME}, \ml{REFL}, 
\ml{BETA\_CONV}, \ml{SUBST}, \ml{ABS}, \ml{INST\_TYPE},
\ml{DISCH} and \ml{MP}.\index{inference schemes, in HOL logic@@inference schemes, in \HOL\ logic}

The \ML\ functions that implement the primitive inference
schemes in the \HOL\
system are  described  below.
The same notation\index{notation!for specification of rules}\index{inferences, in HOL logic@@inferences, in \HOL\ logic!notation for}
 is used here as in Section~\ref{HOLrules}:
hypotheses above a horizontal line and conclusion\index{conclusions!of inference rules} beneath.
The  machine-readable  {\small ASCII}
notation is used for the logical constants.

\subsubsection{Assumption introduction}\index{assumption introduction, in HOL logic@@assumption introduction, in \HOL\ logic!ML function for@@\ML\ function for} 

\begin{boxed}
\index{ASSUME@@\ml{ASSUME}|pin}
\begin{verbatim}
   val ASSUME : term -> thm
\end{verbatim}\end{boxed}

\begin{center}
\begin{tabular}{c}
  \\ \hline
$t${\small\verb% |- %}$t$ \\
\end{tabular}
\end{center}

\noindent
{\small\verb%ASSUME %}$t${\small\verb%%} evaluates to $t${\small\verb%|- %}$t$.
Failure if $t$ is not of type \ml{bool}.

\bigskip

\subsubsection{Reflexivity}\index{reflexivity, in HOL logic@@reflexivity, in \HOL\ logic!ML function for@@\ML\ function for} 

\begin{boxed}\index{REFL@@\ml{REFL}|pin}
\begin{verbatim}
   val REFL : term -> thm
\end{verbatim}\end{boxed}

\begin{center}
\begin{tabular}{c}
  \\ \hline
{\small\verb% |- %}$t${\small\verb% = %}$t$ \\
\end{tabular}
\end{center}

\noindent {\small\verb%REFL %}$t${\small\verb%%} evaluates to {\small\verb%|-
%}$t${\small\verb% = %}$t$. A call to \ml{REFL} never fails.

\bigskip

\subsubsection{Beta-conversion}\index{beta-conversion, in HOL logic@@beta-conversion, in \HOL\ logic!ML function for@@\ML\ function for} 

\begin{boxed}\index{BETA_CONV@@\ml{BETA\_CONV}|pin}
\begin{verbatim}
   val BETA_CONV : term -> thm
\end{verbatim}\end{boxed}

\begin{center}
\begin{tabular}{c}
  \\ \hline
{\small\verb% |- (\%}$x${\small\verb%.%}$t_1${\small\verb%)%}$t_2${\small\verb% = %}$t_1[t_2/x]$
\end{tabular}
\end{center}

\begin{itemize}
\item where $t_1[t_2/x]$ denotes the result of substituting $t_2$ for $x$
in $t_1$, with suitable renaming of variables to prevent free variables
in $t_2$ becoming bound after substitution. The substitution
 $t_1[t_2/x]$ is always defined.
\end{itemize}


\noindent {\small\verb%BETA_CONV (\%}$x${\small\verb%.%}$t_1${\small\verb%)%}$t_2${\small\verb%%} evaluates to the
theorem {\small\verb%|-
(\%}$x${\small\verb%.%}$t_1${\small\verb%)%}$t_2${\small\verb% = %}$t_1[t_2/x]$.
Failure if the argument to \ml{BETA\_CONV} is not a $\beta$-redex (\ie\ is not
of the form {\small\verb%(\%}$x${\small\verb%.%}$t_1${\small\verb%)%}$t_2${\small\verb%%}).

\bigskip

\subsubsection{Substitution}\index{substitution rule, in HOL logic@@substitution rule, in \HOL\ logic!ML function for@@\ML\ function for|(}\index{SUBST@@\ml{SUBST}|(} 

\begin{boxed}
\begin{verbatim}
   val SUBST : (thm * term)list -> term -> thm -> thm
\end{verbatim}\end{boxed}

\begin{center}
\begin{tabular}{c}
$\Gamma_1${\small\verb% |- %} $t_1${\small\verb%=%}$t'_1$ {\small\verb%  %} $\cdots$ {\small\verb%  %}
$\Gamma_n${\small\verb% |- %} $t_n${\small\verb%=%}$t'_n$ {\small\verb%  %} 
$\Gamma${\small\verb% |- %} $t[t_1,\ldots,t_n]$ \\ \hline
$\Gamma_1 \cup \cdots 
\cup \Gamma_n \cup \Gamma${\small\verb% |- %} $t[t'_1,\ldots,t'_n]$ \\
\end{tabular}
\end{center}

\bigskip

\begin{itemize}
\item where $t[t_1,\ldots,t_n]$ denotes a term $t$ with some free 
occurrences of the terms $t_1$, $\dots$, $t_n$ singled out and
$t[t'_1,\ldots,t'_n]$ denotes the result of simultaneously replacing each
such occurrences of $t_i$ by $t'_i$ (for $1{\leq}i {\leq} n$), 
with suitable renaming of variables to prevent free variables
in $t_i'$ becoming bound after substitution.
\end{itemize}

\noindent
The first argument to {\small\verb%SUBST%} is a list
{\small\verb%[(|-%}$t_1${\small\verb%=%}$t'_1${\small\verb%, %}$x_1${\small\verb%);%}$\:\ldots\:${\small\verb%;(|-%}$t_n${\small\verb%=%}
$t'_n${\small\verb%, %}$x_n${\small\verb%)]%}.  The second argument is a
template term $t[x_1,\ldots,x_n]$ in which occurrences of the variable
$x_i$ (where $1 \leq i\leq n$) are used to mark the places where
substitutions with {\small\verb%|- %}$t_i${\small\verb%=%}$t'_i$ are to be
done. Thus

\bigskip

{\small\verb%SUBST [(|-%}$t_1${\small\verb%=%}$t'_1${\small\verb%, %}$x_1${\small\verb%);%}$\ldots${\small\verb%;(|-%}$t_n${\small\verb%=%}
$t'_n${\small\verb%, %}$x_n${\small\verb%)]  %}$t[x_1,\ldots,x_n]${\small\verb%  %}
$\Gamma${\small\verb% |- %}$t[t_1,\ldots,t_n]$

\bigskip 

\noindent returns $\Gamma${\small\verb% |- %}$t[t'_1,\ldots,t'_n]$.
Failure if:
\begin{myenumerate}
\item any of the arguments are of the wrong form;
\item the type of $x_i$ is not equal to the type of $t_i$ for some
$1\leq i\leq n$.
\end{myenumerate}\index{SUBST@@\ml{SUBST}|)}\index{substitution rule, in HOL logic@@substitution rule, in \HOL\ logic!ML function for@@\ML\ function for|)}

\subsubsection{Abstraction}\index{abstraction rule, in HOL logic@@abstraction rule, in \HOL\ logic!ML function for@@\ML\ function for} 
\index{function abstraction, in HOL logic@@function abstraction, in \HOL\ logic!inference rules for}

 
\begin{boxed}\index{ABS@@\ml{ABS}|pin}
\begin{verbatim}
   val ABS : term -> thm -> thm
\end{verbatim}\end{boxed}


\begin{center}
\begin{tabular}{c}
$\Gamma${\small\verb% |- %}$t_1${\small\verb% = %}$t_2$ \\ \hline
$\Gamma${\small\verb% |- (\%}$x${\small\verb%.%}$t_1${\small\verb%) = (\%}$x${\small\verb%.%}$t_2${\small\verb%)%} \\
\end{tabular}
\end{center}

\begin{itemize}
\item where $x$ is not free in $\Gamma$.
\end{itemize}

\noindent 
{\small\verb%ABS %}$x${\small\verb% %}$\Gamma${\small\verb% |- %}$t_1${\small\verb%=%}$t_2$ returns the theorem
$\Gamma${\small\verb% |- (\%}$x${\small\verb%.%}$t_1${\small\verb%) = (\%}$x${\small\verb%.%}$t_2${\small\verb%)%}.
Failure if $x$ is not a variable, or $x$
 occurs free in any assumption in $\Gamma$.


\bigskip

\subsubsection{Type instantiation}\index{type instantiation, in HOL logic@@type instantiation, in \HOL\ logic!ML function for@@\ML\ function for}\index{types, in HOL logic@@types, in \HOL\ logic!instantiation of}

\begin{boxed}\index{INST_TYPE@@\ml{INST\_TYPE}|pin}
\begin{verbatim}
   val INST_TYPE : (type*type) list -> thm -> thm
\end{verbatim}\end{boxed}

\begin{center}
\begin{tabular}{c}
$\Gamma${\small\verb% |- %}$t$ \\ \hline
$\Gamma${\small\verb% |- %}$t[\sigma_1,\ \ldots\ ,\sigma_n/\alpha_1,\ \ldots\ ,\alpha_n]$
\end{tabular}
\end{center}

\bigskip

\begin{itemize}
\item $t[\sigma_1,\ \ldots\ ,\sigma_n/\alpha_1,\ \ldots\ ,\alpha_n]$ 
denotes the result of substituting (in parallel) the types $\sigma_1$,
$\ldots$\ , $\sigma_n$ for the type variables $\alpha_1$, $\ldots$\ ,
$\alpha_n$ in $t$, with the restriction that none of $\alpha_1$, $\ldots$\
, $\alpha_n$ occur in $\Gamma$.
\end{itemize}

\noindent
{\small\verb%INST_TYPE[(%}$\sigma_1${\small\verb%,%}$\alpha_1${\small\verb%);%}$\ldots${\small\verb%;(%}$\sigma_n${\small\verb%,%}$\alpha_n${\small\verb%)] %}$th$
returns the result of instantiating each occurrence of $\alpha_i$ in the
theorem $th$ to $\sigma_i$ (for $1 \leq i \leq n$). Failure if:
\begin{myenumerate}
\item arguments of the wrong form (\eg\ an $\alpha_i$ is not a type variable);
\item $\alpha_i$
(for $1\leq i\leq n$) occurs in any assumption in $\Gamma$.
\end{myenumerate}

\bigskip

\subsubsection{Discharging an assumption}\index{discharging assumptions, in HOL logic@@discharging assumptions, in \HOL\ logic!ML function for@@\ML\ function for} 

 
\begin{boxed}\index{DISCH@@\ml{DISCH}|pin}
\begin{verbatim}
   val DISCH : term -> thm -> thm
\end{verbatim}\end{boxed}

\begin{center}
\begin{tabular}{c}
$\Gamma${\small\verb% |- %} $t_2$ \\ \hline
$\Gamma{-}\{t_1\}${\small\verb% |- %} $t_1${\small\verb% ==> %}$t_2$
\end{tabular}
\end{center}

\begin{itemize}
\item  $\Gamma{-}\{t_1\}$ denotes the set obtained by removing $t_1$ 
from $\Gamma$ (note that $t_1$ need not occur in $\Gamma$; in this case
$\Gamma{-}\{t_1\} = \Gamma$).
\end{itemize}

\noindent
{\small\verb%DISCH %}$t_1${\small\verb% %}$\Gamma${\small\verb% |- %}$t_2$
evaluates to the theorem
$\Gamma{-}\{t_1\}${\small\verb% |- %}$t_1${\small\verb% ==> %}$t_2$.
\ml{DISCH} fails if the term given as its first argument is not of 
type \ml{bool}.



\bigskip

\subsubsection{Modus Ponens}\index{Modus Ponens, in HOL logic@@Modus Ponens, in \HOL\ logic!ML function for@@\ML\ function for} 

 
\begin{boxed}\index{MP@@\ml{MP}|pin}
\begin{verbatim}
   val MP : thm -> thm -> thm
\end{verbatim}\end{boxed}

\begin{center}
\begin{tabular}{c}
$\Gamma_1${\small\verb% |- %}$t_1${\small\verb% ==> %}$t_2$ {\small\verb%     %} $\Gamma_2${\small\verb% |- %}$t_1$ \\
\hline
$\Gamma_1 \cup \Gamma_2${\small\verb% |- %}$t_2$ \\
\end{tabular}
\end{center}

\noindent
{\small\verb%MP%} takes two theorems (in the order shown above) and returns
the result of applying Modus Ponens; it fails if the arguments are not of the
right form.
\index{inference rules, of HOL logic@@inference rules, of \HOL\ logic!primitive|)}



\section{Theories}\index{theories, in HOL logic@@theories, in \HOL\ logic!representation of|(}
\label{theoryfns}

In the formal description of the \HOL\ logic
in Chapter~\ref{logic} a theory is a $4$-tuple

\[ {\cal T}\ =\ \langle{\sf Struc}_{\cal T},\ 
                {\sf Sig}_{\cal T},\ 
                {\sf Axioms}_{\cal T},\ 
                {\sf Theorems}_{\cal T}\rangle \]

\noindent where
\begin{myenumerate}
\item ${\sf Struc}_{\cal T}$ is
the type structure of ${\cal T}$;
\item ${\sf Sig}_{\cal T}$ is 
the signature of ${\cal T}$;
\item ${\sf Axioms}_{\cal T}$ is 
the set of axioms of ${\cal T}$;
\item ${\sf Theorems}_{\cal T}$ is the set of
theorems of ${\cal T}$.
\end{myenumerate}

Such a theory is represented  in the  \HOL\ system  as a  collection of files,
called theory files\index{theory files|(}. 
Various additional pieces of
information are alongside theory files, including the parsing status of the
constants (\ie\ whether they are infixes or binders)
and which axioms are definitions, type
definitions or specifications (see Section~\ref{avra_definitional} for the last
three).

%Theory files are structured hierarchically to represent sequences of
%extensions of an initial theory (see Section~\ref{extensions}) called
%\ml{HOL}\index{HOL@@\ml{HOL}}. Each theory file making up a theory records some types, constants,
%axioms and theorems, together with pointers to other theory files called its
%{\it parents\/}\index{parents, of HOL theories@@parents, of \HOL\ theories}.  The theory represented by such a theory file is obtained by
%taking the union of all the types, constants, axioms and theorems in the file,
%together with the types, constants, axioms and theorems in all the theory
%files reachable by following pointers to parents. This collection of reachable
%files is called the {\it ancestry\/}\index{ancestry, of HOL system theories@@ancestry, of \HOL\ system theories}\index{theories, in HOL logic@@theories, in \HOL\ logic!hierarchies of}
%of the theory file. Axioms (including
%definitions and specifications) and theorems are named in the \HOL\ system by
%two strings: the name of the theory file in which they are stored, together with
%a name supplied by the user\index{theory files|)}.

The data stored in a single theory file is called a {\it theory segment\/}\index{theory segments};
this is not really a logical concept, but rather a concept of the
representation of theories in the \HOL\ system. It is necessary to distinguish
theories from their constituent theory segments  because the naming of data
in theories is based on the names given to segments.  Specifically, axioms,
definitions, specifications and theorems are named\index{theories, in HOL logic@@theories, in \HOL\ logic!naming of}
 by a pair of strings
$\langle thy,name \rangle$,
where $thy$ is the name of the theory segment current when the
item was declared and $name$ is a specific name supplied by the user (see the
functions \ml{new\_open\_axiom}, \ml{new\_definition}, below). Different items
can have the same specific name if the associated segment is different.

\subsection{Theories and Scripts for Theories}

A typical\index{HOL system@@\HOL\ system!typical work in} piece of work 
with the \HOL\ system takes place over a number of
sessions\index{sessions with HOL system@@sessions, with \HOL\ system}.
Typically this involves a migration
from using one `scratch' theory segement to the eventual construction
of stable, completed theories on which future work can be based.

\index{theories!theory scripts}
\index{scripts!for theories}
From the user's perspective, the most important result
of a session with \HOL\ is the user's personal 
record of his or her work.  This will normally be organised 
as a set of \ML\ {\it scripts}, one for each theory which
has been developed.  These must be capable of reperforming the logical
definitions and proofs which the user has performed to construct
that theory.
The naming convention adopted for such a script 
by most \HOL\ users, and by the
\HOL\ system itself is \ml{mk\_}${\cal T}$\ml{.sml}.

After a theory has been constructed, it may be reused efficiently
and quickly by later \HOL\ sessions.  This is done by storing
a theory segment in two files on disk:
\begin{itemize}
    \item A theory signature file ${\cal T}$\ml{.holsig} whose contents
    are the new constants and type constants introduced by the
    user while working with the new theory, and whose
    ancestry is the theories used during the course of the session.
    \item A theorem database ${\cal T}$\ml{.thms} whose contents
    are the axioms, definitions and saved theorems for the theory.
\end{itemize}

For completed, stable theories, \HOL\ can be seen as ``compiler'' which
takes theory scripts as input (e.g. \ml{mk\_btree.sml}) and produces
disk representations of these theories\footnote{Indeed users
frequently write Makefiles which use \HOL\ in batch mode, and this
is how the core theories in \HOL\ are built.}.  
Thus, the completed script for a theory must be capable of recreating
the ${\cal T}$\ml{.holsig} and ${\cal T}$\ml{.thms} files for
the theory.  In this mode of use, the purpose of the
disk representations is two-fold:
\begin{myenumerate}
   \item To allow stable theories to be brought back into a 
   \HOL\ session quickly and without the need to re-execute proofs.
   \item To act as a kind of cache where large numbers of theorems
   can be available to the user in disk databases, but only
   those which are actually used are loaded into memory.\footnote{In
   the present implementation, all the theorems from a theory segment are
   loaded into memory when one theorem in the theory is accessed}.
\end{myenumerate}
Lastly, disk representations of theories allow the resources of
two compatible theories to be brought into the one \HOL\ session -
a kind of merging operation.  This is usually done by:
\begin{myenumerate}
   \item Creating the two theories by the normal process.  This
   will probably involve running \HOL\ twice.
   \item Creating a third theory, and then calling \ml{new\_parent}
   for each of the theories we wish to merge.  Consistency
   is ensured since the \ml{new\_parent} operation is only allowed
   if the theory being added is consistent with the current
   \HOL\ session.
\end{myenumerate}
The \ML\ function \ml{new\_parent} is described in more detail below.

There is always a {\it current theory\/} which is the theory represented by
the current theory segment together with its ancestry. The name of the current
theory is returned by the \ML\ function:

\begin{boxed}\index{current_theory@@\ml{current\_theory}|pin}
\begin{verbatim}
   val current_theory : unit -> string
\end{verbatim}\end{boxed}

\subsection{Draft and Proof Mode}

There are two modes of working with \HOL: {\it draft mode\/}\index{draft mode, in HOL system@@draft mode, in \HOL\ system} and {\it proof
mode\/}\index{proof mode, in HOL system@@proof mode, in \HOL\ system}.
In the former, the sets ${\sf Struc}_{\cal T}$, ${\sf Sig}_{\cal T}$
and ${\sf Axioms}_{\cal T}$ can be extended; in the latter only ${\sf
Theorems}_{\cal T}$ can be changed. In draft mode, inconsistencies can be
introduced by asserting inconsistent axioms, but in proof mode only
consistency-preserving actions (namely valid proof) can be evaluated. Draft mode is
analogous to "super user mode' in Unix, in that it gives access to `dangerous'
facilities. Everything that can be done in proof mode can be done in draft
mode, but not vice versa\footnote{The distinction between draft and
proof mode turns out to be of little use in practice, and so will
be removed in a future version of \HOL}.

Initially \HOL\ is in proof mode with current
theory called \ml{HOL}, which is described in Section~\ref{HOL-theory}\index{theories, in HOL logic@@theories, in \HOL\ logic!representation of|)}.

\subsection{Primitive ML functions for managing theories}
\label{theoryprims}

The \ML\ functions for creating theories\index{theories, in HOL logic@@theories, in \HOL\ logic!creation of|(} are listed below.

\begin{boxed}
\index{new_theory@@\ml{new\_theory}|pin}
\begin{verbatim}
   val new_theory : string -> unit
\end{verbatim}\end{boxed}

\noindent \ml{new\_theory "$thy$"} can be done in both
proof\index{proof mode, in HOL system@@proof mode, in \HOL\ system} and
draft\index{draft mode, in HOL system@@draft mode, in \HOL\ system} modes. It
switches into draft mode for a new theory with name $thy$.
The current theory becomes a new parent of $thy$.
%and it fails if
%there already exists a file $thy$\ml{.th} in the current search path. 


\begin{boxed}
\index{new_parent@@\ml{new\_parent}|pin}
\begin{verbatim}
   val new_parent : string -> unit
\end{verbatim}\end{boxed}


\noindent Executing \ml{new\_parent}\ $thy$ makes $thy$ into
a parent
of the current theory. Failure occurs if:
\begin{myenumerate}
\item not in draft mode;
\item $thy$ is not a theory on the current search path;
\item there is a type in $thy$ with the same
name as a type in the current theory;
\item there is a constant in $thy$ with the same
name as a constant in the current theory.
\end{myenumerate}
Calling \ml{new\_parent} effectively merges a previously derived
theory signature into the current theory - it is the only mechanism presently 
available for performing such an operation.

\begin{boxed}
\index{load_theory@@\ml{new\_parent}|pin}
\begin{verbatim}
   val load_theory : string -> unit
\end{verbatim}\end{boxed}


\noindent Executing \ml{load\_theory}\ $thy$ makes $thy$ the
current theory. Failure occurs if:
\begin{myenumerate}
\item $thy$ is not a theory on the current search path;
\item the current theory is an ancestor of the theory
being loaded;
\item the current theory has changed in any way since the
time when the theory being loaded was created as an extension
of it.  
\end{myenumerate}
The last restriction means that no new theories, axioms, or definitions 
can have been made in a \HOL\ session from which \ml{load\_theory} is
executed.  It follows that the only real (but important)
use for \ml{load\_theory} is to help set up the initial state
of a \HOL\ session by making a previously constructed theory the
focus of the current session.


The following function is used to switch from draft mode
to proof mode\index{draft mode, in HOL system@@draft mode, in \HOL\ system}.

\begin{boxed}
\index{close_theory@@\ml{close\_theory}|pin}
\begin{verbatim}
   close_theory : unit -> unit
\end{verbatim}\end{boxed}

The following function is used to save the current theory segment to 
a theory file on disk.
\begin{boxed}
\index{export_theory@@\ml{export\_theory}|pin}
\begin{verbatim}
   export_theory : unit -> unit
\end{verbatim}\end{boxed}
\noindent {\bf Warning:} quitting \HOL\ without\index{exiting of HOL system@@exiting of \HOL\ system} closing the session with
\ml{export\_theory} may result in the theory segment created during the session
being lost (\ie\ not saved in a theory file)!\index{theories, in HOL logic@@theories, in \HOL\ logic!creation of|)}.
Note exiting via the function \ml{exit()} automatically calls \ml{export\_theory}.

\subsection{New axioms}

\begin{boxed}
\index{new_open_axiom@@\ml{new\_open\_axiom}|pin}
\begin{verbatim}
   new_open_axiom : (string * term) -> thm
\end{verbatim}\end{boxed}


\noindent Executing \ml{new\_open\_axiom("}$name$\ml{",}$t$\ml{)} declares the 
sequent
\ml{(\{\},$t$)} to be an axiom\index{axioms!declaration of, in HOL logic@@declaration of, in \HOL\ logic} of the current theory with name $name$. 
Failure if:
\begin{myenumerate}
\item not in draft mode;
\item there is already an axiom, definition or specification 
named $name$ in the current theory segment.
\end{myenumerate}

\subsection{Saving theorems to theories}

Once a theorem has been proved, it can be saved with the function

\begin{boxed}
\index{save_thm@@\ml{save\_thm}|pin}
\begin{verbatim}
   save_thm : (string * thm) -> thm
\end{verbatim}\end{boxed}

\noindent
Evaluating \ml{save\_thm("}$name$\ml{",}$th$\ml{)} will save the theorem\index{theorems, in HOL logic@@theorems, in \HOL\ logic!saving of}\index{saving theorems}
$th$ with name $name$ in the current theory segment.


\index{theories, in HOL logic@@theories, in \HOL\ logic!functions for accessing|(}
\index{axioms!retrieval of, in HOL system@@retrieval of, in \HOL\ system|(}
The arguments of \ML\ type {\small\verb%string%} to {\small\verb%new_axiom%},
{\small\verb%save_thm%}
\etc\ are the names of the corresponding axioms and definitions. These
names are used when accessing theories with the functions
{\small\verb%axiom%}, {\small\verb%definition%}, \etc, described below.


\subsection{Introducing uninterpreted types and constants}

The following function introduce {\em uniterpreted} types and constants -
i.e. types and constants which are ascribed no special meaning.  There
are two main reasons for using these functions:
\begin{myenumerate}
   \item when prototyping a theory and
   the meaning of constructs is
   not so important, and \HOL\ is simply being used to explore
   the theory signature and concrete syntax for the theory;
   \item in situations where the constants and types will be ascribed
   a meaning by the use of \ml{new\_open\_axiom} at a later date.  For
   instance, these functions are used to specify the initial three
   constants of the core \HOL\ logic.
\end{myenumerate}   

\begin{boxed}
\index{new_type@@\ml{new\_type}|pin}
\index{new_constant@@\ml{new\_constant}|pin}
\begin{verbatim}
   val new_type : {Name : string, Arity : int}
   val new_constant : {Name:string,Ty:typ} -> unit
\end{verbatim}\end{boxed}


\noindent Executing \ml{new\_type\{Name="\ty{op}",Arity=$n$\}}
makes \ty{op} a new $n$-ary type operator
\index{type operators, in HOL logic@@type operators, in \HOL\ logic!declaration} in the current theory.
Failure occurs if:
\begin{myenumerate}
\item not in draft mode;
\item there already exists a type operator named \ty{op} in the current
theory.
\end{myenumerate}

\noindent Executing \ml{new\_constant\{Name="$c$",Ty=$\sigma$ \}} makes
$c_{\sigma'}$ a new constant\index{constants, in HOL logic@@constants, in \HOL\ logic!declaration of} of the current theory,
for all $c_{\sigma'}$ where $\sigma'$ is an instance of $\sigma$.
The type $\sigma$ is
called the {\it generic type\/}\index{generic types, in HOL logic@@generic types, in \HOL\ logic} of $c$. Failure if:
\begin{myenumerate}
\item not in draft mode;
\item there already exists a constant named $c$ in the current
theory.
\end{myenumerate}

\noindent Parsing and fixity information for
uniterpreted constants can be introduced by the
functions described in Section~\ref{fixities}.
%\begin{boxed}
%\index{new_infix@@\ml{new\_infix}|pin}
%\begin{verbatim}
%   new_infix : {Name:string, Prec:int, Ty:typ} -> unit
%\end{verbatim}\end{boxed}
%
%
%\noindent Executing
%\ml{new\_infix\{Name="}$ix$\ml{",Ty=}$\sigma$\ml{,Prec=}$p$\ml{\}}
%declares $ix$ to be a new constant with generic type $\sigma$ and
%infix status, with precedence $p$.
%Failure if:
%\begin{myenumerate}
%\item not in draft mode;
%\item there already exists a constant named $ix$ in the current theory;
%\item $\sigma$ not of the form \ml{$\sigma_1$->$\sigma_2$->$\sigma_3$}.
%\end{myenumerate}
%
%
%\begin{boxed}
%\index{new_binder@@\ml{new\_binder}|pin}
%\begin{verbatim}
%   new_binder : {Name: string,Ty: type} -> unit
%\end{verbatim}\end{boxed}
%
%
%\noindent Executing \ml{new\_binder\{Name="}$b$\ml{",Ty=}$\sigma$\ml{\}}\index{binders, in HOL logic@@binders, in \HOL\ logic!declaration of}
%declares $b$ to be a new constant with generic type $\sigma$ and 
%binder status.
%Failure if:
%\begin{myenumerate}
%\item not in draft mode;
%\item there already exists a constant named $b$ in the current theory;
%\item $\sigma$ not of the form \ml{($\sigma_1$->$\sigma_2$)->$\sigma_3$}.
%\end{myenumerate}


%A theory with no descendants\index{theories, in HOL logic@@theories, in \HOL\ logic!hierarchies of}
%can be extended by adding new parents, types,
%constants, axioms and definitions. Theories that are already the parents of
%other theories cannot be extended in this way.\footnote{It 
%would be difficult
%to implement the necessary checks to ensure that added types,
%constants \etc\ did not invalidate declarations in the descendant theories.}
%When a new theory is being created or an existing one extended it is necessary
%to be in draft mode.\index{draft mode, in HOL system@@draft mode, in \HOL\ system}
%In proof mode\index{proof mode, in HOL system@@proof mode, in \HOL\ system} the
%functions with prefix `{\small\verb%new_%}'\index{new_@@\ml{new\_}$\ldots$}
%listed above are not available.  


\subsection{Accessing theories}


There are various functions for loading the contents of theory files:

\begin{boxed}
\index{parents@@\ml{parents}|pin}
\index{types@@\ml{types}|pin}
\index{constants@@\ml{constants}|pin}
\index{infixes@@\ml{infixes}|pin}
\index{binders@@\ml{binders}|pin}
\index{axioms@@\ml{axioms}|pin}
\index{definitions@@\ml{definitions}|pin}
\index{theorems@@\ml{theorems}|pin}
\begin{verbatim}
   parents     : string -> string list
   types       : string -> (int * string) list
   constants   : string -> term list
   infixes     : string -> term list
   binders     : string -> term list
   axioms      : string -> (string * thm) list
   definitions : string -> (string * thm) list
   theorems    : string -> (string * thm) list
\end{verbatim}\end{boxed}

\noindent The first argument is the name of a theory (which must be in the
ancestry of the current theory segment); the result is a list of the
components of the theory. The name of the current theory can be abbreviated by
\ml{"-"}.\index{ abbreviation, of HOL theory part names@@\ml{-}
(abbreviation, of \HOL\ theory part names)} For example, \ml{parents "-"} returns the parents of the current
theory.

In the case of \ml{types} a list of arity-name pairs is returned; in the
case of  \ml{axioms}, \ml{definitions} or \ml{theorems} a list 
of string-theorem
pairs is returned, where the string is the name of the theorem representing the
axiom, definition or theorem that was supplied by the user. Note that constant
specifications and type definitions are both retrieved using the function
\ml{definitions}.



Individual axioms, definitions and theorems can be read (from the current or
ancestor theories) using the following \ML\ functions:



\begin{boxed}
\index{axiom@@\ml{axiom}|pin}
\index{definition@@\ml{definition}|pin}
\index{theorem@@\ml{theorem}|pin}
\begin{verbatim}
   axiom      : string -> string -> thm
   definition : string -> string -> thm
   theorem    : string -> string -> thm
\end{verbatim}\end{boxed}

\noindent The  first  argument  is  the  theory (\ml{"-"}  can be  used for the
current theory); the second argument is  the user  supplied name  of the axiom,
definition or theorem in the theory.

Theories can be printed using the function
{\small\verb%print_theory%}\index{printing, in HOL logic@@printing, in \HOL\ logic!of theories}\index{print_theory@@\ml{print\_theory}}, 
which takes a theory name and then
prints out the named theory in a readable format.\index{axioms!retrieval of, in HOL system@@retrieval of, in \HOL\ system|)}\index{theories, in HOL logic@@theories, in \HOL\ logic!functions for accessing|)}


\subsection{Finding theorems}

The special function \ml{THM} is defined to look through all
available theories for a theorem of a particular name:
\begin{boxed}
\index{THM@@\ml{THM}|pin}
\begin{verbatim}
   THM      : string -> thm
\end{verbatim}\end{boxed}
%Sometimes it is useful to add extra `theorem databases' to the list
%of theorems which will be searched.  In particular, there are theorems which
%get proved but never saved into theories, but are instead kept
%bound to some top level identifier.  

\section{Definitional extensions}\index{extension, of HOL logic@@extension, of \HOL\ logic!definitional}\index{definitional extension, of HOL logic@@definitional extension, of \HOL\ logic}\index{theories, in HOL logic@@theories, in \HOL\ logic!extension of|(}
\label{avra_definitional}
\label{theory-extension}

This section describes the primitve mechanisms in the \HOL\
system for creating definitional extensions of theories.  These
functions play a central role in the \HOL\ system.  It has already
been shown in Section~\ref{semantics} that the mechanisms implemented
here are conservative, in the sense that they preserve the consistency
of the \HOL\ logic.  In addition, powerful definitional mechanisms
can be implemented in terms of the primitives described here, with
the assurance that such mechanisms will also be ``safe''.

There are three kinds of primitive definitional extensions:
constant definitions, constant specifications and type definitions.
It should be noted that these mechanisms are merely the {\em primitives}
available in the \HOL\ system - several more convenient tools
have been implemented in terms of them, and are available either
in the core system or in \HOL\ libraries (see Section~\ref{types-package}).

\subsection{Constant definitions}

\index{constant definition extension, of HOL logic@@constant definition extension, of \HOL\ logic!ML function for@@\ML\ function for|)}
In Section~\ref{defs} a constant definition\index{extension, of HOL logic@@extension, of \HOL\ logic!by constant definition}\index{constant definition extension, of HOL logic@@constant definition extension, of \HOL\ logic!ML function for@@\ML\ function for|(}
over a signature $\Sigma_{\Omega}$ is defined to be
an equation, \ie\ a formula of the form $c_{\sigma}=t_{\sigma}$,
such that:
\begin{myenumerate}
\item $c$ is not the name of any constant in $\Sigma_{\Omega}$;
\item $t_{\sigma}$ is a closed term in ${\sf Terms}_{\Sigma_{\Omega}}$;
\item all the type variables occurring in $t_{\sigma}$ occur in $\sigma$.
\end{myenumerate}

In \HOL, definitions can be slightly more general than this, in that
an equation:

\[ c\ v_1\ \cdots\ v_n\ =\ t \]

\noindent is  allowed  to  be a  definition where  $v_1$, $\dots$, $v_n$ are
variable structures (\ie\ tuples of distinct variables).   Such  an equation is
logically equivalent to:

\[ c\ =\ \lambda v_1\ \cdots\ v_n.\  t \]

\noindent which is a definition in the sense of  Section~\ref{defs} if (i),
(ii) and (iii) hold.  

The following  \ML\ function  creates\index{defining mechanisms, for HOL logic@@defining mechanisms, for \HOL\ logic} a  new definition in
the current theory.

\begin{boxed}
\index{new_definition@@\ml{new\_definition}|pin}
\begin{verbatim}
   new_definition : (string * term) -> thm
\end{verbatim}\end{boxed}


\noindent Evaluating
 \ml{new\_definition("}$name$\ml{",\ (--`}$c\ v_1\ \cdots\ v_n\ =\ t$\ml{`--))},
where $c$ is not already a constant, declares the sequent
\ml{(\{\},$\lambda v_1\ \cdots\ v_n.\  t$)} to be a constant definition\index{definitions, adding to HOL logic@@definitions, adding to \HOL\ logic} 
of the current theory. The name associated with the definition in
this theory is $name$. 
Failure if:
\begin{myenumerate}
\item not in draft mode;
\item there is already an axiom, definition or specification 
named $name$ in the current theory segment;
\item $c$ is already a constant in the current theory;
\item $t$ contains free variables that are not in any of
the variable structures $v_1$, $\dots$, $v_n$ (this is equivalent
to requiring $\lambda v_1\ \cdots\ v_n.\  t$ to be a closed term);
\item there is a type variable in  $v_1$, $\dots$, $v_n$ or $t$
that does not occur in the type of $c$.
\end{myenumerate}

\noindent Parsing and fixity information for
the constant can be introduced before or after its definition by
functions described in Section~\ref{fixities}.

%The following two functions declare new constants that have infix\index{infixes, in HOL logic@@infixes, in \HOL\ logic!declaration of}\index{infixes, in HOL logic@@infixes, in \HOL\ logic} or binder
%status. The failure conditions are the same as for \ml{new\_definition}, 
%with the
%additional conditions that the constants being declared must be types of
%the appropriate form (\ml{$\sigma_1$->$\sigma_2$->$\sigma_3$} for infixes and
%\ml{($\sigma_1$->$\sigma_2$)->$\sigma_3$} for binders).
%
%
%\begin{boxed}
%\index{new_infix_definition@@\ml{new\_infix\_definition}|pin}
%\index{new_binder_definition@@\ml{new\_binder\_definition}|pin}
%\begin{verbatim}
%   new_infix_definition  : (string * term * int) -> thm
%   new_binder_definition : (string * term) -> thm
%\end{verbatim}\end{boxed}
%
%\noindent Note that until an infix or binder declaration has been processed the
%constant being defined will not have its special status.\index{parsing, of HOL logic@@parsing, of \HOL\ logic!of constants, before definition} It is therefore
%necessary to use
%the constant in normal prefix position when making the definition\index{defining mechanisms, for HOL logic@@defining mechanisms, for \HOL\ logic}. For example,
%
%\begin{hol}
%{\small\verb%   new_infix_definition("%}$ix${\small\verb%_DEF", (--`%}$m$% $ix$ $n${\small\verb% = ... `--),$prec$)%}
%\end{hol}
%
%\noindent will not work, as at the time when the quotation is parsed, \ml{ix}
%does not have infix status and hence \ml{m ix n} will parse with \ml{m} as the
%function. The definition must thus have the form:
%
%\begin{hol}
%{\small\verb%   new_infix_definition("%}$ix${\small\verb%_DEF", (--`%}$ix$ $m$ $n${\small\verb% = ... `--))%}
%\end{hol}
%
%\noindent Only after this has been processed will $ix$ be an infix. It is a
%common practice among \HOL\ users to write a {\small\verb%$%}\index{ escape, in HOL logic parser@@{\small\verb+$+} (escape, in \HOL\ logic parser)}\index{declared constants, in HOL logic@@declared constants, in \HOL\ logic}
%before
%the constant being defined as an infix or binder
%to indicate that after the definition is made, it will have a special
%syntactic status; \ie\ to write:
%
%\begin{hol}
%{\small\verb%   new_infix_definition("%}$ix${\small\verb%_DEF", (--`$%}$ix$ $m$ $n${\small\verb% = ... `--))%}
%\end{hol}
%
%\noindent and similarly with \ml{new\_binder\_definition}. This use of
%{\small\verb%$%} is not necessary; but after the definition has been
%made {\small\verb%$%} must, of course, 
% be used if the syntactic status needs to be suppressed.

\subsection{Constant specifications}
\label{conspec}
\label{constant-specification}

\index{specification of constants, in HOL logic@@specification of constants, in \HOL\ logic|(}
\index{extension, of HOL logic@@extension, of \HOL\ logic!by constant specification}
In Section~\ref{specs} a constant specification\index{constant specification extension, of HOL logic@@constant specification extension, of \HOL\ logic!ML function for@@\ML\ function for} for a theory ${\cal T}$
is defined to be a pair:

\[ \langle(c_1,\ldots,c_n),\ \lquant{{x_1}_{\sigma_1}
\cdots {x_n}_{\sigma_n}}t_{\ty{bool}}\rangle \]

\noindent such that:

\begin{myenumerate}
\item $c_1$, $\dots$, $c_n$ are distinct names that
are not the names of any constants in ${\sf Sig}_{\cal T}$.
\item $\lquant{{x_1}_{\sigma_1}
\cdots {x_n}_{\sigma_n}}t_{\ty{bool}}\ \in\ {\sf Terms}_{\cal T}$.
\item $tyvars(\lquant{{x_1}_{\sigma_1}
\cdots {x_n}_{\sigma_n}}t_{\ty{bool}})\ \subseteq\ tyvars(\sigma_i)$ for
$1\leq i\leq n$.
\item $\equant{{x_1}_{\sigma_1}\ \cdots\ {x_n}_{\sigma_n}}t
\ \in\ {\sf Theorems}_{\cal T}$.
\end{myenumerate}

The following \ML\ function is used to make constant specifications in
the \HOL\ system.

\begin{boxed}
\index{new_specification@@\ml{new\_specification}|pin}
\begin{verbatim}
   new_specification : (string * string list * thm) -> thm
\end{verbatim}\end{boxed}
\begin{aside}
The version of \ml{new\_specification} documented here
is yet to be implemented.  The
version in the current system requires extra fixity information as
an argument.  In future versions it may be possible to specify fixity
information more flexibly, as well as to increase the syntactic
devices that may be employed in the interface.
\end{aside}

Evaluating:
\begin{hol}
   \ml{new\_specification($name$,[$c_1$,$\ldots$,$c_n$],|- ?$x_1\cdots x_n$.\  $t$[$x_1$,$\ldots$,$x_n$])}
\end{hol}
\noindent simultaneously  introduces  new constants  named $c_1$, $\dots$,
$c_n$ satisfying the property:


\[ \ml{|- }t\ml{[}c_1\ml{,}\ \ldots\ \ml{,}c_n\ml{]} \]


\noindent theorem is stored,
with name $name$, as a definition in the current theory segment. A call to
\ml{new\_specification} fails if:

\begin{myenumerate}
\item not in draft mode;
\item there is already an axiom, definition or specification 
named $name$ in the current theory segment;
\item the theorem argument has a non-empty assumption list;
\item there are free variables in the theorem argument;
\item $c_1$, $\dots$, $c_n$ are not distinct variables;
\item some $c_i$ is already a constant in the current theory;
\item some $c_i$ is not an allowed name for a constant;
\item the type of some $c_i$ does not contain all the type
variables which occur in the term
{\small\verb%\%}
$x_1\ \cdots\ x_n$\ml{.}\  $t$\ml{[}$x_1$\ml{,}$\ \ldots$\ml{,}$x_n$\ml{]}.
\end{myenumerate}


\noindent Parsing and fixity information for
the constant can be introduced before or after its definition by
functions described in Section~\ref{fixities}.


\subsection{Type definitions}\index{extension, of HOL logic@@extension, of \HOL\ logic!by type definition|(}
\label{type-defs}\index{type definitions, in HOL logic@@type definitions, in \HOL\ logic|(}

In the \HOL\  system, new types and type operators can 
be introduced\index{extension, of HOL logic@@extension, of \HOL\ logic}
using the  consistency-preserving definitional  mechanism  of  
type  definitions\index{type definition extension, in HOL logic@@type
definition extension, in \HOL\ logic|(} (see Sections~\ref{tydefs}).
The primitive \ML\ rule for introducing a new type is:

\begin{boxed}
\index{new_type_definition@@\ml{new\_type\_definition}}
\begin{verbatim}
   val new_type_definition : {name: string, pred: term, inhab_thm: thm} -> thm
\end{verbatim}\end{boxed}

\noindent This rule allows
axioms of a restricted form to be added to the primitive basis of the logic.
These axioms are analogous to definitional axioms for new constants: they
define new types in terms of other type expressions already present in the
logic. Like the rule \ml{new\_definition} for making constant definitions, 
the rule  \ml{new\_type\_definition}
 for type definitions
ensures that adding a new syntactic entity (in this case, a type or 
type operator) is a conservative extension of the logic. 

The basic idea behind \ml{new\_type\_definition} is  that a  type definition is
made by  adding an  axiom to  the logic  which asserts  that the  set of values
denoted by a  new type  is isomorphic\index{isomorphism of types, in HOL logic@@isomorphism of types, in \HOL\ logic}  to an  appropriate subset  of the values
denoted by  a type  expression already  present in  the logic.   A definitional
axiom\index{definitional axioms} of this form merely states  
that a  new type  is isomorphic  to a particular
subset of an existing type.  From such type definition  axioms, it  is usual to
prove theorems that characterize newly-defined types more abstractly.  The idea
is to prove a collection of theorems that state  the essential  properties of a
new type without reference to how it is defined.   These  theorems then
constitute a derived `abstract axiomatization' of the new type, and 
once  they have  been proved they
become the basis for all further reasoning about it.  

With this approach, introducing a new type (or type operator) in \HOL\
involves two distinct steps:

\setcounter{myenumi}{1}
\begin{list}{\arabic{myenumi}.}{\usecounter{myenumi}
\setlength{\leftmargin}{10mm}
\setlength{\rightmargin}{5mm}
\setlength{\labelwidth}{3mm}
\setlength{\labelsep}{2mm}
\setlength{\listparindent}{0mm}
\setlength{\itemsep}{8pt plus1pt minus2pt}
\setlength{\topsep}{3mm}
\setlength{\parsep}{0mm}}
\setlength{\abovedisplayshortskip}{8pt plus1pt minus1pt} 
\setlength{\belowdisplayshortskip}{8pt plus1pt minus1pt}

\item Finding an appropriate representation for the new type, and making a type \mbox{definition} using \ml{new\_type\_definition} based
 on this representation.

\item Using the axiomatic definition of the new type and the properties of its
representation to prove a set of theorems that abstractly characterizes it.

\end{list}

In Section~\ref{tydefs} it is explained that
defining\index{type definitions, in HOL logic@@type definitions, in \HOL\ logic!introduction of}\index{type definition extension, in HOL logic@@type definition extension, in \HOL\ logic!ML function for@@\ML\ function for|(}
a new type $(\alpha_1,\ldots,\alpha_n)\ty{op}$ in a theory ${\cal T}$ consists
of introducing $\ty{op}$ as a new $n$-ary type operator and 

\[\turn \equant{f_{(\alpha_1,\ldots,\alpha_n)\ty{op}\fun\sigma}}\TyDef\ p\ f\]

\noindent as a new axiom, where $p$ is a predicate
characterizing\index{characteristic predicate, of type definitions} a
non-empty subset of an existing type $\sigma$.  Formally, a type definition
for a theory ${\cal T}$ is a $3$-tuple 

\[ \langle \sigma,\ (\alpha_1,\ldots,\alpha_n)\ty{op},
    \ p_{\sigma\fun\ty{bool}}\rangle \]

\noindent where:

\begin{myenumerate}
\item $\sigma\in{\sf Types}_{\cal T}$  and
$tyvars(\sigma)\in\{\alpha_1, \ldots , \alpha_n\}$.
\item \ty{op} is not the name of a type constant in ${\sf Struc}_{\cal T}$.
\item $p\in{\sf Terms}_{\cal T}$ is a closed term of
type $\sigma\fun\ty{bool}$  and
$tyvars(p)\subseteq\{\alpha_1, \ldots , \alpha_n\}$.
\item $\equant{x_{\sigma}}p\ x \ \subseteq\ {\sf Theorems}_{\cal T}$.
\end{myenumerate}

%The following \ML\ function makes a type definition in the \HOL\ system.
%
%\begin{boxed}
%\index{new_type_definition@@\ml{new\_type\_definition}|pin}
%\begin{verbatim}
%   val new_type_definition : 
%            {name: string, pred: term, inhab_thm: thm} -> thm
%\end{verbatim}\end{boxed}
%
\noindent If $t$ is a term of type
$\sigma$\ml{->bool} containing $n$ distinct type variables, then
evaluating:

{\def\op{{\normalsize\sl op}}
\begin{hol}\begin{alltt}
   new_type_definition\{Name="{\op}", pred=\m{t}, inhab_thm=|- ?\m{x}.\m{\:t\;x}\}
\end{alltt}\end{hol}

\noindent results in \ty{op} being declared as a new $n$-ary type operator
characterized by the definitional\index{definitional axioms}\index{type operators, in HOL logic@@type operators, in \HOL\ logic!definitional axioms for} axiom:

\begin{hol}\begin{alltt}
   |- ?rep. TYPE\_DEFINITION \m{t} rep
\end{alltt}\end{hol}

\noindent which is stored as a definition with the automatically 
generated name
\ty{op}\ml{\_TY\_DEF}.\index{TY_DEF@@$\ldots$\ml{\_TY\_DEF}}\footnote{In 
previous versions of HOL, type definitions 
were stored as axioms rather than definitions.} The constant 
\ml{TYPE\_DEFINITION}\index{TYPE_DEFINITION@@\ml{TYPE\_DEFINITION}} 
is defined in the theory \ml{bool} by:

\begin{hol}\begin{verbatim}
   |- TYPE_DEFINITION (P:'a->bool) (rep:'b->'a) =
       (!x' x''. (rep x' = rep x'') ==> (x' = x'')) /\	
       (!x. P x = (?x'. x = rep x'))
\end{verbatim}\end{hol}

\noindent Executing \ml{new\_type\_definition("\ty{op}",\ }$t$\ml{,\ 
|- ?}$x$\ml{.}\ $t\ x$\ml{)} fails if:
\begin{myenumerate}
\item not in draft mode;
\item $\ty{op}$ is already the name of a type or type operator 
in the current theory;
\item there already exists a constant definition, constant specification,
type definition or axiom named  \ty{op}\ml{\_TY\_DEF} in the current theory; 
\item $t$ does not have a type of the form $\sigma$\ml{->bool}.
\end{myenumerate}
\index{extension, of HOL logic@@extension, of \HOL\ logic!by type definition|)}
\index{theories, in HOL logic@@theories, in \HOL\ logic!extension of|)}\index{type definition extension, in HOL logic@@type definition extension, in \HOL\ logic!ML function for@@\ML\ function for|)}\index{type definitions, in HOL logic@@type definitions, in \HOL\ logic|)}

\subsubsection{Defining bijections}
\index{type definitions, in HOL logic@@type definitions, in \HOL\ logic!defining bijections for|(}

The result of a type definition using \ml{new\_type\_definition} is a theorem
which asserts only the {\it existence\/} of a
bijection\index{bijection of types, in HOL logic@@bijection of types, in \HOL\ logic} 
from the type it defines to the corresponding subset of an existing type.  To
introduce constants that in fact denote such a bijection and its inverse, the
following \ML\ function is provided:

\begin{boxed}
\index{define_new_type_bijections@@\ml{define\_new\_type\_bijections}|pin}
\begin{verbatim}
   define_new_type_bijections : string -> string -> string -> thm -> thm
\end{verbatim}\end{boxed}

\noindent This function takes three string arguments and a theorem argument.
The theorem argument must be a definitional axiom of the form returned by
\ml{new\_type\_definition}.  The first string argument is the name under which
the constant definition (a constant specification, in fact) made by
{\small\verb!define_new_type_bijections!} will be stored in the current theory
segment, and the second and third string arguments are user-specified names for
the two constants that are to be defined. These constants are defined so as to
denote mutually inverse bijections between the defined type, whose definition
is given by the supplied theorem, and the representing type of this defined
type.

Evaluating:

\medskip
{\def\op{{\normalsize\sl op}}
\begin{hol}\begin{alltt}
   define\_new\_type\_bijections "\m{name}" "\m{abs}" "\m{rep}" 
           |- ?rep:newty->ty. TYPE\_DEFINITION \m{P} rep
\end{alltt}\end{hol}}

\medskip

\noindent automatically defines two new constants
\m{abs}{\small\verb!:ty->newty!} and \m{rep}{\small\verb!:ty->newty!} 
such that:

{\def\bk{\char'134}
\begin{hol}\begin{alltt}
   |- (!a. \m{abs}(\m{rep} a) = a) /\bk (!r. \m{P} r = (\m{rep}(\m{abs} r) = r))
\end{alltt}\end{hol}}

\noindent This theorem, which is the defining property for the constants
\m{abs} and \m{rep}, is stored under the name "\m{name}" in the current theory
segment.  It is also the value returned by \ml{define\_new\_type\_bijections}.
The theorem states that \m{abs} is the left inverse of \m{rep} and---for
values satisfying \m{P}---that \m{rep} is the left inverse of \m{abs}.

A call to 
\ml{define\_new\_type\_bijections \m{name} \m{abs} \m{rep} \m{th}}
fails if:

\begin{myenumerate}
\item not in draft mode;
\item either $abs$ or $rep$ is already the name of a constant in
the current theory;
\item there already exists a constant definition, constant specification,
type definition or axiom named  \m{name} in the current theory; 
\item $th$ is not a theorem of the form returned by
\ml{new\_type\_definition}.
\end{myenumerate}%
\index{type definitions, in HOL logic@@type definitions, in \HOL\ logic!defining bijections for|)}

\subsubsection{Properties of type bijections}
\index{type definitions, in HOL logic@@type definitions, in \HOL\ logic!properties of bijections for|(}

The following \ML\ functions are provided for proving that the bijections
introduced by \\
\ml{define\_new\_type\_bijections} are injective (one-to-one)
and surjective (onto):

\begin{boxed}
\index{prove_rep_fn_one_one@@\ml{prove\_rep\_fn\_one\_one}|pin}
\index{prove_rep_fn_onto@@\ml{prove\_rep\_fn\_onto}|pin}
\index{prove_abs_fn_one_one@@\ml{prove\_abs\_fn\_one\_one}|pin}
\index{prove_abs_fn_onto@@\ml{prove\_abs\_fn\_onto}|pin}
\begin{verbatim}
   prove_rep_fn_one_one : thm -> thm
   prove_rep_fn_onto    : thm -> thm
   prove_abs_fn_one_one : thm -> thm
   prove_abs_fn_onto    : thm -> thm
\end{verbatim}\end{boxed}

\noindent The theorem argument to each of these functions must be a theorem 
of the form returned by \ml{define\_new\_type\_bijections}:

{\def\bk{\char'134}
\begin{hol}\begin{alltt}
   |- (!a. \m{abs}(\m{rep} a) = a) /\bk (!r. \m{P} r = (\m{rep}(\m{abs} r) = r))
\end{alltt}\end{hol}}

\noindent If \m{th} is a theorem of this form, then evaluating
\ml{prove\_rep\_fn\_one\_one \m{th}} proves that the function \m{rep} is
one-to-one, and returns the theorem:

\begin{hol}\begin{alltt}
   |- !a a'. (\m{rep} a = \m{rep} a') = (a = a')
\end{alltt}\end{hol}

\noindent Likewise, \ml{prove\_rep\_fn\_onto \m{th}} proves that \m{rep} is
onto the set of values that satisfy \m{P}:

{\def\bk{\char'134}
\begin{hol}\begin{alltt}
   |- !r. \m{P} r = (?a. r = \m{rep} a)
\end{alltt}\end{hol}}

\noindent Evaluating \ml{prove\_abs\_fn\_one\_one \m{th}} proves that \m{abs}
is one-to-one for values that satisfy \m{P}, and returns the theorem:

{\def\bk{\char'134}
\begin{hol}\begin{alltt}
   |- !r r'. \m{P} r ==> \m{P} r' ==> ((\m{abs} r = \m{abs} r') = (r = r'))
\end{alltt}\end{hol}}

\noindent And evaluating \ml{prove\_abs\_fn\_onto \m{th}} proves that \m{abs}
is onto, returning the theorem:

{\def\bk{\char'134}
\begin{hol}\begin{alltt}
   |- !a. ?r. (a = \m{abs} r) /\bk \m{P} r
\end{alltt}\end{hol}}

\noindent All four functions will fail if applied to any theorem that does not
have the form of a theorem returned by \ml{define\_new\_type\_bijections}.
None of these functions saves anything on the current theory file. In fact, it
should usually be unnecessary to save the results proved by these functions,
since they can be generated quickly whenever required from the theorem returned
by \ml{define\_new\_type\_bijections}, which is itself saved.  Of course,
within any given session, one would bind results to \ML\ identifiers.

\index{type definitions, in HOL logic@@type definitions, in \HOL\ logic!properties of bijections for|)}


@


1.3.2.1
log
@Moving changes toManual Description to main development branch
@
text
@@


1.3.2.2
log
@Changed quotations.
@
text
@d67 2
a68 2
a term whose \HOL\ type is {\small\verb%``:bool``%}.
Therefore, a term\index{terms, in HOL logic@@terms, in \HOL\ logic!as logical formulas} of type {\small\verb%``:bool``%} is used to represent
d74 1
a74 1
is represented by a list of {\small\verb%``:bool``%}-typed terms.
d139 1
a139 1
the absence of \HOL\ quotation marks\index{ theorem marker, in HOL logic@@\ml{"|-} (theorem marker, in \HOL\ logic)} 
d154 1
a154 1
val it = ``!t. (t = T) \/ (t = F)`` : term
d157 1
a157 1
val it = ``:bool`` : typ
d208 1
a208 1
infix) and {\small\verb%@@%}\index{ choice function, in HOL logic@@{\small\verb+"@@+} (choice function, in \HOL\ logic)}\index{choice operator, in HOL logic@@choice operator, in \HOL\ logic} (choice, a binder).  Equality\index{equality, in HOL logic@@equality, in \HOL\ logic}\index{implication, in HOL logic@@implication, in \HOL\ logic}
d233 1
a233 1
and {\small\verb%?!%} (unique existence quantifier)\index{ exists unique, in HOL logic@@{\small\verb+?"!+} (exists unique, in \HOL\ logic)}\index{exists unique, in HOL logic@@exists unique, in \HOL\ logic!defined in terms of primitives}.
d1127 1
a1127 1
 \ml{new\_definition("}$name$\ml{",\ ``}$c\ v_1\ \cdots\ v_n\ =\ t$\ml{``)},
d1171 1
a1171 1
%{\small\verb%   new_infix_definition("%}$ix${\small\verb%_DEF", ``%}$m$% $ix$ $n${\small\verb% = ... ``,$prec$)%}
d1179 1
a1179 1
%{\small\verb%   new_infix_definition("%}$ix${\small\verb%_DEF", ``%}$ix$ $m$ $n${\small\verb% = ... ``)%}
d1190 1
a1190 1
%{\small\verb%   new_infix_definition("%}$ix${\small\verb%_DEF", ``$%}$ix$ $m$ $n${\small\verb% = ... ``)%}
@


1.2
log
@lots of development by don
@
text
@@


1.1
log
@much improved (??), by DRS
@
text
@a695 1
    \item 
a696 4
In future implementations axioms will almost certainly 
go in the \ml{.holsig} file.


d1232 8
a1239 5
\HOLNINETYSEVENDIFF The version of \ml{new\_specification} documented here
is that found in \ml{Const\_spec.new\_specification}.  The
version found at the top level needs extra fixity information passed as
an argument, and is included for compatibility with previous
versions of \HOLNINETY.
d1492 2
a1493 1
introduced by \ml{define\_new\_type\_isomorphisms} are injective (one-to-one)
@
