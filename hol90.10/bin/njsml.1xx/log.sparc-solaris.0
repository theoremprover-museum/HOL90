Standard ML of New Jersey, Version 110.0.3, January 30, 1998 [CM; autoload enabled]
- [opening /Nfs/bescot/grp11/hol/hol90.10/src/0/sources.sml]
[opening SysParams.sml]
structure SysParams :
  sig
    datatype MLversion = Ninety | NinetySeven
    datatype thy_opt = make_binary | make_new_ascii | use_old_ascii
    val HOL_base_directory : string
    val MLdialect : MLversion
    val arch : string
    val remake_theory_files : bool
    val theory_file_option : thy_opt
    val theory_file_type : string
    val version_number : string
  end
val it = () : unit
GC #0.0.0.0.1.12:   (10 ms)
GC #0.0.0.1.2.25:   (60 ms)
GC #0.0.0.1.3.50:   (30 ms)
GC #0.0.0.1.4.60:   (80 ms)
GC #0.0.0.1.5.78:   (30 ms)
GC #0.0.0.1.6.125:   (30 ms)
[opening portableML/njsml.109.32.sml]
structure Portable :
  sig
    structure Array : <sig>
    structure ByteArray : <sig>
    structure Char : <sig>
    structure General : <sig>
    structure Int : <sig>
    structure List : <sig>
    structure PrettyPrint : <sig>
    structure Ref : <sig>
    structure String : <sig>
    structure Time : <sig>
    structure Timer : <sig>
    structure Vector : <sig>
    datatype 'a frag = ANTIQUOTE of 'a | QUOTE of string
    type instream = instream
    type outstream = outstream
    exception Io of string
    val argv : unit -> string list
    val cd : string -> unit
    val close_in : instream -> unit
    val close_out : outstream -> unit
    val end_of_stream : instream -> bool
    val execute : string * string list -> instream * outstream
    val exit : unit -> 'a
    val explode : string -> string list
    val exportML : string -> unit
    val file_exists_for_reading : string -> bool
    val flush_out : outstream -> unit
    val getArgs : unit -> string list
    val getEnv : string -> string option
    val implode : string list -> string
    val input_line : instream -> string
    val interp : bool ref
    val linewidth : int ref
    val listDir : string -> string list
    val load : string list -> unit
    val ls : unit -> OS.Process.status
    val open_in : string -> instream
    val open_out : string -> outstream
    val open_string : string -> instream
    val output : outstream * TextIO.vector -> unit
    val outputc : outstream -> TextIO.vector -> unit
    val pointer_eq : 'a * 'b -> bool
    val pwd : unit -> string
    val real_to_string : real -> string
    val reap : Unix.proc -> unit
    val say : string -> unit
    val sml_banner : string
    val std_out : outstream
    val stdin : instream
    val string_to_int : string -> int option
    val system : string -> OS.Process.status
    val unfiltered_use_file : string -> unit
    val unfiltered_use_stream : instream -> unit
    val use : string -> unit
    val use_and_exit : (exn -> 'a) -> string -> 'b
    val use_stream : instream -> unit
    val version : {date:string, system:string, version_id:int list}
  end
val it = () : unit
GC #0.0.0.1.7.144:   (0 ms)
[opening 0/globals.sig]
signature Globals_sig =
  sig
    val version_number : string
    val neg_defined : unit -> bool
    val nums_defined : unit -> bool
    val strings_defined : unit -> bool
    val assert_neg_defined : unit -> unit
    val assert_nums_defined : unit -> unit
    val assert_strings_defined : unit -> unit
    val in_type_spec : string option ref
    val print_exceptions : bool ref
    val show_assums : bool ref
    val allow_theorems_with_assumptions : bool ref
    val use_init_file : bool ref
    val max_print_depth : int ref
    val type_pp_prefix : string ref
    val type_pp_suffix : string ref
    val term_pp_prefix : string ref
    val term_pp_suffix : string ref
    val linewidth : int ref
    val interp : bool ref
    val paths : {HOLdir:string ref, help_path:string list ref,
                 library_path:string list ref, theory_path:string list ref}
    val HOLdir : string ref
    val theory_path : string list ref
    val library_path : string list ref
    val help_path : string list ref
    val output_HOL_ERR : ({message:string, origin_function:string,
                           origin_structure:string}
                          -> unit) ref
    val output_help : string ref
    val tilde_symbols : string list ref
    val pp_flags : {in_at_end:bool ref, infix_at_front:bool ref,
                    show_dB:bool ref, show_restrict:bool ref,
                    show_types:bool ref, stack_infixes:bool ref}
    val show_dB : bool ref
    val show_restrict : bool ref
    val show_types : bool ref
    val infix_at_front : bool ref
    val stack_infixes : bool ref
    val in_at_end : bool ref
    val reserved_identifiers : {alphanumeric:string list, symbolic:string list}
    val goal_line : string ref
    val notify_on_tyvar_guess : bool ref
  end
val it = () : unit
[opening 0/globals.sml]
structure Globals : Globals_sig
val it = () : unit
[opening 0/exception.sig]
signature Exception_sig =
  sig
    exception HOL_ERR of {message:string, origin_function:string,
                          origin_structure:string}
    val print_HOL_ERR : exn -> unit
    val Raise : exn -> 'a
  end
val it = () : unit
GC #0.0.0.1.8.195:   (20 ms)
[opening 0/exception.sml]
structure Exception : Exception_sig
val it = () : unit
[opening quote-filter/filter.sml]
quote-filter/filter.sml:111.41-111.55 Warning: match nonexhaustive
          (s,(pd,cd,ps) :: e) => ...
  
quote-filter/filter.sml:44.1-245.4 Warning: match nonexhaustive
          (pd,cd,ps) :: e => ...
  
quote-filter/filter.sml:44.1-245.4 Warning: match nonexhaustive
          (pd,cd,ps) :: e => ...
  
quote-filter/filter.sml:44.1-245.4 Warning: match nonexhaustive
          (pd,cd,ps) :: e => ...
  
quote-filter/filter.sml:44.1-245.4 Warning: match nonexhaustive
          (pd,cd,ps) :: e => ...
  
quote-filter/filter.sml:44.1-245.4 Warning: match nonexhaustive
          (_,_,ps) :: _ => ...
  
quote-filter/filter.sml:44.1-245.4 Warning: match nonexhaustive
          (_,cd,_) :: _ => ...
  
quote-filter/filter.sml:44.1-245.4 Warning: match nonexhaustive
          (pd,_,_) :: _ => ...
  
GC #0.0.0.1.9.239:   (30 ms)
GC #0.0.0.1.10.256:   (50 ms)
GC #0.0.0.1.11.267:   (30 ms)
GC #0.0.1.2.12.294:   (140 ms)
GC #0.0.1.2.13.304:   (20 ms)
GC #0.0.1.2.14.350:   (40 ms)
structure QuoteFilter : sig val quote_filter : string -> string end
val it = () : unit
GC #0.0.1.2.15.364:   (0 ms)
[opening 0/lib.sig]
signature Lib_sig =
  sig
    val curry : ('a * 'b -> 'c) -> 'a -> 'b -> 'c
    val uncurry : ('a -> 'b -> 'c) -> 'a * 'b -> 'c
    val append : 'a list -> 'a list -> 'a list
    val concat : string -> string -> string
    val equal : ''a -> ''a -> bool
    val ## : ('a -> 'c) * ('b -> 'd) -> 'a * 'b -> 'c * 'd
    val A : ('a -> 'b) -> 'a -> 'b
    val B : ('a -> 'c) -> ('b -> 'a) -> 'b -> 'c
    val C : ('b -> 'a -> 'c) -> 'a -> 'b -> 'c
    val I : 'a -> 'a
    val K : 'b -> 'a -> 'b
    val S : ('b -> 'a -> 'c) -> ('b -> 'a) -> 'b -> 'c
    val W : ('a -> 'a -> 'b) -> 'a -> 'b
    val fst : 'b * 'a -> 'b
    val snd : 'a * 'b -> 'b
    val can : ('b -> 'a) -> 'b -> bool
    val try : ('a -> 'b) -> 'a -> 'b
    val assert : ('a -> bool) -> 'a -> 'a
    val tryfind : ('a -> 'b) -> 'a list -> 'b
    val el : int -> 'a list -> 'a
    val map2 : ('a -> 'b -> 'c) -> 'a list -> 'b list -> 'c list
    val all : ('a -> bool) -> 'a list -> bool
    val all2 : ('a -> 'b -> bool) -> 'a list -> 'b list -> bool
    val exists : ('a -> bool) -> 'a list -> bool
    val first : ('a -> bool) -> 'a list -> 'a
    val split_after : int -> 'a list -> 'a list * 'a list
    val partition : ('a -> bool) -> 'a list -> 'a list * 'a list
    val gather : ('a -> bool) -> 'a list -> 'a list
    val filter : ('a -> bool) -> 'a list -> 'a list
    val itlist : ('a -> 'b -> 'b) -> 'a list -> 'b -> 'b
    val itlist2 : ('a -> 'b -> 'c -> 'c) -> 'a list -> 'b list -> 'c -> 'c
    val rev_itlist : ('a -> 'b -> 'b) -> 'a list -> 'b -> 'b
    val rev_itlist2 : ('a -> 'b -> 'c -> 'c) -> 'a list -> 'b list -> 'c -> 'c
    val end_itlist : ('a -> 'a -> 'a) -> 'a list -> 'a
    val zip : 'a list -> 'b list -> ('a * 'b) list
    val combine : 'a list * 'b list -> ('a * 'b) list
    val unzip : ('a * 'b) list -> 'a list * 'b list
    val split : ('a * 'b) list -> 'a list * 'b list
    val mapfilter : ('a -> 'b) -> 'a list -> 'b list
    val flatten : 'a list list -> 'a list
    exception NOT_FOUND
    exception NO_CHANGE
    val assoc : ''a -> (''a * 'b) list -> 'b
    val assoc1 : ''a -> (''a * 'b) list -> (''a * 'b) option
    val assoc2 : ''b -> ('a * ''b) list -> ('a * ''b) option
    type 'a subst
    val subst_assoc : ('a -> bool) -> 'a subst -> 'a option
    val |-> : 'a * 'a -> {redex:'a, residue:'a}
    val mem : ''a -> ''a list -> bool
    val insert : ''a -> ''a list -> ''a list
    val mk_set : ''a list -> ''a list
    val union : ''a list -> ''a list -> ''a list
    val U : ''a list list -> ''a list
    val set_diff : ''a list -> ''a list -> ''a list
    val subtract : ''a list -> ''a list -> ''a list
    val intersect : ''a list -> ''a list -> ''a list
    val null_intersection : ''a list -> ''a list -> bool
    val set_eq : ''a list -> ''a list -> bool
    val op_mem : ('a -> 'b -> bool) -> 'a -> 'b list -> bool
    val op_union : ('a -> 'a -> bool) -> 'a list -> 'a list -> 'a list
    val op_U : ('a -> 'a -> bool) -> 'a list list -> 'a list
    val op_intersect : ('a -> 'a -> bool) -> 'a list -> 'a list -> 'a list
    val for : int -> int -> (int -> 'a) -> 'a list
    val for_se : int -> int -> (int -> 'a) -> unit
    val list_of_array : 'a array -> 'a list
    val int_to_string : int -> string
    val string_to_int : string -> int
    val sort : ('a -> 'a -> bool) -> 'a list -> 'a list
    val int_sort : int list -> int list
    val clean_directory : string -> unit
    val file_exists_for_reading : string -> bool
    val find_path : string list -> string -> string
    val cons_path : string -> string list ref -> unit
    val append_path : string -> string list ref -> unit
    type time
    val timestamp : unit -> time
    val time_eq : time -> time -> bool
    val time_lt : time -> time -> bool
    val time : ('a -> 'b) -> 'a -> 'b
    val compile : string -> unit
    val interpret : string -> unit
    type ('a,'b) istream
    val mk_istream : ('a -> 'a) -> 'a -> ('a -> 'b) -> ('a,'b) istream
    val next : ('a,'b) istream -> ('a,'b) istream
    val state : ('a,'b) istream -> 'b
    val reset : ('a,'b) istream -> ('a,'b) istream
    val use_string : string -> unit
    val say : string -> unit
    val quote : string -> string
    val words2 : string -> string -> string list
    val front_last : 'a list -> 'a list * 'a
    val last : 'a list -> 'a
    val funpow : int -> ('a -> 'a) -> 'a -> 'a
    val ordof : string * int -> int
    val mesg : bool -> string -> unit
    val with_flag : 'a ref -> 'a -> ('c -> 'b) -> 'c -> unit
  end
val it = () : unit
GC #0.0.1.2.16.389:   (30 ms)
GC #0.0.1.2.17.415:   (30 ms)
[opening 0/lib.sml]
0/lib.sml:141.17-141.47 Warning: binding not exhaustive
          base :: ralist = ...
0/lib.sml:84.27-87.74 Warning: match nonexhaustive
          (nil,nil) => ...
          (a1 :: rst1,a2 :: rst2) => ...
          (_,nil) => ...
  
GC #0.0.1.2.18.447:   (90 ms)
GC #0.0.1.2.19.459:   (30 ms)
GC #0.0.1.2.20.476:   (30 ms)
GC #0.0.1.2.21.491:   (40 ms)
GC #0.0.1.2.22.510:   (50 ms)
GC #0.1.2.3.23.542:   (240 ms)
GC #0.1.2.3.24.563:   (10 ms)
GC #0.1.2.3.25.628:   (30 ms)
GC #0.1.2.3.26.652:   (80 ms)
GC #0.1.3.4.27.674:   (160 ms)
GC #0.1.3.4.28.692:   (0 ms)
structure Lib : Lib_sig
val it = () : unit
opening Lib
  val curry : ('a * 'b -> 'c) -> 'a -> 'b -> 'c
  val uncurry : ('a -> 'b -> 'c) -> 'a * 'b -> 'c
  val append : 'a list -> 'a list -> 'a list
  val concat : string -> string -> string
  val equal : ''a -> ''a -> bool
  val ## : ('a -> 'c) * ('b -> 'd) -> 'a * 'b -> 'c * 'd
  val A : ('a -> 'b) -> 'a -> 'b
  val B : ('a -> 'c) -> ('b -> 'a) -> 'b -> 'c
  val C : ('b -> 'a -> 'c) -> 'a -> 'b -> 'c
  val I : 'a -> 'a
  val K : 'b -> 'a -> 'b
  val S : ('b -> 'a -> 'c) -> ('b -> 'a) -> 'b -> 'c
  val W : ('a -> 'a -> 'b) -> 'a -> 'b
  val fst : 'b * 'a -> 'b
  val snd : 'a * 'b -> 'b
  val can : ('b -> 'a) -> 'b -> bool
  val try : ('a -> 'b) -> 'a -> 'b
  val assert : ('a -> bool) -> 'a -> 'a
  val tryfind : ('a -> 'b) -> 'a list -> 'b
  val el : int -> 'a list -> 'a
  val map2 : ('a -> 'b -> 'c) -> 'a list -> 'b list -> 'c list
  val all : ('a -> bool) -> 'a list -> bool
  val all2 : ('a -> 'b -> bool) -> 'a list -> 'b list -> bool
  val exists : ('a -> bool) -> 'a list -> bool
  val first : ('a -> bool) -> 'a list -> 'a
  val split_after : int -> 'a list -> 'a list * 'a list
  val partition : ('a -> bool) -> 'a list -> 'a list * 'a list
  val gather : ('a -> bool) -> 'a list -> 'a list
  val filter : ('a -> bool) -> 'a list -> 'a list
  val itlist : ('a -> 'b -> 'b) -> 'a list -> 'b -> 'b
  val itlist2 : ('a -> 'b -> 'c -> 'c) -> 'a list -> 'b list -> 'c -> 'c
  val rev_itlist : ('a -> 'b -> 'b) -> 'a list -> 'b -> 'b
  val rev_itlist2 : ('a -> 'b -> 'c -> 'c) -> 'a list -> 'b list -> 'c -> 'c
  val end_itlist : ('a -> 'a -> 'a) -> 'a list -> 'a
  val zip : 'a list -> 'b list -> ('a * 'b) list
  val combine : 'a list * 'b list -> ('a * 'b) list
  val unzip : ('a * 'b) list -> 'a list * 'b list
  val split : ('a * 'b) list -> 'a list * 'b list
  val mapfilter : ('a -> 'b) -> 'a list -> 'b list
  val flatten : 'a list list -> 'a list
  exception NOT_FOUND
  exception NO_CHANGE
  val assoc : ''a -> (''a * 'b) list -> 'b
  val assoc1 : ''a -> (''a * 'b) list -> (''a * 'b) option
  val assoc2 : ''b -> ('a * ''b) list -> ('a * ''b) option
  type 'a subst = {redex:'a, residue:'a} list
  val subst_assoc : ('a -> bool) -> 'a subst -> 'a option
  val |-> : 'a * 'a -> {redex:'a, residue:'a}
  val mem : ''a -> ''a list -> bool
  val insert : ''a -> ''a list -> ''a list
  val mk_set : ''a list -> ''a list
  val union : ''a list -> ''a list -> ''a list
  val U : ''a list list -> ''a list
  val set_diff : ''a list -> ''a list -> ''a list
  val subtract : ''a list -> ''a list -> ''a list
  val intersect : ''a list -> ''a list -> ''a list
  val null_intersection : ''a list -> ''a list -> bool
  val set_eq : ''a list -> ''a list -> bool
  val op_mem : ('a -> 'b -> bool) -> 'a -> 'b list -> bool
  val op_union : ('a -> 'a -> bool) -> 'a list -> 'a list -> 'a list
  val op_U : ('a -> 'a -> bool) -> 'a list list -> 'a list
  val op_intersect : ('a -> 'a -> bool) -> 'a list -> 'a list -> 'a list
  val for : int -> int -> (int -> 'a) -> 'a list
  val for_se : int -> int -> (int -> 'a) -> unit
  val list_of_array : 'a array -> 'a list
  val int_to_string : int -> string
  val string_to_int : string -> int
  val sort : ('a -> 'a -> bool) -> 'a list -> 'a list
  val int_sort : int list -> int list
  val clean_directory : string -> unit
  val file_exists_for_reading : string -> bool
  val find_path : string list -> string -> string
  val cons_path : string -> string list ref -> unit
  val append_path : string -> string list ref -> unit
  type time = Time.time
  val timestamp : unit -> time
  val time_eq : time -> time -> bool
  val time_lt : time -> time -> bool
  val time : ('a -> 'b) -> 'a -> 'b
  val compile : string -> unit
  val interpret : string -> unit
  type ('a,'b) istream
  val mk_istream : ('a -> 'a) -> 'a -> ('a -> 'b) -> ('a,'b) istream
  val next : ('a,'b) istream -> ('a,'b) istream
  val state : ('a,'b) istream -> 'b
  val reset : ('a,'b) istream -> ('a,'b) istream
  val use_string : string -> unit
  val say : string -> unit
  val quote : string -> string
  val words2 : string -> string -> string list
  val front_last : 'a list -> 'a list * 'a
  val last : 'a list -> 'a
  val funpow : int -> ('a -> 'a) -> 'a -> 'a
  val ordof : string * int -> int
  val mesg : bool -> string -> unit
  val with_flag : 'a ref -> 'a -> ('c -> 'b) -> 'c -> unit
[opening 0/file.sig]
signature File_sig =
  sig
    val get_file_by_name : {reader:Portable.instream -> 'a, suffix:string}
                           -> string list -> string -> {data:'a, path:string}
    val get_file_by_key : {eq:'a * 'a -> bool, key_of:'b -> 'a,
                           name_of:'a -> string,
                           reader:Portable.instream -> 'b, suffix:string}
                          -> string list -> 'a -> {data:'b, path:string}
  end
val it = () : unit
GC #0.1.3.4.29.717:   (20 ms)
[opening 0/file.sml]
structure File : File_sig
val it = () : unit
[opening 0/help.sig]
signature Help_sig =
  sig
    val helper : string list -> string -> unit
    val help : string -> unit
    val help1 : string -> unit
  end
val it = () : unit
GC #0.1.3.4.30.745:   (20 ms)
[opening 0/help.sml]
structure Help : Help_sig
val it = () : unit
[opening 0/save_hol.sig]
signature Save_hol_sig =
  sig
    val print_banner : string -> unit
    val save_hol : string -> unit
  end
val it = () : unit
[opening 0/save_hol.sml]
structure Save_hol : Save_hol_sig
val it = () : unit
[opening 0/lexis.sig]
signature Lexis_sig =
  sig
    val allowed_user_type_var : string -> bool
    val allowed_type_constant : string -> bool
    val allowed_term_constant : string -> bool
    val ok_identifier : string -> bool
    val ok_symbolic : string -> bool
    val ok_sml_identifier : string -> bool
    val ok_thy_index : string -> bool
    val is_num_literal : string -> bool
    val is_string_literal : string -> bool
  end
GC #0.1.3.4.31.784:   (10 ms)
val it = () : unit
GC #0.1.3.4.32.824:   (40 ms)
GC #0.1.3.4.33.834:   (50 ms)
[opening 0/lexis.sml]
structure Lexis : Lexis_sig
val it = () : unit
[opening 0/type.sig]
signature Type_sig =
  sig
    datatype hol_type
      = Link of hol_type ref
      | Stv of int
      | Tyapp of {Args:hol_type list, Tyop:string}
      | Tyc of string
      | Utv of string
    datatype 'a delta = DIFF of 'a | SAME
    val fresh_tyvar_stream : unit -> (int,hol_type) istream
    val unify : hol_type -> hol_type -> unit
    val ty_eq : hol_type * hol_type -> bool
    val rename_tv : (int,hol_type) istream -> hol_type -> hol_type delta
    val type_subst : hol_type subst -> hol_type -> hol_type
    val type_vars : hol_type -> hol_type list
    val type_varsl : hol_type list -> hol_type list
    val mk_type : {Args:hol_type list, Tyop:string} -> hol_type
    val dest_type : hol_type -> {Args:hol_type list, Tyop:string}
    val mk_vartype : string -> hol_type
    val dest_vartype : hol_type -> string
    val is_vartype : hol_type -> bool
    val polymorphic : hol_type -> bool
    val type_lt : hol_type -> hol_type -> bool
    val lookup_type : string -> {arity:int, theory:string, tyc:hol_type}
    val type_decl : string -> {arity:int, theory:string, tyc:hol_type}
    val add_type_const : {arity:int, theory:string, tyc:hol_type} -> unit
    val add_entry : {arity:int, theory:string, tyc:hol_type} -> unit
    type symtab
    val symtab_copy : unit -> symtab
    val replace_symtab : symtab -> unit
    exception TYPE_SYMTAB_CLASH of {common_name:string, theory1:string,
                                    theory2:string}
    val is_st_type_const : string -> bool
    val arity_of_type : string -> int
  end
GC #0.1.3.4.34.881:   (10 ms)
signature Public_type_sig =
  sig
    eqtype hol_type
    val fresh_tyvar_stream : unit -> (int,hol_type) istream
    val type_subst : hol_type subst -> hol_type -> hol_type
    val type_vars : hol_type -> hol_type list
    val type_varsl : hol_type list -> hol_type list
    val mk_type : {Args:hol_type list, Tyop:string} -> hol_type
    val dest_type : hol_type -> {Args:hol_type list, Tyop:string}
    val mk_vartype : string -> hol_type
    val dest_vartype : hol_type -> string
    val is_vartype : hol_type -> bool
    val type_lt : hol_type -> hol_type -> bool
    val type_decl : string -> {arity:int, theory:string, tyc:hol_type}
  end
val it = () : unit
[opening 0/type.sml]
0/type.sml:237.41-238.29 Warning: match nonexhaustive
          (a1 :: rst1,a2 :: rst2) => ...
          (nil,nil) => ...
  
0/type.sml:12.1-360.4 Warning: match nonexhaustive
          entry as {arity=_,theory=thry1,tyc=Tyc name} => ...
  
0/type.sml:12.1-360.4 Warning: match nonexhaustive
          entry as {arity=_,theory=_,tyc=Tyc name} => ...
  
GC #0.1.3.4.35.945:   (60 ms)
GC #0.1.3.4.36.959:   (90 ms)
GC #1.2.4.5.37.976:   (480 ms)
GC #1.2.4.5.38.1015:   (30 ms)
structure Type : Type_sig
val it = () : unit
GC #1.2.4.5.39.1043:   (0 ms)
[opening 0/term.sig]
signature Term_sig =
  sig
    structure Type :
      sig
        datatype hol_type
          = Link of hol_type ref
          | Stv of int
          | Tyapp of {Args:hol_type list, Tyop:string}
          | Tyc of string
          | Utv of string
        datatype 'a delta = DIFF of 'a | SAME
        val fresh_tyvar_stream : unit -> (int,hol_type) istream
        val unify : hol_type -> hol_type -> unit
        val ty_eq : hol_type * hol_type -> bool
        val rename_tv : (int,hol_type) istream -> hol_type -> hol_type delta
        val type_subst : hol_type subst -> hol_type -> hol_type
        val type_vars : hol_type -> hol_type list
        val type_varsl : hol_type list -> hol_type list
        val mk_type : {Args:hol_type list, Tyop:string} -> hol_type
        val dest_type : hol_type -> {Args:hol_type list, Tyop:string}
        val mk_vartype : string -> hol_type
        val dest_vartype : hol_type -> string
        val is_vartype : hol_type -> bool
        val polymorphic : hol_type -> bool
        val type_lt : hol_type -> hol_type -> bool
        val lookup_type : string -> {arity:int, theory:string, tyc:hol_type}
        val type_decl : string -> {arity:int, theory:string, tyc:hol_type}
        val add_type_const : {arity:int, theory:string, tyc:hol_type} -> unit
        val add_entry : {arity:int, theory:string, tyc:hol_type} -> unit
        type symtab
        val symtab_copy : unit -> symtab
        val replace_symtab : symtab -> unit
        exception TYPE_SYMTAB_CLASH of {common_name:string, theory1:string,
                                        theory2:string}
        val is_st_type_const : string -> bool
        val arity_of_type : string -> int
      end
    datatype fixity = Binder | Infix of int | Prefix
    datatype term
      = Abs of {Body:term, Bvar:term}
      | Bv of int
      | Comb of {Rand:term, Rator:term}
      | Const of {Name:string, Ty:Type.hol_type}
      | Fv of {Name:string, Ty:Type.hol_type}
      | ty_antiq of Type.hol_type
    datatype lambda
      = COMB of {Rand:term, Rator:term}
      | CONST of {Name:string, Ty:Type.hol_type}
      | LAMB of {Body:term, Bvar:term}
      | VAR of {Name:string, Ty:Type.hol_type}
    type symtab
    val symtab_copy : unit -> symtab
    val replace_symtab : symtab -> unit
    exception TERM_SYMTAB_CLASH of {common_name:string, theory1:string,
                                    theory2:string}
    val lookup_const : string -> term
    val const_decl : string -> {const:term, place:fixity, theory:string}
    datatype add_style = Defining | Loading
    val add_term_const : add_style
                         -> {const:term, place:fixity, theory:string} -> unit
    val is_st_term_const : string -> bool
    val fixity_of_term : string -> fixity
    val fixity_to_string : fixity -> string
    val prec_of_term : string -> int
    val is_binder : string -> bool
    val is_infix : string -> bool
    val is_polymorphic : string -> bool
    val free_vars : term -> term list
    val free_in : term -> term -> bool
    val all_vars : term -> term list
    val free_varsl : term list -> term list
    val all_varsl : term list -> term list
    val term_lt : term -> term -> bool
    val genvar : Type.hol_type -> term
    val genvars : Type.hol_type -> int -> term list
    val variant : term list -> term -> term
    val type_of : term -> Type.hol_type
    val type_vars_in_term : term -> Type.hol_type list
    val mk_var : {Name:string, Ty:Type.hol_type} -> term
    val mk_primed_var : {Name:string, Ty:Type.hol_type} -> term
    val list_mk_comb : term * term list -> term
    val mk_comb : {Rand:term, Rator:term} -> term
    val mk_abs : {Body:term, Bvar:term} -> term
    val dest_var : term -> {Name:string, Ty:Type.hol_type}
    val dest_const : term -> {Name:string, Ty:Type.hol_type}
    val dest_comb : term -> {Rand:term, Rator:term}
    val dest_abs : term -> {Body:term, Bvar:term}
    val is_var : term -> bool
    val is_const : term -> bool
    val is_comb : term -> bool
    val is_abs : term -> bool
    val dest_term : term -> lambda
    val rator : term -> term
    val rand : term -> term
    val bvar : term -> term
    val body : term -> term
    val break_abs : term -> {Body:term, Bvar:term}
    val is_bvar : term -> bool
    val aconv : term -> term -> bool
    val subst : term subst -> term -> term
    val inst : Type.hol_type subst -> term -> term
    val beta_conv : term -> term
  end
signature Public_term_sig =
  sig
    structure Type :
      sig
        eqtype hol_type
        val fresh_tyvar_stream : unit -> (int,hol_type) istream
        val type_subst : hol_type subst -> hol_type -> hol_type
        val type_vars : hol_type -> hol_type list
        val type_varsl : hol_type list -> hol_type list
        val mk_type : {Args:hol_type list, Tyop:string} -> hol_type
        val dest_type : hol_type -> {Args:hol_type list, Tyop:string}
        val mk_vartype : string -> hol_type
        val dest_vartype : hol_type -> string
        val is_vartype : hol_type -> bool
        val type_lt : hol_type -> hol_type -> bool
        val type_decl : string -> {arity:int, theory:string, tyc:hol_type}
      end
    datatype fixity = Binder | Infix of int | Prefix
    eqtype term
    val const_decl : string -> {const:term, place:fixity, theory:string}
    val fixity_of_term : string -> fixity
    val fixity_to_string : fixity -> string
    val prec_of_term : string -> int
    val is_binder : string -> bool
    val is_infix : string -> bool
    val is_polymorphic : string -> bool
    datatype lambda
      = COMB of {Rand:term, Rator:term}
      | CONST of {Name:string, Ty:Type.hol_type}
      | LAMB of {Body:term, Bvar:term}
      | VAR of {Name:string, Ty:Type.hol_type}
    val ty_antiq : Type.hol_type -> term
    val free_vars : term -> term list
    val free_in : term -> term -> bool
    val all_vars : term -> term list
    val free_varsl : term list -> term list
    val all_varsl : term list -> term list
    val term_lt : term -> term -> bool
    val genvar : Type.hol_type -> term
    val genvars : Type.hol_type -> int -> term list
    val variant : term list -> term -> term
    val type_of : term -> Type.hol_type
    val type_vars_in_term : term -> Type.hol_type list
    val mk_var : {Name:string, Ty:Type.hol_type} -> term
    val mk_primed_var : {Name:string, Ty:Type.hol_type} -> term
    val list_mk_comb : term * term list -> term
    val mk_comb : {Rand:term, Rator:term} -> term
    val mk_abs : {Body:term, Bvar:term} -> term
    val dest_var : term -> {Name:string, Ty:Type.hol_type}
    val dest_const : term -> {Name:string, Ty:Type.hol_type}
    val dest_comb : term -> {Rand:term, Rator:term}
    val dest_abs : term -> {Body:term, Bvar:term}
    val is_var : term -> bool
    val is_const : term -> bool
    val is_comb : term -> bool
    val is_abs : term -> bool
    val dest_term : term -> lambda
    val rator : term -> term
    val rand : term -> term
    val bvar : term -> term
    val body : term -> term
    val aconv : term -> term -> bool
    val subst : term subst -> term -> term
    val inst : Type.hol_type subst -> term -> term
    val beta_conv : term -> term
  end
val it = () : unit
GC #1.2.4.5.40.1135:   (100 ms)
GC #1.2.4.5.41.1166:   (60 ms)
[opening 0/term.sml]
0/term.sml:160.2-170.74 Warning: match nonexhaustive
          (DorL,
           entry as {const=Const {Name=Name,Ty=Ty},place=place,
                     theory=thry1}) => ...
  
0/term.sml:132.8-136.36 Warning: match nonexhaustive
          (tr  as {const=Const {Name=Name,Ty=_},place=_,theory=_}) ::
            nil => ...
          (tr  as {const=Const {Name=Name,Ty=_},place=_,theory=_}) ::
            rst => ...
          nil => ...
  
0/term.sml:12.1-1009.4 Warning: match nonexhaustive
          entry as {const=Const {Name=Name,Ty=_},place=_,theory=_} => ...
  
GC #1.2.4.5.42.1194:   (80 ms)
GC #1.2.5.6.43.1203:   (90 ms)
GC #1.2.5.6.44.1241:   (80 ms)
GC #1.2.6.7.45.1252:   (160 ms)
GC #1.2.6.8.46.1281:   (70 ms)
GC #1.2.6.8.47.1320:   (40 ms)
GC #1.2.6.8.48.1381:   (30 ms)
GC #1.2.7.9.49.1471:   (150 ms)
GC #1.2.7.10.50.1476:   (90 ms)
GC #1.2.7.10.51.1480:   (10 ms)
functor TERM : <sig>
val it = () : unit
GC #1.2.8.11.52.1481:   (0 ms)
[opening 0/match.sig]
signature Match_sig =
  sig
    structure Term :
      sig
        structure Type : <sig>
        datatype fixity = Binder | Infix of int | Prefix
        eqtype term
        val const_decl : string -> {const:term, place:fixity, theory:string}
        val fixity_of_term : string -> fixity
        val fixity_to_string : fixity -> string
        val prec_of_term : string -> int
        val is_binder : string -> bool
        val is_infix : string -> bool
        val is_polymorphic : string -> bool
        datatype lambda
          = COMB of {Rand:term, Rator:term}
          | CONST of {Name:string, Ty:Type.hol_type}
          | LAMB of {Body:term, Bvar:term}
          | VAR of {Name:string, Ty:Type.hol_type}
        val ty_antiq : Type.hol_type -> term
        val free_vars : term -> term list
        val free_in : term -> term -> bool
        val all_vars : term -> term list
        val free_varsl : term list -> term list
        val all_varsl : term list -> term list
        val term_lt : term -> term -> bool
        val genvar : Type.hol_type -> term
        val genvars : Type.hol_type -> int -> term list
        val variant : term list -> term -> term
        val type_of : term -> Type.hol_type
        val type_vars_in_term : term -> Type.hol_type list
        val mk_var : {Name:string, Ty:Type.hol_type} -> term
        val mk_primed_var : {Name:string, Ty:Type.hol_type} -> term
        val list_mk_comb : term * term list -> term
        val mk_comb : {Rand:term, Rator:term} -> term
        val mk_abs : {Body:term, Bvar:term} -> term
        val dest_var : term -> {Name:string, Ty:Type.hol_type}
        val dest_const : term -> {Name:string, Ty:Type.hol_type}
        val dest_comb : term -> {Rand:term, Rator:term}
        val dest_abs : term -> {Body:term, Bvar:term}
        val is_var : term -> bool
        val is_const : term -> bool
        val is_comb : term -> bool
        val is_abs : term -> bool
        val dest_term : term -> lambda
        val rator : term -> term
        val rand : term -> term
        val bvar : term -> term
        val body : term -> term
        val aconv : term -> term -> bool
        val subst : term subst -> term -> term
        val inst : Type.hol_type subst -> term -> term
        val beta_conv : term -> term
      end
    val match_type : Term.Type.hol_type
                     -> Term.Type.hol_type -> Term.Type.hol_type subst
    val match_term : Term.term
                     -> Term.term -> Term.term subst * Term.Type.hol_type subst
  end
val it = () : unit
GC #1.2.8.12.53.1498:   (10 ms)
GC #1.2.8.13.54.1517:   (40 ms)
GC #1.2.8.14.55.1524:   (40 ms)
GC #1.2.8.15.56.1560:   (40 ms)
[opening 0/match.sml]
functor MATCH : <sig>
val it = () : unit
[opening 0/dsyntax.sig]
signature Dsyntax_sig =
  sig
    structure Term :
      sig
        structure Type : <sig>
        datatype fixity = Binder | Infix of int | Prefix
        eqtype term
        val const_decl : string -> {const:term, place:fixity, theory:string}
        val fixity_of_term : string -> fixity
        val fixity_to_string : fixity -> string
        val prec_of_term : string -> int
        val is_binder : string -> bool
        val is_infix : string -> bool
        val is_polymorphic : string -> bool
        datatype lambda
          = COMB of {Rand:term, Rator:term}
          | CONST of {Name:string, Ty:Type.hol_type}
          | LAMB of {Body:term, Bvar:term}
          | VAR of {Name:string, Ty:Type.hol_type}
        val ty_antiq : Type.hol_type -> term
        val free_vars : term -> term list
        val free_in : term -> term -> bool
        val all_vars : term -> term list
        val free_varsl : term list -> term list
        val all_varsl : term list -> term list
        val term_lt : term -> term -> bool
        val genvar : Type.hol_type -> term
        val genvars : Type.hol_type -> int -> term list
        val variant : term list -> term -> term
        val type_of : term -> Type.hol_type
        val type_vars_in_term : term -> Type.hol_type list
        val mk_var : {Name:string, Ty:Type.hol_type} -> term
        val mk_primed_var : {Name:string, Ty:Type.hol_type} -> term
        val list_mk_comb : term * term list -> term
        val mk_comb : {Rand:term, Rator:term} -> term
        val mk_abs : {Body:term, Bvar:term} -> term
        val dest_var : term -> {Name:string, Ty:Type.hol_type}
        val dest_const : term -> {Name:string, Ty:Type.hol_type}
        val dest_comb : term -> {Rand:term, Rator:term}
        val dest_abs : term -> {Body:term, Bvar:term}
        val is_var : term -> bool
        val is_const : term -> bool
        val is_comb : term -> bool
        val is_abs : term -> bool
        val dest_term : term -> lambda
        val rator : term -> term
        val rand : term -> term
        val bvar : term -> term
        val body : term -> term
        val aconv : term -> term -> bool
        val subst : term subst -> term -> term
        val inst : Type.hol_type subst -> term -> term
        val beta_conv : term -> term
      end
    val mk_const : {Name:string, Ty:Term.Type.hol_type} -> Term.term
    val mk_eq : {lhs:Term.term, rhs:Term.term} -> Term.term
    val mk_imp : {ant:Term.term, conseq:Term.term} -> Term.term
    val mk_select : {Body:Term.term, Bvar:Term.term} -> Term.term
    val mk_forall : {Body:Term.term, Bvar:Term.term} -> Term.term
    val mk_exists : {Body:Term.term, Bvar:Term.term} -> Term.term
    val mk_neg : Term.term -> Term.term
    val mk_conj : {conj1:Term.term, conj2:Term.term} -> Term.term
    val mk_disj : {disj1:Term.term, disj2:Term.term} -> Term.term
    val mk_cond : {cond:Term.term, larm:Term.term, rarm:Term.term} -> Term.term
    val mk_pair : {fst:Term.term, snd:Term.term} -> Term.term
    val mk_let : {arg:Term.term, func:Term.term} -> Term.term
    val mk_cons : {hd:Term.term, tl:Term.term} -> Term.term
    val mk_list : {els:Term.term list, ty:Term.Type.hol_type} -> Term.term
    val mk_pabs : {body:Term.term, varstruct:Term.term} -> Term.term
    val dest_eq : Term.term -> {lhs:Term.term, rhs:Term.term}
    val lhs : Term.term -> Term.term
    val rhs : Term.term -> Term.term
    val dest_imp : Term.term -> {ant:Term.term, conseq:Term.term}
    val dest_select : Term.term -> {Body:Term.term, Bvar:Term.term}
    val dest_forall : Term.term -> {Body:Term.term, Bvar:Term.term}
    val dest_exists : Term.term -> {Body:Term.term, Bvar:Term.term}
    val dest_neg : Term.term -> Term.term
    val dest_conj : Term.term -> {conj1:Term.term, conj2:Term.term}
    val dest_disj : Term.term -> {disj1:Term.term, disj2:Term.term}
    val dest_cond : Term.term
                    -> {cond:Term.term, larm:Term.term, rarm:Term.term}
    val dest_pair : Term.term -> {fst:Term.term, snd:Term.term}
    val dest_let : Term.term -> {arg:Term.term, func:Term.term}
    val dest_cons : Term.term -> {hd:Term.term, tl:Term.term}
    val dest_list : Term.term -> {els:Term.term list, ty:Term.Type.hol_type}
    val dest_pabs : Term.term -> {body:Term.term, varstruct:Term.term}
    val is_eq : Term.term -> bool
    val is_imp : Term.term -> bool
    val is_select : Term.term -> bool
    val is_forall : Term.term -> bool
    val is_exists : Term.term -> bool
    val is_neg : Term.term -> bool
    val is_conj : Term.term -> bool
    val is_disj : Term.term -> bool
    val is_cond : Term.term -> bool
    val is_pair : Term.term -> bool
    val is_let : Term.term -> bool
    val is_cons : Term.term -> bool
    val is_list : Term.term -> bool
    val is_pabs : Term.term -> bool
    val list_mk_abs : Term.term list * Term.term -> Term.term
    val list_mk_imp : Term.term list * Term.term -> Term.term
    val list_mk_forall : Term.term list * Term.term -> Term.term
    val gen_all : Term.term -> Term.term
    val list_mk_exists : Term.term list * Term.term -> Term.term
    val list_mk_conj : Term.term list -> Term.term
    val list_mk_disj : Term.term list -> Term.term
    val list_mk_pair : Term.term list -> Term.term
    val strip_comb : Term.term -> Term.term * Term.term list
    val strip_abs : Term.term -> Term.term list * Term.term
    val strip_imp : Term.term -> Term.term list * Term.term
    val strip_forall : Term.term -> Term.term list * Term.term
    val strip_exists : Term.term -> Term.term list * Term.term
    val strip_conj : Term.term -> Term.term list
    val strip_disj : Term.term -> Term.term list
    val strip_pair : Term.term -> Term.term list
    val infix_ty : Term.Type.hol_type
                   -> Term.Type.hol_type -> Term.Type.hol_type
    val bool : Term.Type.hol_type
    val de_abs : Term.term -> Term.term list * Term.term
    val find_term : (Term.term -> bool) -> Term.term -> Term.term
    val find_terms : (Term.term -> bool) -> Term.term -> Term.term list
    val subst_occs : int list list -> Term.term subst -> Term.term -> Term.term
    val binder_restrictions : unit -> (string * string) list
    val associate_restriction : string * string -> unit
    val delete_restriction : string -> unit
  end
val it = () : unit
GC #1.2.8.16.57.1586:   (30 ms)
GC #1.2.8.16.58.1615:   (30 ms)
[opening 0/dsyntax.sml]
0/dsyntax.sml:260.13-261.30 Warning: binding not exhaustive
          {Name="NIL",Ty=Tyapp {Args=ty :: nil,Tyop="list"}} = ...
GC #1.2.8.17.59.1652:   (90 ms)
0/dsyntax.sml:25.8-25.60 Warning: binding not exhaustive
          c as Const {Name=_,Ty=ty} = ...
GC #1.2.8.18.60.1664:   (80 ms)
GC #1.2.8.18.61.1692:   (50 ms)
GC #1.2.9.19.62.1702:   (190 ms)
GC #1.3.10.20.63.1727:   (160 ms)
GC #1.3.10.20.64.1783:   (50 ms)
GC #1.3.10.21.65.1839:   (80 ms)
GC #1.3.10.22.66.1878:   (10 ms)
functor DSYNTAX : <sig>
val it = () : unit
[opening 0/pp.sig]
signature PP_sig =
  sig
    type ppstream
    type ppconsumer
    datatype break_style = CONSISTENT | INCONSISTENT
    val mk_consumer : {consumer:string -> unit, flush:unit -> unit,
                       linewidth:int}
                      -> ppconsumer
    val defaultConsumer : unit
                          -> {consumer:string -> unit, flush:unit -> unit,
                              linewidth:int}
    val mk_ppstream : ppconsumer -> ppstream
    val dest_ppstream : ppstream -> ppconsumer
    val add_break : ppstream -> int * int -> unit
    val add_newline : ppstream -> unit
    val add_string : ppstream -> string -> unit
    val begin_block : ppstream -> break_style -> int -> unit
    val end_block : ppstream -> unit
    val clear_ppstream : ppstream -> unit
    val flush_ppstream : ppstream -> unit
    val with_pp : ppconsumer -> (ppstream -> unit) -> unit
    val install_pp : string list -> string -> (ppstream -> 'a -> unit) -> unit
    val pp_to_string : int -> (ppstream -> 'a -> unit) -> 'a -> string
    val with_ppstream : ppstream
                        -> {add_break:int * int -> unit,
                            add_newline:unit -> unit,
                            add_string:string -> unit,
                            begin_block:break_style -> int -> unit,
                            clear_ppstream:unit -> unit,
                            end_block:unit -> unit,
                            flush_ppstream:unit -> unit}
    val pr_list : ('c -> unit)
                  -> (unit -> 'a) -> (unit -> 'b) -> 'c list -> unit
  end
val it = () : unit
[opening 0/pp.sml]
structure PP : PP_sig
val it = () : unit
[opening 0/hol_pp.extensible.sig]
signature Hol_pp_sig =
  sig
    structure Term :
      sig
        structure Type : <sig>
        datatype fixity = Binder | Infix of int | Prefix
        eqtype term
        val const_decl : string -> {const:term, place:fixity, theory:string}
        val fixity_of_term : string -> fixity
        val fixity_to_string : fixity -> string
        val prec_of_term : string -> int
        val is_binder : string -> bool
        val is_infix : string -> bool
        val is_polymorphic : string -> bool
        datatype lambda
          = COMB of {Rand:term, Rator:term}
          | CONST of {Name:string, Ty:Type.hol_type}
          | LAMB of {Body:term, Bvar:term}
          | VAR of {Name:string, Ty:Type.hol_type}
        val ty_antiq : Type.hol_type -> term
        val free_vars : term -> term list
        val free_in : term -> term -> bool
        val all_vars : term -> term list
        val free_varsl : term list -> term list
        val all_varsl : term list -> term list
        val term_lt : term -> term -> bool
        val genvar : Type.hol_type -> term
        val genvars : Type.hol_type -> int -> term list
        val variant : term list -> term -> term
        val type_of : term -> Type.hol_type
        val type_vars_in_term : term -> Type.hol_type list
        val mk_var : {Name:string, Ty:Type.hol_type} -> term
        val mk_primed_var : {Name:string, Ty:Type.hol_type} -> term
        val list_mk_comb : term * term list -> term
        val mk_comb : {Rand:term, Rator:term} -> term
        val mk_abs : {Body:term, Bvar:term} -> term
        val dest_var : term -> {Name:string, Ty:Type.hol_type}
        val dest_const : term -> {Name:string, Ty:Type.hol_type}
        val dest_comb : term -> {Rand:term, Rator:term}
        val dest_abs : term -> {Body:term, Bvar:term}
        val is_var : term -> bool
        val is_const : term -> bool
        val is_comb : term -> bool
        val is_abs : term -> bool
        val dest_term : term -> lambda
        val rator : term -> term
        val rand : term -> term
        val bvar : term -> term
        val body : term -> term
        val aconv : term -> term -> bool
        val subst : term subst -> term -> term
        val inst : Type.hol_type subst -> term -> term
        val beta_conv : term -> term
      end
    val pp_type : ?.PrettyPrint.ppstream -> Term.Type.hol_type -> int -> unit
    val pp_term : ?.PrettyPrint.ppstream -> Term.term -> unit
    val pp_self_parsing_type : ?.PrettyPrint.ppstream
                               -> Term.Type.hol_type -> unit
    val pp_self_parsing_term : ?.PrettyPrint.ppstream -> Term.term -> unit
    val type_to_string : Term.Type.hol_type -> string
    val term_to_string : Term.term -> string
    val print_type : Term.Type.hol_type -> unit
    val print_term : Term.term -> unit
    structure Extend_hol_pp :
      sig
        datatype gravity = APPL | BOTTOM | INFIX of int | TOP | WEAK
        val gravity_geq : gravity -> gravity -> bool
        val extend_pp_type : (({depth:int, gravity:gravity}
                               -> Term.Type.hol_type
                                  -> ?.PrettyPrint.ppstream -> unit)
                              -> {depth:int, gravity:gravity}
                                 -> Term.Type.hol_type
                                    -> ?.PrettyPrint.ppstream -> unit)
                             -> unit
        val extend_pp_term : (({boundvars:Term.term list, depth:int,
                                gravity:gravity}
                               -> Term.term -> ?.PrettyPrint.ppstream -> unit)
                              -> {boundvars:Term.term list, depth:int,
                                  gravity:gravity}
                                 -> Term.term
                                    -> ?.PrettyPrint.ppstream -> unit)
                             -> unit
        val reset_pp_type : unit -> unit
        val reset_pp_term : unit -> unit
      end
  end
val it = () : unit
GC #1.3.10.22.67.1921:   (40 ms)
GC #1.3.10.22.68.1963:   (110 ms)
GC #1.3.10.23.69.1985:   (60 ms)
GC #1.3.10.23.70.2016:   (90 ms)
GC #1.3.10.23.71.2042:   (70 ms)
GC #1.3.10.23.72.2048:   (50 ms)
GC #1.3.11.24.73.2070:   (90 ms)
GC #1.3.11.24.74.2092:   (40 ms)
GC #1.3.11.24.75.2098:   (60 ms)
GC #1.3.11.24.76.2116:   (120 ms)
GC #1.3.12.25.77.2126:   (230 ms)
GC #1.3.12.25.78.2161:   (70 ms)
GC #1.3.12.25.79.2198:   (80 ms)
GC #1.3.13.26.80.2241:   (150 ms)
GC #1.3.13.26.81.2312:   (70 ms)
GC #1.3.13.26.82.2394:   (100 ms)
GC #1.3.13.27.83.2465:   (150 ms)
GC #1.4.14.28.84.2505:   (240 ms)
GC #1.4.15.29.85.2517:   (110 ms)
GC #1.4.16.30.86.2523:   (0 ms)
[opening 0/hol_pp.extensible.sml]
functor HOL_PP : <sig>
val it = () : unit
GC #1.4.16.31.87.2524:   (0 ms)
[opening 0/thm.sig]
signature Thm_sig =
  sig
    structure Term :
      sig
        structure Type : <sig>
        datatype fixity = Binder | Infix of int | Prefix
        eqtype term
        val const_decl : string -> {const:term, place:fixity, theory:string}
        val fixity_of_term : string -> fixity
        val fixity_to_string : fixity -> string
        val prec_of_term : string -> int
        val is_binder : string -> bool
        val is_infix : string -> bool
        val is_polymorphic : string -> bool
        datatype lambda
          = COMB of {Rand:term, Rator:term}
          | CONST of {Name:string, Ty:Type.hol_type}
          | LAMB of {Body:term, Bvar:term}
          | VAR of {Name:string, Ty:Type.hol_type}
        val ty_antiq : Type.hol_type -> term
        val free_vars : term -> term list
        val free_in : term -> term -> bool
        val all_vars : term -> term list
        val free_varsl : term list -> term list
        val all_varsl : term list -> term list
        val term_lt : term -> term -> bool
        val genvar : Type.hol_type -> term
        val genvars : Type.hol_type -> int -> term list
        val variant : term list -> term -> term
        val type_of : term -> Type.hol_type
        val type_vars_in_term : term -> Type.hol_type list
        val mk_var : {Name:string, Ty:Type.hol_type} -> term
        val mk_primed_var : {Name:string, Ty:Type.hol_type} -> term
        val list_mk_comb : term * term list -> term
        val mk_comb : {Rand:term, Rator:term} -> term
        val mk_abs : {Body:term, Bvar:term} -> term
        val dest_var : term -> {Name:string, Ty:Type.hol_type}
        val dest_const : term -> {Name:string, Ty:Type.hol_type}
        val dest_comb : term -> {Rand:term, Rator:term}
        val dest_abs : term -> {Body:term, Bvar:term}
        val is_var : term -> bool
        val is_const : term -> bool
        val is_comb : term -> bool
        val is_abs : term -> bool
        val dest_term : term -> lambda
        val rator : term -> term
        val rand : term -> term
        val bvar : term -> term
        val body : term -> term
        val aconv : term -> term -> bool
        val subst : term subst -> term -> term
        val inst : Type.hol_type subst -> term -> term
        val beta_conv : term -> term
      end
    type thm
    val reset_thm_count : unit -> unit
    val counting_thms : bool -> unit
    val thm_count : unit
                    -> {ABS:int, ASSUME:int, BETA_CONV:int, DISCH:int,
                        INST_TYPE:int, MP:int, REFL:int, SUBST:int, axiom:int,
                        definition:int, drule:int, from_disk:int, other:int,
                        valid_tac:int}
    val hyp : thm -> Term.term list
    val concl : thm -> Term.term
    val dest_thm : thm -> Term.term list * Term.term
    val thm_free_vars : thm -> Term.term list
    val hyp_union : thm list -> Term.term list
    val pp_thm : ?.PrettyPrint.ppstream -> thm -> unit
    val thm_to_string : thm -> string
    val print_thm : thm -> unit
    val ASSUME : Term.term -> thm
    val REFL : Term.term -> thm
    val BETA_CONV : Term.term -> thm
    val SUBST : {thm:thm, var:Term.term} list -> Term.term -> thm -> thm
    val ABS : Term.term -> thm -> thm
    val INST_TYPE : Term.Type.hol_type subst -> thm -> thm
    val DISCH : Term.term -> thm -> thm
    val MP : thm -> thm -> thm
    val mk_axiom_thm : Term.term list * Term.term -> thm
    val mk_definition_thm : Term.term list * Term.term -> thm
    val mk_drule_thm : Term.term list * Term.term -> thm
    val mk_disk_thm : Term.term list * Term.term -> thm
    val mk_tac_thm : Term.term list * Term.term -> thm
    val mk_thm : Term.term list * Term.term -> thm
    datatype just_arg
      = JA_INT of int
      | JA_INTLIST of int list
      | JA_PAIR of just_arg * just_arg
      | JA_STRING of string
      | JA_TERM of Term.term
      | JA_THM of thm
      | JA_TYPE of Term.Type.hol_type
    datatype step = STEP of {Just:just_arg list, Name:string, Thm:thm}
    val record_step : (step -> thm) ref
    val record_proof : bool -> unit
    val suspend_recording : unit -> unit
    val resume_recording : unit -> unit
    val is_recording_proof : unit -> bool
    val note : step * thm -> thm
  end
val it = () : unit
GC #1.4.16.32.88.2538:   (10 ms)
GC #1.4.16.32.89.2554:   (20 ms)
[opening 0/thm.sml]
0/thm.sml:223.18-229.26 Warning: match nonexhaustive
          {thm=THM (h,c),var=var as Fv _} => ...
  
GC #1.4.16.33.90.2587:   (60 ms)
GC #1.4.16.34.91.2598:   (70 ms)
GC #1.4.16.34.92.2617:   (30 ms)
GC #1.4.17.35.93.2649:   (90 ms)
functor THM : <sig>
val it = () : unit
[opening 0/preterm.sig]
signature Preterm_sig =
  sig
    structure Term :
      sig
        structure Type : <sig>
        datatype fixity = Binder | Infix of int | Prefix
        datatype term
          = Abs of {Body:term, Bvar:term}
          | Bv of int
          | Comb of {Rand:term, Rator:term}
          | Const of {Name:string, Ty:Type.hol_type}
          | Fv of {Name:string, Ty:Type.hol_type}
          | ty_antiq of Type.hol_type
        datatype lambda
          = COMB of {Rand:term, Rator:term}
          | CONST of {Name:string, Ty:Type.hol_type}
          | LAMB of {Body:term, Bvar:term}
          | VAR of {Name:string, Ty:Type.hol_type}
        type symtab
        val symtab_copy : unit -> symtab
        val replace_symtab : symtab -> unit
        exception TERM_SYMTAB_CLASH of {common_name:string, theory1:string,
                                        theory2:string}
        val lookup_const : string -> term
        val const_decl : string -> {const:term, place:fixity, theory:string}
        datatype add_style = Defining | Loading
        val add_term_const : add_style
                             -> {const:term, place:fixity, theory:string}
                                -> unit
        val is_st_term_const : string -> bool
        val fixity_of_term : string -> fixity
        val fixity_to_string : fixity -> string
        val prec_of_term : string -> int
        val is_binder : string -> bool
        val is_infix : string -> bool
        val is_polymorphic : string -> bool
        val free_vars : term -> term list
        val free_in : term -> term -> bool
        val all_vars : term -> term list
        val free_varsl : term list -> term list
        val all_varsl : term list -> term list
        val term_lt : term -> term -> bool
        val genvar : Type.hol_type -> term
        val genvars : Type.hol_type -> int -> term list
        val variant : term list -> term -> term
        val type_of : term -> Type.hol_type
        val type_vars_in_term : term -> Type.hol_type list
        val mk_var : {Name:string, Ty:Type.hol_type} -> term
        val mk_primed_var : {Name:string, Ty:Type.hol_type} -> term
        val list_mk_comb : term * term list -> term
        val mk_comb : {Rand:term, Rator:term} -> term
        val mk_abs : {Body:term, Bvar:term} -> term
        val dest_var : term -> {Name:string, Ty:Type.hol_type}
        val dest_const : term -> {Name:string, Ty:Type.hol_type}
        val dest_comb : term -> {Rand:term, Rator:term}
        val dest_abs : term -> {Body:term, Bvar:term}
        val is_var : term -> bool
        val is_const : term -> bool
        val is_comb : term -> bool
        val is_abs : term -> bool
        val dest_term : term -> lambda
        val rator : term -> term
        val rand : term -> term
        val bvar : term -> term
        val body : term -> term
        val break_abs : term -> {Body:term, Bvar:term}
        val is_bvar : term -> bool
        val aconv : term -> term -> bool
        val subst : term subst -> term -> term
        val inst : Type.hol_type subst -> term -> term
        val beta_conv : term -> term
      end
    datatype preterm
      = Abs of {Body:preterm, Bvar:preterm}
      | Antiq of Term.term
      | Comb of {Rand:preterm, Rator:preterm}
      | Const of {Name:string, Ty:Term.Type.hol_type}
      | Constrained of preterm * Term.Type.hol_type
      | Var of {Name:string, Ty:Term.Type.hol_type}
    val TC : (int,Term.Type.hol_type) istream -> preterm -> unit
    val shrink_type : (Term.Type.hol_type * Term.Type.hol_type) list
                      -> Term.Type.hol_type -> Term.Type.hol_type
    val tyVars : preterm -> Term.Type.hol_type list
    val cleanup : preterm -> Term.term
    val typecheck : (int,Term.Type.hol_type) istream -> preterm -> Term.term
    val preterm_to_term : preterm -> Term.term
  end
GC #1.4.17.36.94.2692:   (0 ms)
signature Public_preterm_sig =
  sig
    structure Term :
      sig
        structure Type : <sig>
        datatype fixity = Binder | Infix of int | Prefix
        eqtype term
        val const_decl : string -> {const:term, place:fixity, theory:string}
        val fixity_of_term : string -> fixity
        val fixity_to_string : fixity -> string
        val prec_of_term : string -> int
        val is_binder : string -> bool
        val is_infix : string -> bool
        val is_polymorphic : string -> bool
        datatype lambda
          = COMB of {Rand:term, Rator:term}
          | CONST of {Name:string, Ty:Type.hol_type}
          | LAMB of {Body:term, Bvar:term}
          | VAR of {Name:string, Ty:Type.hol_type}
        val ty_antiq : Type.hol_type -> term
        val free_vars : term -> term list
        val free_in : term -> term -> bool
        val all_vars : term -> term list
        val free_varsl : term list -> term list
        val all_varsl : term list -> term list
        val term_lt : term -> term -> bool
        val genvar : Type.hol_type -> term
        val genvars : Type.hol_type -> int -> term list
        val variant : term list -> term -> term
        val type_of : term -> Type.hol_type
        val type_vars_in_term : term -> Type.hol_type list
        val mk_var : {Name:string, Ty:Type.hol_type} -> term
        val mk_primed_var : {Name:string, Ty:Type.hol_type} -> term
        val list_mk_comb : term * term list -> term
        val mk_comb : {Rand:term, Rator:term} -> term
        val mk_abs : {Body:term, Bvar:term} -> term
        val dest_var : term -> {Name:string, Ty:Type.hol_type}
        val dest_const : term -> {Name:string, Ty:Type.hol_type}
        val dest_comb : term -> {Rand:term, Rator:term}
        val dest_abs : term -> {Body:term, Bvar:term}
        val is_var : term -> bool
        val is_const : term -> bool
        val is_comb : term -> bool
        val is_abs : term -> bool
        val dest_term : term -> lambda
        val rator : term -> term
        val rand : term -> term
        val bvar : term -> term
        val body : term -> term
        val aconv : term -> term -> bool
        val subst : term subst -> term -> term
        val inst : Type.hol_type subst -> term -> term
        val beta_conv : term -> term
      end
    datatype preterm
      = Abs of {Body:preterm, Bvar:preterm}
      | Antiq of Term.term
      | Comb of {Rand:preterm, Rator:preterm}
      | Const of {Name:string, Ty:Term.Type.hol_type}
      | Constrained of preterm * Term.Type.hol_type
      | Var of {Name:string, Ty:Term.Type.hol_type}
    val typecheck : (int,Term.Type.hol_type) istream -> preterm -> Term.term
  end
val it = () : unit
GC #1.4.17.36.95.2749:   (50 ms)
GC #1.4.17.37.96.2760:   (50 ms)
GC #1.4.17.37.97.2799:   (30 ms)
[opening 0/preterm.sml]
functor PRETERM : <sig>
val it = () : unit
GC #1.4.18.38.98.2826:   (20 ms)
[opening Grammars/ParseBase/base.sig]
signature STREAM =
  sig
    type 'a stream
    val streamify : (unit -> 'a) -> 'a stream
    val cons : 'a * 'a stream -> 'a stream
    val get : 'a stream -> 'a * 'a stream
  end
signature LR_TABLE =
  sig
    datatype ('a,'b) pairlist = EMPTY | PAIR of 'a * 'b * ('a,'b) pairlist
    datatype state = STATE of int
    datatype term = T of int
    datatype nonterm = NT of int
    datatype action = ACCEPT | ERROR | REDUCE of int | SHIFT of state
    type table
    val numStates : table -> int
    val numRules : table -> int
    val describeActions : table -> state -> (term,action) pairlist * action
    val describeGoto : table -> state -> (nonterm,state) pairlist
    val action : table -> state * term -> action
    val goto : table -> state * nonterm -> state
    val initialState : table -> state
    exception Goto of state * nonterm
    val mkLrTable : {actions:((term,action) pairlist * action) array,
                     gotos:(nonterm,state) pairlist array, initialState:state,
                     numRules:int, numStates:int}
                    -> table
  end
signature TOKEN =
  sig
    structure LrTable :
      sig
        datatype ('a,'b) pairlist = EMPTY | PAIR of 'a * 'b * ('a,'b) pairlist
        datatype state = STATE of int
        datatype term = T of int
        datatype nonterm = NT of int
        datatype action = ACCEPT | ERROR | REDUCE of int | SHIFT of state
        type table
        val numStates : table -> int
        val numRules : table -> int
        val describeActions : table -> state -> (term,action) pairlist * action
        val describeGoto : table -> state -> (nonterm,state) pairlist
        val action : table -> state * term -> action
        val goto : table -> state * nonterm -> state
        val initialState : table -> state
        exception Goto of state * nonterm
        val mkLrTable : {actions:((term,action) pairlist * action) array,
                         gotos:(nonterm,state) pairlist array,
                         initialState:state, numRules:int, numStates:int}
                        -> table
      end
    datatype ('a,'b) token = TOKEN of LrTable.term * ('a * 'b * 'b)
    val sameToken : ('a,'b) token * ('a,'b) token -> bool
  end
signature LR_PARSER =
  sig
    structure Stream :
      sig
        type 'a stream
        val streamify : (unit -> 'a) -> 'a stream
        val cons : 'a * 'a stream -> 'a stream
        val get : 'a stream -> 'a * 'a stream
      end
    structure LrTable :
      sig
        datatype ('a,'b) pairlist = EMPTY | PAIR of 'a * 'b * ('a,'b) pairlist
        datatype state = STATE of int
        datatype term = T of int
        datatype nonterm = NT of int
        datatype action = ACCEPT | ERROR | REDUCE of int | SHIFT of state
        type table
        val numStates : table -> int
        val numRules : table -> int
        val describeActions : table -> state -> (term,action) pairlist * action
        val describeGoto : table -> state -> (nonterm,state) pairlist
        val action : table -> state * term -> action
        val goto : table -> state * nonterm -> state
        val initialState : table -> state
        exception Goto of state * nonterm
        val mkLrTable : {actions:((term,action) pairlist * action) array,
                         gotos:(nonterm,state) pairlist array,
                         initialState:state, numRules:int, numStates:int}
                        -> table
      end
    structure Token :
      sig
        structure LrTable : <sig>
        datatype ('a,'b) token = TOKEN of LrTable.term * ('a * 'b * 'b)
        val sameToken : ('a,'b) token * ('a,'b) token -> bool
      end
    exception ParseError
    val parse : {arg:'a,
                 ec:{error:string * 'c * 'c -> unit,
                     errtermvalue:LrTable.term -> 'b,
                     is_keyword:LrTable.term -> bool,
                     noShift:LrTable.term -> bool,
                     preferred_change:(LrTable.term list * LrTable.term list) 
                                        list,
                     showTerminal:LrTable.term -> string,
                     terms:LrTable.term list},
                 lexer:('b,'c) Token.token Stream.stream, lookahead:int,
                 saction:int * 'c * (LrTable.state * ('b * 'c * 'c)) list * 'a
                         -> LrTable.nonterm * ('b * 'c * 'c)
                            * (LrTable.state * ('b * 'c * 'c)) list,
                 table:LrTable.table, void:'b}
                -> 'b * ('b,'c) Token.token Stream.stream
    sharing Token.LrTable = LrTable
  end
signature LEXER =
  sig
    structure UserDeclarations :
      sig
        type ('a,'b) token
        type pos
        type svalue
      end
    val makeLexer : (int -> string)
                    -> unit
                       -> (UserDeclarations.svalue,UserDeclarations.pos) 
                            UserDeclarations.token
  end
signature ARG_LEXER =
  sig
    structure UserDeclarations :
      sig
        type ('a,'b) token
        type pos
        type svalue
        type arg
      end
    val makeLexer : (int -> string)
                    -> UserDeclarations.arg
                       -> unit
                          -> (UserDeclarations.svalue,UserDeclarations.pos) 
                               UserDeclarations.token
  end
signature PARSER_DATA =
  sig
    type pos
    type svalue
    type arg
    type result
    structure LrTable :
      sig
        datatype ('a,'b) pairlist = EMPTY | PAIR of 'a * 'b * ('a,'b) pairlist
        datatype state = STATE of int
        datatype term = T of int
        datatype nonterm = NT of int
        datatype action = ACCEPT | ERROR | REDUCE of int | SHIFT of state
        type table
        val numStates : table -> int
        val numRules : table -> int
        val describeActions : table -> state -> (term,action) pairlist * action
        val describeGoto : table -> state -> (nonterm,state) pairlist
        val action : table -> state * term -> action
        val goto : table -> state * nonterm -> state
        val initialState : table -> state
        exception Goto of state * nonterm
        val mkLrTable : {actions:((term,action) pairlist * action) array,
                         gotos:(nonterm,state) pairlist array,
                         initialState:state, numRules:int, numStates:int}
                        -> table
      end
    structure Token :
      sig
        structure LrTable : <sig>
        datatype ('a,'b) token = TOKEN of LrTable.term * ('a * 'b * 'b)
        val sameToken : ('a,'b) token * ('a,'b) token -> bool
      end
    structure Actions :
      sig
        val actions : int * pos * (LrTable.state * (svalue * pos * pos)) list
                      * arg
                      -> LrTable.nonterm * (svalue * pos * pos)
                         * (LrTable.state * (svalue * pos * pos)) list
        val void : svalue
        val extract : svalue -> result
      end
    structure EC :
      sig
        val is_keyword : LrTable.term -> bool
        val noShift : LrTable.term -> bool
        val preferred_change : (LrTable.term list * LrTable.term list) list
        val errtermvalue : LrTable.term -> svalue
        val showTerminal : LrTable.term -> string
        val terms : LrTable.term list
      end
    val table : LrTable.table
    sharing LrTable = Token.LrTable
  end
signature PARSER =
  sig
    structure Token :
      sig
        structure LrTable : <sig>
        datatype ('a,'b) token = TOKEN of LrTable.term * ('a * 'b * 'b)
        val sameToken : ('a,'b) token * ('a,'b) token -> bool
      end
    structure Stream :
      sig
        type 'a stream
        val streamify : (unit -> 'a) -> 'a stream
        val cons : 'a * 'a stream -> 'a stream
        val get : 'a stream -> 'a * 'a stream
      end
    exception ParseError
    type pos
    type result
    type arg
    type svalue
    val makeLexer : (int -> string) -> (svalue,pos) Token.token Stream.stream
    val parse : int * (svalue,pos) Token.token Stream.stream
                * (string * pos * pos -> unit) * arg
                -> result * (svalue,pos) Token.token Stream.stream
    val sameToken : (svalue,pos) Token.token * (svalue,pos) Token.token -> bool
  end
signature ARG_PARSER =
  sig
    structure Token :
      sig
        structure LrTable : <sig>
        datatype ('a,'b) token = TOKEN of LrTable.term * ('a * 'b * 'b)
        val sameToken : ('a,'b) token * ('a,'b) token -> bool
      end
    structure Stream :
      sig
        type 'a stream
        val streamify : (unit -> 'a) -> 'a stream
        val cons : 'a * 'a stream -> 'a stream
        val get : 'a stream -> 'a * 'a stream
      end
    exception ParseError
    type arg
    type lexarg
    type pos
    type result
    type svalue
    val makeLexer : (int -> string)
                    -> lexarg -> (svalue,pos) Token.token Stream.stream
    val parse : int * (svalue,pos) Token.token Stream.stream
                * (string * pos * pos -> unit) * arg
                -> result * (svalue,pos) Token.token Stream.stream
    val sameToken : (svalue,pos) Token.token * (svalue,pos) Token.token -> bool
  end
val it = () : unit
[opening Grammars/ParseBase/join.sml]
functor Join : <sig>
functor JoinWithArg : <sig>
val it = () : unit
GC #1.4.18.38.99.2875:   (20 ms)
[opening Grammars/ParseBase/lrtable.sml]
structure LrTable : LR_TABLE
val it = () : unit
[opening Grammars/ParseBase/stream.sml]
structure Stream : STREAM
val it = () : unit
[opening Grammars/ParseBase/parser1.sml]
Grammars/ParseBase/parser1.sml:98.11-99.35 Warning: binding not exhaustive
          (nonterm,value,stack as (state,_) :: _) = ...
Grammars/ParseBase/parser1.sml:106.27-106.62 Warning: binding not exhaustive
          (_,(topvalue,_,_)) :: _ = ...
Grammars/ParseBase/parser1.sml:91.7-109.10 Warning: match nonexhaustive
          (next as (TOKEN (terminal,value as (_,leftPos,_)),lexer),
           stack as (state,_) :: _) => ...
  
GC #1.4.18.38.100.2917:   (30 ms)
structure LrParser : LR_PARSER
val it = () : unit
[opening 0/uid.sig]
signature Uid_sig =
  sig
    type uid
    val mk_uid : string -> uid
    val re_mk_uid : {name:string, timestamp:time} -> uid
    val dest_uid : uid -> {name:string, timestamp:time}
    val name : uid -> string
    val timestamp : uid -> time
    val eq : uid * uid -> bool
  end
val it = () : unit
[opening 0/uid.sml]
functor UID : <sig>
val it = () : unit
[opening 0/theory/data.sig]
signature Theory_data_sig =
  sig
    structure Thm :
      sig
        structure Term : <sig>
        type thm
        val reset_thm_count : unit -> unit
        val counting_thms : bool -> unit
        val thm_count : unit
                        -> {ABS:int, ASSUME:int, BETA_CONV:int, DISCH:int,
                            INST_TYPE:int, MP:int, REFL:int, SUBST:int,
                            axiom:int, definition:int, drule:int,
                            from_disk:int, other:int, valid_tac:int}
        val hyp : thm -> Term.term list
        val concl : thm -> Term.term
        val dest_thm : thm -> Term.term list * Term.term
        val thm_free_vars : thm -> Term.term list
        val hyp_union : thm list -> Term.term list
        val pp_thm : ?.PrettyPrint.ppstream -> thm -> unit
        val thm_to_string : thm -> string
        val print_thm : thm -> unit
        val ASSUME : Term.term -> thm
        val REFL : Term.term -> thm
        val BETA_CONV : Term.term -> thm
        val SUBST : {thm:thm, var:Term.term} list -> Term.term -> thm -> thm
        val ABS : Term.term -> thm -> thm
        val INST_TYPE : Term.Type.hol_type subst -> thm -> thm
        val DISCH : Term.term -> thm -> thm
        val MP : thm -> thm -> thm
        val mk_axiom_thm : Term.term list * Term.term -> thm
        val mk_definition_thm : Term.term list * Term.term -> thm
        val mk_drule_thm : Term.term list * Term.term -> thm
        val mk_disk_thm : Term.term list * Term.term -> thm
        val mk_tac_thm : Term.term list * Term.term -> thm
        val mk_thm : Term.term list * Term.term -> thm
        datatype just_arg
          = JA_INT of int
          | JA_INTLIST of int list
          | JA_PAIR of just_arg * just_arg
          | JA_STRING of string
          | JA_TERM of Term.term
          | JA_THM of thm
          | JA_TYPE of Term.Type.hol_type
        datatype step = STEP of {Just:just_arg list, Name:string, Thm:thm}
        val record_step : (step -> thm) ref
        val record_proof : bool -> unit
        val suspend_recording : unit -> unit
        val resume_recording : unit -> unit
        val is_recording_proof : unit -> bool
        val note : step * thm -> thm
      end
    type theory
    type theory_id
    val mk_theory_id : {name:string, timestamp:time} -> theory_id
    val theory_id : theory -> theory_id
    val theory_id_name : theory_id -> string
    val theory_id_timestamp : theory_id -> time
    val theory_id_eq : theory_id * theory_id -> bool
    val theory_draft_mode : theory -> bool
    val theory_consistent_with_disk : theory -> bool
    val theory_parents : theory -> theory_id list
    val theory_type_constants : theory
                                -> {arity:int, theory:string,
                                    tyc:Thm.Term.Type.hol_type} list
    val theory_term_constants : theory
                                -> {const:Thm.Term.term, place:Thm.Term.fixity,
                                    theory:string} list
    val theory_axioms : theory -> (string * Thm.thm) list
    val theory_definitions : theory -> (string * Thm.thm) list
    val theory_theorems : theory -> (string * Thm.thm) list
    val mk_theory : theory_id -> theory
    val fresh_theory : string -> theory
    val the_current_theory : unit -> theory
    val make_current : theory -> unit
    val set_draft_mode : bool -> theory -> theory
    val set_consistency_with_disk : bool -> theory -> theory
    val add_parent : theory_id -> theory -> theory
    val add_type : {arity:int, theory:string, tyc:Thm.Term.Type.hol_type}
                   -> theory -> theory
    val add_term : {const:Thm.Term.term, place:Thm.Term.fixity, theory:string}
                   -> theory -> theory
    val add_axiom : string * Thm.thm -> theory -> theory
    val add_definition : string * Thm.thm -> theory -> theory
    val add_theorem : string * Thm.thm -> theory -> theory
    val pp_theory : ?.PrettyPrint.ppstream -> theory -> unit
  end
val it = () : unit
GC #1.4.18.39.101.2950:   (20 ms)
GC #1.4.18.39.102.2999:   (40 ms)
GC #1.4.18.39.103.3006:   (50 ms)
GC #1.4.18.39.104.3018:   (10 ms)
[opening 0/theory/data.sml]
functor THEORY_DATA : <sig>
val it = () : unit
[opening 0/theory/thy_pp.sig]
signature Thy_pp_sig =
  sig
    structure Term :
      sig
        structure Type : <sig>
        datatype fixity = Binder | Infix of int | Prefix
        eqtype term
        val const_decl : string -> {const:term, place:fixity, theory:string}
        val fixity_of_term : string -> fixity
        val fixity_to_string : fixity -> string
        val prec_of_term : string -> int
        val is_binder : string -> bool
        val is_infix : string -> bool
        val is_polymorphic : string -> bool
        datatype lambda
          = COMB of {Rand:term, Rator:term}
          | CONST of {Name:string, Ty:Type.hol_type}
          | LAMB of {Body:term, Bvar:term}
          | VAR of {Name:string, Ty:Type.hol_type}
        val ty_antiq : Type.hol_type -> term
        val free_vars : term -> term list
        val free_in : term -> term -> bool
        val all_vars : term -> term list
        val free_varsl : term list -> term list
        val all_varsl : term list -> term list
        val term_lt : term -> term -> bool
        val genvar : Type.hol_type -> term
        val genvars : Type.hol_type -> int -> term list
        val variant : term list -> term -> term
        val type_of : term -> Type.hol_type
        val type_vars_in_term : term -> Type.hol_type list
        val mk_var : {Name:string, Ty:Type.hol_type} -> term
        val mk_primed_var : {Name:string, Ty:Type.hol_type} -> term
        val list_mk_comb : term * term list -> term
        val mk_comb : {Rand:term, Rator:term} -> term
        val mk_abs : {Body:term, Bvar:term} -> term
        val dest_var : term -> {Name:string, Ty:Type.hol_type}
        val dest_const : term -> {Name:string, Ty:Type.hol_type}
        val dest_comb : term -> {Rand:term, Rator:term}
        val dest_abs : term -> {Body:term, Bvar:term}
        val is_var : term -> bool
        val is_const : term -> bool
        val is_comb : term -> bool
        val is_abs : term -> bool
        val dest_term : term -> lambda
        val rator : term -> term
        val rand : term -> term
        val bvar : term -> term
        val body : term -> term
        val aconv : term -> term -> bool
        val subst : term subst -> term -> term
        val inst : Type.hol_type subst -> term -> term
        val beta_conv : term -> term
      end
    val pp_type_rep : ?.PrettyPrint.ppstream -> Term.Type.hol_type -> unit
    val pp_term : ?.PrettyPrint.ppstream -> Term.term -> unit
  end
val it = () : unit
GC #1.4.18.39.105.3068:   (10 ms)
[opening 0/theory/thy_pp.sml]
functor THY_PP : <sig>
val it = () : unit
[opening Grammars/thy.yak.sig]
signature thy_TOKENS =
  sig
    type ('a,'b) token
    type svalue
    val EOF : 'a * 'a -> (svalue,'a) token
    val EOLEX : 'a * 'a -> (svalue,'a) token
    val string_ : string * 'a * 'a -> (svalue,'a) token
    val type_plus : 'a * 'a -> (svalue,'a) token
    val type_hash : 'a * 'a -> (svalue,'a) token
    val type_right_arrow : 'a * 'a -> (svalue,'a) token
    val dot : 'a * 'a -> (svalue,'a) token
    val colon : 'a * 'a -> (svalue,'a) token
    val type_comma : 'a * 'a -> (svalue,'a) token
    val type_rparen : 'a * 'a -> (svalue,'a) token
    val type_lparen : 'a * 'a -> (svalue,'a) token
    val rparen : 'a * 'a -> (svalue,'a) token
    val lparen : 'a * 'a -> (svalue,'a) token
    val num : string * 'a * 'a -> (svalue,'a) token
    val db_index : int * 'a * 'a -> (svalue,'a) token
    val lambda : 'a * 'a -> (svalue,'a) token
    val type_var_ident : string * 'a * 'a -> (svalue,'a) token
    val type_ident : string * 'a * 'a -> (svalue,'a) token
    val ident : string * 'a * 'a -> (svalue,'a) token
  end
signature thy_LRVALS =
  sig
    structure Tokens :
      sig
        type ('a,'b) token
        type svalue
        val EOF : 'a * 'a -> (svalue,'a) token
        val EOLEX : 'a * 'a -> (svalue,'a) token
        val string_ : string * 'a * 'a -> (svalue,'a) token
        val type_plus : 'a * 'a -> (svalue,'a) token
        val type_hash : 'a * 'a -> (svalue,'a) token
        val type_right_arrow : 'a * 'a -> (svalue,'a) token
        val dot : 'a * 'a -> (svalue,'a) token
        val colon : 'a * 'a -> (svalue,'a) token
        val type_comma : 'a * 'a -> (svalue,'a) token
        val type_rparen : 'a * 'a -> (svalue,'a) token
        val type_lparen : 'a * 'a -> (svalue,'a) token
        val rparen : 'a * 'a -> (svalue,'a) token
        val lparen : 'a * 'a -> (svalue,'a) token
        val num : string * 'a * 'a -> (svalue,'a) token
        val db_index : int * 'a * 'a -> (svalue,'a) token
        val lambda : 'a * 'a -> (svalue,'a) token
        val type_var_ident : string * 'a * 'a -> (svalue,'a) token
        val type_ident : string * 'a * 'a -> (svalue,'a) token
        val ident : string * 'a * 'a -> (svalue,'a) token
      end
    structure ParserData :
      sig
        type pos
        type svalue
        type arg
        type result
        structure LrTable : <sig>
        structure Token : <sig>
        structure Actions : <sig>
        structure EC : <sig>
        val table : LrTable.table
        sharing LrTable = Token.LrTable
      end
    sharing type Tokens.svalue = ParserData.svalue
    sharing type Tokens.token = ParserData.Token.token
  end
val it = () : unit
GC #1.4.18.39.106.3132:   (30 ms)
GC #1.4.18.40.107.3184:   (100 ms)
GC #1.4.18.40.108.3194:   (90 ms)
GC #1.4.18.41.109.3213:   (110 ms)
GC #1.4.18.41.110.3245:   (10 ms)
[opening Grammars/thy.yak.sml]
functor thyLrValsFun : <sig>
val it = () : unit
[opening 0/theory/thy_parse.sig]
signature Thy_parse_sig =
  sig
    structure Term :
      sig
        structure Type : <sig>
        datatype fixity = Binder | Infix of int | Prefix
        datatype term
          = Abs of {Body:term, Bvar:term}
          | Bv of int
          | Comb of {Rand:term, Rator:term}
          | Const of {Name:string, Ty:Type.hol_type}
          | Fv of {Name:string, Ty:Type.hol_type}
          | ty_antiq of Type.hol_type
        datatype lambda
          = COMB of {Rand:term, Rator:term}
          | CONST of {Name:string, Ty:Type.hol_type}
          | LAMB of {Body:term, Bvar:term}
          | VAR of {Name:string, Ty:Type.hol_type}
        type symtab
        val symtab_copy : unit -> symtab
        val replace_symtab : symtab -> unit
        exception TERM_SYMTAB_CLASH of {common_name:string, theory1:string,
                                        theory2:string}
        val lookup_const : string -> term
        val const_decl : string -> {const:term, place:fixity, theory:string}
        datatype add_style = Defining | Loading
        val add_term_const : add_style
                             -> {const:term, place:fixity, theory:string}
                                -> unit
        val is_st_term_const : string -> bool
        val fixity_of_term : string -> fixity
        val fixity_to_string : fixity -> string
        val prec_of_term : string -> int
        val is_binder : string -> bool
        val is_infix : string -> bool
        val is_polymorphic : string -> bool
        val free_vars : term -> term list
        val free_in : term -> term -> bool
        val all_vars : term -> term list
        val free_varsl : term list -> term list
        val all_varsl : term list -> term list
        val term_lt : term -> term -> bool
        val genvar : Type.hol_type -> term
        val genvars : Type.hol_type -> int -> term list
        val variant : term list -> term -> term
        val type_of : term -> Type.hol_type
        val type_vars_in_term : term -> Type.hol_type list
        val mk_var : {Name:string, Ty:Type.hol_type} -> term
        val mk_primed_var : {Name:string, Ty:Type.hol_type} -> term
        val list_mk_comb : term * term list -> term
        val mk_comb : {Rand:term, Rator:term} -> term
        val mk_abs : {Body:term, Bvar:term} -> term
        val dest_var : term -> {Name:string, Ty:Type.hol_type}
        val dest_const : term -> {Name:string, Ty:Type.hol_type}
        val dest_comb : term -> {Rand:term, Rator:term}
        val dest_abs : term -> {Body:term, Bvar:term}
        val is_var : term -> bool
        val is_const : term -> bool
        val is_comb : term -> bool
        val is_abs : term -> bool
        val dest_term : term -> lambda
        val rator : term -> term
        val rand : term -> term
        val bvar : term -> term
        val body : term -> term
        val break_abs : term -> {Body:term, Bvar:term}
        val is_bvar : term -> bool
        val aconv : term -> term -> bool
        val subst : term subst -> term -> term
        val inst : Type.hol_type subst -> term -> term
        val beta_conv : term -> term
      end
    val theory_term_parser : string -> Term.term
  end
val it = () : unit
GC #1.4.18.41.111.3285:   (10 ms)
[opening 0/theory/thy_parse.sml]
functor THY_PARSE : <sig>
val it = () : unit
GC #1.4.18.41.112.3336:   (30 ms)
GC #1.4.18.41.113.3352:   (40 ms)
GC #1.4.18.41.114.3365:   (40 ms)
GC #1.4.18.41.115.3415:   (30 ms)
[opening Grammars/thy.lex.sml]
functor THY_LEX : <sig>
val it = () : unit
[opening Grammars/thms.yak.sig]
signature thms_TOKENS =
  sig
    type ('a,'b) token
    type svalue
    val EOF : 'a * 'a -> (svalue,'a) token
    val EOLEX : 'a * 'a -> (svalue,'a) token
    val num : string * 'a * 'a -> (svalue,'a) token
    val id : string * 'a * 'a -> (svalue,'a) token
    val quote : string * 'a * 'a -> (svalue,'a) token
    val theorems : 'a * 'a -> (svalue,'a) token
    val definitions : 'a * 'a -> (svalue,'a) token
    val axioms : 'a * 'a -> (svalue,'a) token
    val thid : 'a * 'a -> (svalue,'a) token
    val eq : 'a * 'a -> (svalue,'a) token
    val comma : 'a * 'a -> (svalue,'a) token
    val rbracket : 'a * 'a -> (svalue,'a) token
    val lbracket : 'a * 'a -> (svalue,'a) token
    val rparen : 'a * 'a -> (svalue,'a) token
    val lparen : 'a * 'a -> (svalue,'a) token
  end
signature thms_LRVALS =
  sig
    structure Tokens :
      sig
        type ('a,'b) token
        type svalue
        val EOF : 'a * 'a -> (svalue,'a) token
        val EOLEX : 'a * 'a -> (svalue,'a) token
        val num : string * 'a * 'a -> (svalue,'a) token
        val id : string * 'a * 'a -> (svalue,'a) token
        val quote : string * 'a * 'a -> (svalue,'a) token
        val theorems : 'a * 'a -> (svalue,'a) token
        val definitions : 'a * 'a -> (svalue,'a) token
        val axioms : 'a * 'a -> (svalue,'a) token
        val thid : 'a * 'a -> (svalue,'a) token
        val eq : 'a * 'a -> (svalue,'a) token
        val comma : 'a * 'a -> (svalue,'a) token
        val rbracket : 'a * 'a -> (svalue,'a) token
        val lbracket : 'a * 'a -> (svalue,'a) token
        val rparen : 'a * 'a -> (svalue,'a) token
        val lparen : 'a * 'a -> (svalue,'a) token
      end
    structure ParserData :
      sig
        type pos
        type svalue
        type arg
        type result
        structure LrTable : <sig>
        structure Token : <sig>
        structure Actions : <sig>
        structure EC : <sig>
        val table : LrTable.table
        sharing LrTable = Token.LrTable
      end
    sharing type Tokens.svalue = ParserData.svalue
    sharing type Tokens.token = ParserData.Token.token
  end
val it = () : unit
GC #1.4.18.41.116.3442:   (10 ms)
GC #1.4.18.41.117.3490:   (40 ms)
GC #1.4.18.41.118.3511:   (60 ms)
GC #1.4.18.41.119.3525:   (70 ms)
GC #1.4.19.42.120.3546:   (80 ms)
GC #1.4.19.42.121.3581:   (20 ms)
[opening Grammars/thms.yak.sml]
functor thmsLrValsFun : <sig>
val it = () : unit
[opening Grammars/holsig.yak.sig]
signature holsig_TOKENS =
  sig
    type ('a,'b) token
    type svalue
    val EOF : 'a * 'a -> (svalue,'a) token
    val EOLEX : 'a * 'a -> (svalue,'a) token
    val num : string * 'a * 'a -> (svalue,'a) token
    val id : string * 'a * 'a -> (svalue,'a) token
    val string_constant : string * 'a * 'a -> (svalue,'a) token
    val symbolic : string * 'a * 'a -> (svalue,'a) token
    val type_var : string * 'a * 'a -> (svalue,'a) token
    val constants : 'a * 'a -> (svalue,'a) token
    val types : 'a * 'a -> (svalue,'a) token
    val parents : 'a * 'a -> (svalue,'a) token
    val Infix : 'a * 'a -> (svalue,'a) token
    val Prefix : 'a * 'a -> (svalue,'a) token
    val Binder : 'a * 'a -> (svalue,'a) token
    val fixity : 'a * 'a -> (svalue,'a) token
    val ty : 'a * 'a -> (svalue,'a) token
    val name : 'a * 'a -> (svalue,'a) token
    val thid : 'a * 'a -> (svalue,'a) token
    val eq : 'a * 'a -> (svalue,'a) token
    val comma : 'a * 'a -> (svalue,'a) token
    val rparen : 'a * 'a -> (svalue,'a) token
    val lparen : 'a * 'a -> (svalue,'a) token
    val rbracket : 'a * 'a -> (svalue,'a) token
    val lbracket : 'a * 'a -> (svalue,'a) token
    val rbrace : 'a * 'a -> (svalue,'a) token
    val lbrace : 'a * 'a -> (svalue,'a) token
  end
signature holsig_LRVALS =
  sig
    structure Tokens :
      sig
        type ('a,'b) token
        type svalue
        val EOF : 'a * 'a -> (svalue,'a) token
        val EOLEX : 'a * 'a -> (svalue,'a) token
        val num : string * 'a * 'a -> (svalue,'a) token
        val id : string * 'a * 'a -> (svalue,'a) token
        val string_constant : string * 'a * 'a -> (svalue,'a) token
        val symbolic : string * 'a * 'a -> (svalue,'a) token
        val type_var : string * 'a * 'a -> (svalue,'a) token
        val constants : 'a * 'a -> (svalue,'a) token
        val types : 'a * 'a -> (svalue,'a) token
        val parents : 'a * 'a -> (svalue,'a) token
        val Infix : 'a * 'a -> (svalue,'a) token
        val Prefix : 'a * 'a -> (svalue,'a) token
        val Binder : 'a * 'a -> (svalue,'a) token
        val fixity : 'a * 'a -> (svalue,'a) token
        val ty : 'a * 'a -> (svalue,'a) token
        val name : 'a * 'a -> (svalue,'a) token
        val thid : 'a * 'a -> (svalue,'a) token
        val eq : 'a * 'a -> (svalue,'a) token
        val comma : 'a * 'a -> (svalue,'a) token
        val rparen : 'a * 'a -> (svalue,'a) token
        val lparen : 'a * 'a -> (svalue,'a) token
        val rbracket : 'a * 'a -> (svalue,'a) token
        val lbracket : 'a * 'a -> (svalue,'a) token
        val rbrace : 'a * 'a -> (svalue,'a) token
        val lbrace : 'a * 'a -> (svalue,'a) token
      end
    structure ParserData :
      sig
        type pos
        type svalue
        type arg
        type result
        structure LrTable : <sig>
        structure Token : <sig>
        structure Actions : <sig>
        structure EC : <sig>
        val table : LrTable.table
        sharing LrTable = Token.LrTable
      end
    sharing type Tokens.svalue = ParserData.svalue
    sharing type Tokens.token = ParserData.Token.token
  end
val it = () : unit
GC #1.4.19.42.122.3613:   (10 ms)
GC #1.4.19.42.123.3647:   (40 ms)
GC #1.4.19.42.124.3693:   (80 ms)
GC #1.4.19.42.125.3712:   (60 ms)
GC #1.4.19.42.126.3733:   (70 ms)
GC #1.4.19.43.127.3746:   (160 ms)
GC #1.4.19.44.128.3788:   (110 ms)
GC #1.4.19.44.129.3843:   (40 ms)
[opening Grammars/holsig.yak.sml]
functor holsigLrValsFun : <sig>
val it = () : unit
GC #1.4.19.44.130.3860:   (0 ms)
[opening 0/theory/regime.sig]
signature Regime_sig =
  sig
    structure Theory_data :
      sig
        structure Thm : <sig>
        type theory
        type theory_id
        val mk_theory_id : {name:string, timestamp:time} -> theory_id
        val theory_id : theory -> theory_id
        val theory_id_name : theory_id -> string
        val theory_id_timestamp : theory_id -> time
        val theory_id_eq : theory_id * theory_id -> bool
        val theory_draft_mode : theory -> bool
        val theory_consistent_with_disk : theory -> bool
        val theory_parents : theory -> theory_id list
        val theory_type_constants : theory
                                    -> {arity:int, theory:string,
                                        tyc:Thm.Term.Type.hol_type} list
        val theory_term_constants : theory
                                    -> {const:Thm.Term.term,
                                        place:Thm.Term.fixity, theory:string} 
                                         list
        val theory_axioms : theory -> (string * Thm.thm) list
        val theory_definitions : theory -> (string * Thm.thm) list
        val theory_theorems : theory -> (string * Thm.thm) list
        val mk_theory : theory_id -> theory
        val fresh_theory : string -> theory
        val the_current_theory : unit -> theory
        val make_current : theory -> unit
        val set_draft_mode : bool -> theory -> theory
        val set_consistency_with_disk : bool -> theory -> theory
        val add_parent : theory_id -> theory -> theory
        val add_type : {arity:int, theory:string, tyc:Thm.Term.Type.hol_type}
                       -> theory -> theory
        val add_term : {const:Thm.Term.term, place:Thm.Term.fixity,
                        theory:string}
                       -> theory -> theory
        val add_axiom : string * Thm.thm -> theory -> theory
        val add_definition : string * Thm.thm -> theory -> theory
        val add_theorem : string * Thm.thm -> theory -> theory
        val pp_theory : ?.PrettyPrint.ppstream -> theory -> unit
      end
    type hol_sig
    type hol_thms
    val dest_hol_sig : hol_sig
                       -> {parents:Theory_data.theory_id list,
                           term_constants:{const:Theory_data.Thm.Term.term,
                                           place:Theory_data.Thm.Term.fixity,
                                           theory:string} list,
                           thid:Theory_data.theory_id,
                           type_constants:{arity:int, theory:string,
                                           tyc:
                                                 Theory_data.Thm.Term.Type.hol_type}
                                            list}
    val mk_hol_sig : {parents:Theory_data.theory_id list,
                      term_constants:{const:Theory_data.Thm.Term.term,
                                      place:Theory_data.Thm.Term.fixity,
                                      theory:string} list,
                      thid:Theory_data.theory_id,
                      type_constants:{arity:int, theory:string,
                                      tyc:Theory_data.Thm.Term.Type.hol_type} 
                                       list}
                     -> hol_sig
    val dest_hol_thms : hol_thms
                        -> {axioms:(string * Theory_data.Thm.thm) list,
                            definitions:(string * Theory_data.Thm.thm) list,
                            theorems:(string * Theory_data.Thm.thm) list,
                            thid:Theory_data.theory_id}
    val mk_hol_thms : {axioms:(string * Theory_data.Thm.thm) list,
                       definitions:(string * Theory_data.Thm.thm) list,
                       theorems:(string * Theory_data.Thm.thm) list,
                       thid:Theory_data.theory_id}
                      -> hol_thms
    val split_theory : Theory_data.theory -> hol_sig * hol_thms
    val mk_theory_from_parts : hol_sig -> hol_thms -> Theory_data.theory
    val theory_to_hol_sig : Theory_data.theory -> hol_sig
  end
val it = () : unit
[opening 0/theory/disk_io.sig]
signature Disk_io_sig =
  sig
    structure Regime :
      sig
        structure Theory_data : <sig>
        type hol_sig
        type hol_thms
        val dest_hol_sig : hol_sig
                           -> {parents:Theory_data.theory_id list,
                               term_constants:{const:Theory_data.Thm.Term.term,
                                               place:
                          Theory_data.Thm.Term.fixity, theory:string} list,
                               thid:Theory_data.theory_id,
                               type_constants:{arity:int, theory:string,
                                               tyc:
                          Theory_data.Thm.Term.Type.hol_type} list}
        val mk_hol_sig : {parents:Theory_data.theory_id list,
                          term_constants:{const:Theory_data.Thm.Term.term,
                                          place:Theory_data.Thm.Term.fixity,
                                          theory:string} list,
                          thid:Theory_data.theory_id,
                          type_constants:{arity:int, theory:string,
                                          tyc:
                                                Theory_data.Thm.Term.Type.hol_type}
                                           list}
                         -> hol_sig
        val dest_hol_thms : hol_thms
                            -> {axioms:(string * Theory_data.Thm.thm) list,
                                definitions:(string * Theory_data.Thm.thm) 
                                              list,
                                theorems:(string * Theory_data.Thm.thm) list,
                                thid:Theory_data.theory_id}
        val mk_hol_thms : {axioms:(string * Theory_data.Thm.thm) list,
                           definitions:(string * Theory_data.Thm.thm) list,
                           theorems:(string * Theory_data.Thm.thm) list,
                           thid:Theory_data.theory_id}
                          -> hol_thms
        val split_theory : Theory_data.theory -> hol_sig * hol_thms
        val mk_theory_from_parts : hol_sig -> hol_thms -> Theory_data.theory
        val theory_to_hol_sig : Theory_data.theory -> hol_sig
      end
    val read_hol_sig : Portable.instream -> Regime.hol_sig
    val write_hol_sig : Portable.outstream * Regime.hol_sig -> unit
    val read_hol_thms : Portable.instream -> Regime.hol_thms
    val write_hol_thms : Portable.outstream * Regime.hol_thms -> unit
  end
val it = () : unit
[opening 0/theory/disk_io.ascii.sml]
0/theory/disk_io.ascii.sml:98.15-98.63 Warning: binding not exhaustive
          {Args=nil,Tyop=Tyop} = ...
GC #1.4.19.44.131.3896:   (40 ms)
GC #1.4.19.44.132.3910:   (50 ms)
GC #1.4.19.44.133.3950:   (40 ms)
functor DISK_IO_ASCII : <sig>
val it = () : unit
GC #1.4.19.44.134.3990:   (30 ms)
[opening 0/theory/regime.sml]
functor REGIME : <sig>
val it = () : unit
GC #1.4.19.44.135.4038:   (40 ms)
GC #1.4.19.44.136.4054:   (40 ms)
GC #1.4.19.44.137.4067:   (30 ms)
GC #1.4.19.45.138.4125:   (110 ms)
[opening Grammars/thms.lex.sml]
functor THMS_LEX : <sig>
val it = () : unit
GC #1.4.19.45.139.4145:   (10 ms)
GC #1.4.19.45.140.4190:   (30 ms)
GC #1.4.19.45.141.4210:   (60 ms)
GC #1.4.19.45.142.4234:   (40 ms)
GC #1.4.19.45.143.4251:   (30 ms)
GC #1.4.19.45.144.4371:   (40 ms)
GC #1.4.19.45.145.4394:   (0 ms)
[opening Grammars/holsig.lex.sml]
functor HOLSIG_LEX : <sig>
val it = () : unit
[opening 0/cache.sml]
signature Key_sig =
  sig
    type object
    eqtype key
    val key_of : object -> key
  end
functor CACHE : <sig>
val it = () : unit
[opening 0/theory/cache.sig]
signature Theory_cache_sig =
  sig
    type object
    eqtype key
    val add_object_to_cache : object -> unit
    val get_object_from_cache : key -> object
    val delete_object_from_cache : key -> unit
    val delete_cache : unit -> unit
    val objects_in_cache : unit -> key list
    val is_object_in_cache : key -> bool
  end
val it = () : unit
[opening 0/theory/graph.sml]
signature Node_sig =
  sig
    type node_id
    val node_name : node_id -> string
    val node_eq : node_id -> node_id -> bool
  end
GC #1.4.20.46.146.4443:   (80 ms)
functor DAG : <sig>
val it = () : unit
[opening 0/theory/graph.sig]
signature Theory_graph_sig =
  sig
    type node_id
    type graph
    val add_node : node_id -> node_id list -> unit
    val node_in_graph : node_id -> bool
    val is_ancestor : string -> bool
    val add_parent : node_id -> node_id -> unit
    val graph_copy : unit -> graph
    val replace_graph : graph -> unit
    val parents : string -> node_id list
    val ancestry : string -> node_id list
  end
val it = () : unit
[opening 0/theory/io.sig]
signature Theory_io_sig =
  sig
    structure Theory_data :
      sig
        structure Thm : <sig>
        type theory
        type theory_id
        val mk_theory_id : {name:string, timestamp:time} -> theory_id
        val theory_id : theory -> theory_id
        val theory_id_name : theory_id -> string
        val theory_id_timestamp : theory_id -> time
        val theory_id_eq : theory_id * theory_id -> bool
        val theory_draft_mode : theory -> bool
        val theory_consistent_with_disk : theory -> bool
        val theory_parents : theory -> theory_id list
        val theory_type_constants : theory
                                    -> {arity:int, theory:string,
                                        tyc:Thm.Term.Type.hol_type} list
        val theory_term_constants : theory
                                    -> {const:Thm.Term.term,
                                        place:Thm.Term.fixity, theory:string} 
                                         list
        val theory_axioms : theory -> (string * Thm.thm) list
        val theory_definitions : theory -> (string * Thm.thm) list
        val theory_theorems : theory -> (string * Thm.thm) list
        val mk_theory : theory_id -> theory
        val fresh_theory : string -> theory
        val the_current_theory : unit -> theory
        val make_current : theory -> unit
        val set_draft_mode : bool -> theory -> theory
        val set_consistency_with_disk : bool -> theory -> theory
        val add_parent : theory_id -> theory -> theory
        val add_type : {arity:int, theory:string, tyc:Thm.Term.Type.hol_type}
                       -> theory -> theory
        val add_term : {const:Thm.Term.term, place:Thm.Term.fixity,
                        theory:string}
                       -> theory -> theory
        val add_axiom : string * Thm.thm -> theory -> theory
        val add_definition : string * Thm.thm -> theory -> theory
        val add_theorem : string * Thm.thm -> theory -> theory
        val pp_theory : ?.PrettyPrint.ppstream -> theory -> unit
      end
    type hol_sig
    type hol_thms
    val dest_hol_sig : hol_sig
                       -> {parents:Theory_data.theory_id list,
                           term_constants:{const:Theory_data.Thm.Term.term,
                                           place:Theory_data.Thm.Term.fixity,
                                           theory:string} list,
                           thid:Theory_data.theory_id,
                           type_constants:{arity:int, theory:string,
                                           tyc:
                                                 Theory_data.Thm.Term.Type.hol_type}
                                            list}
    val theory_to_hol_sig : Theory_data.theory -> hol_sig
    val get_hol_sig_by_name : string list
                              -> string -> {data:hol_sig, path:string}
    val get_hol_sig_by_uid : string list
                             -> Theory_data.theory_id
                                -> {data:hol_sig, path:string}
    val get_thms : string list
                   -> Theory_data.theory_id -> {data:hol_thms, path:string}
    val mk_theory : hol_sig -> hol_thms -> Theory_data.theory
    val put_theory_to_disk : Theory_data.theory -> unit
  end
val it = () : unit
GC #1.4.20.46.147.4501:   (30 ms)
[opening 0/theory/io.sml]
functor THEORY_IO : <sig>
val it = () : unit
[opening 0/theory/ops.sig]
signature Theory_ops_sig =
  sig
    structure Theory_data :
      sig
        structure Thm : <sig>
        type theory
        type theory_id
        val mk_theory_id : {name:string, timestamp:time} -> theory_id
        val theory_id : theory -> theory_id
        val theory_id_name : theory_id -> string
        val theory_id_timestamp : theory_id -> time
        val theory_id_eq : theory_id * theory_id -> bool
        val theory_draft_mode : theory -> bool
        val theory_consistent_with_disk : theory -> bool
        val theory_parents : theory -> theory_id list
        val theory_type_constants : theory
                                    -> {arity:int, theory:string,
                                        tyc:Thm.Term.Type.hol_type} list
        val theory_term_constants : theory
                                    -> {const:Thm.Term.term,
                                        place:Thm.Term.fixity, theory:string} 
                                         list
        val theory_axioms : theory -> (string * Thm.thm) list
        val theory_definitions : theory -> (string * Thm.thm) list
        val theory_theorems : theory -> (string * Thm.thm) list
        val mk_theory : theory_id -> theory
        val fresh_theory : string -> theory
        val the_current_theory : unit -> theory
        val make_current : theory -> unit
        val set_draft_mode : bool -> theory -> theory
        val set_consistency_with_disk : bool -> theory -> theory
        val add_parent : theory_id -> theory -> theory
        val add_type : {arity:int, theory:string, tyc:Thm.Term.Type.hol_type}
                       -> theory -> theory
        val add_term : {const:Thm.Term.term, place:Thm.Term.fixity,
                        theory:string}
                       -> theory -> theory
        val add_axiom : string * Thm.thm -> theory -> theory
        val add_definition : string * Thm.thm -> theory -> theory
        val add_theorem : string * Thm.thm -> theory -> theory
        val pp_theory : ?.PrettyPrint.ppstream -> theory -> unit
      end
    structure Theory_io :
      sig
        structure Theory_data : <sig>
        type hol_sig
        type hol_thms
        val dest_hol_sig : hol_sig
                           -> {parents:Theory_data.theory_id list,
                               term_constants:{const:Theory_data.Thm.Term.term,
                                               place:
                          Theory_data.Thm.Term.fixity, theory:string} list,
                               thid:Theory_data.theory_id,
                               type_constants:{arity:int, theory:string,
                                               tyc:
                          Theory_data.Thm.Term.Type.hol_type} list}
        val theory_to_hol_sig : Theory_data.theory -> hol_sig
        val get_hol_sig_by_name : string list
                                  -> string -> {data:hol_sig, path:string}
        val get_hol_sig_by_uid : string list
                                 -> Theory_data.theory_id
                                    -> {data:hol_sig, path:string}
        val get_thms : string list
                       -> Theory_data.theory_id -> {data:hol_thms, path:string}
        val mk_theory : hol_sig -> hol_thms -> Theory_data.theory
        val put_theory_to_disk : Theory_data.theory -> unit
      end
    structure Theory_cache :
      sig
        type object
        eqtype key
        val add_object_to_cache : object -> unit
        val get_object_from_cache : key -> object
        val delete_object_from_cache : key -> unit
        val delete_cache : unit -> unit
        val objects_in_cache : unit -> key list
        val is_object_in_cache : key -> bool
      end
    structure Theory_graph :
      sig
        type node_id
        type graph
        val add_node : node_id -> node_id list -> unit
        val node_in_graph : node_id -> bool
        val is_ancestor : string -> bool
        val add_parent : node_id -> node_id -> unit
        val graph_copy : unit -> graph
        val replace_graph : graph -> unit
        val parents : string -> node_id list
        val ancestry : string -> node_id list
      end
    val grab_ances_theory : string -> Theory_data.theory
    val perform_atomic_theory_op : (unit -> 'a) -> 'a
    val install_new_parent : string * Theory_io.hol_sig -> unit
    val goto_theory : string -> Theory_data.theory_id -> Theory_data.theory
    val export_theory : unit -> unit
    val close : unit -> unit
    sharing Theory_data = Theory_io.Theory_data
  end
val it = () : unit
GC #1.4.20.46.148.4575:   (40 ms)
[opening 0/theory/ops.sml]
functor THEORY_OPS : <sig>
val it = () : unit
[opening 0/theory/theory.sig]
signature Theory_sig =
  sig
    structure Thm :
      sig
        structure Term : <sig>
        type thm
        val reset_thm_count : unit -> unit
        val counting_thms : bool -> unit
        val thm_count : unit
                        -> {ABS:int, ASSUME:int, BETA_CONV:int, DISCH:int,
                            INST_TYPE:int, MP:int, REFL:int, SUBST:int,
                            axiom:int, definition:int, drule:int,
                            from_disk:int, other:int, valid_tac:int}
        val hyp : thm -> Term.term list
        val concl : thm -> Term.term
        val dest_thm : thm -> Term.term list * Term.term
        val thm_free_vars : thm -> Term.term list
        val hyp_union : thm list -> Term.term list
        val pp_thm : ?.PrettyPrint.ppstream -> thm -> unit
        val thm_to_string : thm -> string
        val print_thm : thm -> unit
        val ASSUME : Term.term -> thm
        val REFL : Term.term -> thm
        val BETA_CONV : Term.term -> thm
        val SUBST : {thm:thm, var:Term.term} list -> Term.term -> thm -> thm
        val ABS : Term.term -> thm -> thm
        val INST_TYPE : Term.Type.hol_type subst -> thm -> thm
        val DISCH : Term.term -> thm -> thm
        val MP : thm -> thm -> thm
        val mk_axiom_thm : Term.term list * Term.term -> thm
        val mk_definition_thm : Term.term list * Term.term -> thm
        val mk_drule_thm : Term.term list * Term.term -> thm
        val mk_disk_thm : Term.term list * Term.term -> thm
        val mk_tac_thm : Term.term list * Term.term -> thm
        val mk_thm : Term.term list * Term.term -> thm
        datatype just_arg
          = JA_INT of int
          | JA_INTLIST of int list
          | JA_PAIR of just_arg * just_arg
          | JA_STRING of string
          | JA_TERM of Term.term
          | JA_THM of thm
          | JA_TYPE of Term.Type.hol_type
        datatype step = STEP of {Just:just_arg list, Name:string, Thm:thm}
        val record_step : (step -> thm) ref
        val record_proof : bool -> unit
        val suspend_recording : unit -> unit
        val resume_recording : unit -> unit
        val is_recording_proof : unit -> bool
        val note : step * thm -> thm
      end
    val new_parent : string -> unit
    val new_type : {Arity:int, Name:string} -> unit
    val new_constant : {Name:string, Ty:Thm.Term.Type.hol_type} -> unit
    val new_infix : {Name:string, Prec:int, Ty:Thm.Term.Type.hol_type} -> unit
    val new_binder : {Name:string, Ty:Thm.Term.Type.hol_type} -> unit
    val new_open_axiom : string * Thm.Term.term -> Thm.thm
    val store_definition : string * Thm.Term.term -> Thm.thm
    val save_thm : string * Thm.thm -> Thm.thm
    val arity : string -> int
    val fixity : string -> Thm.Term.fixity
    val precedence : string -> int
    val const_decl : string
                     -> {const:Thm.Term.term, place:Thm.Term.fixity,
                         theory:string}
    val is_constant : string -> bool
    val is_type : string -> bool
    val is_binder : string -> bool
    val is_infix : string -> bool
    val draft_mode : unit -> bool
    val current_theory : unit -> string
    val parents : string -> string list
    val ancestry : string -> string list
    val types : string -> {Arity:int, Name:string} list
    val constants : string -> Thm.Term.term list
    val infixes : string -> Thm.Term.term list
    val binders : string -> Thm.Term.term list
    val axioms : string -> (string * Thm.thm) list
    val axiom : string -> string -> Thm.thm
    val definitions : string -> (string * Thm.thm) list
    val definition : string -> string -> Thm.thm
    val theorems : string -> (string * Thm.thm) list
    val theorem : string -> string -> Thm.thm
    val print_theory_to_outstream : {outstream:Portable.outstream,
                                     theory:string}
                                    -> Portable.outstream
    val print_theory_to_file : {file:string, theory:string} -> unit
    val print_theory : string -> unit
    val html_theory : string -> unit
    val new_theory : string -> unit
    val close_theory : unit -> unit
    val load_theory : string -> unit
    val extend_theory : string -> unit
    val export_theory : unit -> unit
    val close : unit -> unit
    val delete_cache : unit -> unit
    val delete_theory_from_cache : string -> unit
    val theories_in_cache : unit -> string list
    val perform_atomic_theory_op : (unit -> 'a) -> 'a
    val loadLibThry : string -> string -> unit
  end
val it = () : unit
GC #1.4.20.46.149.4650:   (60 ms)
[opening 0/theory/theory.sml]
0/theory/theory.sml:598.7-600.62 Warning: binding contains no variables
          () = ...
0/theory/theory.sml:24.1-612.4 Warning: match nonexhaustive
          {arity=arity,theory=theory,tyc=Tyc name} => ...
  
0/theory/theory.sml:118.8-118.61 Warning: binding not exhaustive
          {Args=_ :: _ :: nil,Tyop="fun"} = ...
0/theory/theory.sml:117.8-117.62 Warning: binding not exhaustive
          {Args=ty1 :: _ :: nil,Tyop="fun"} = ...
0/theory/theory.sml:112.8-112.60 Warning: binding not exhaustive
          {Args=_ :: _ :: nil,Tyop="fun"} = ...
0/theory/theory.sml:111.8-111.61 Warning: binding not exhaustive
          {Args=_ :: ty2 :: nil,Tyop="fun"} = ...
GC #1.4.20.46.150.4712:   (90 ms)
GC #1.4.20.47.151.4720:   (100 ms)
GC #1.4.20.47.152.4745:   (50 ms)
GC #1.4.20.48.153.4759:   (130 ms)
GC #1.4.20.49.154.4784:   (40 ms)
GC #1.4.20.49.155.4796:   (10 ms)
GC #1.4.20.49.156.4857:   (50 ms)
GC #1.4.20.50.157.4896:   (100 ms)
GC #1.4.20.51.158.4922:   (100 ms)
GC #1.4.20.52.159.4938:   (90 ms)
GC #1.4.20.52.160.4942:   (0 ms)
functor THEORY : <sig>
val it = () : unit
GC #1.4.20.53.161.4943:   (0 ms)
[opening 0/net.sig]
signature Net_sig =
  sig
    structure Term :
      sig
        structure Type : <sig>
        datatype fixity = Binder | Infix of int | Prefix
        eqtype term
        val const_decl : string -> {const:term, place:fixity, theory:string}
        val fixity_of_term : string -> fixity
        val fixity_to_string : fixity -> string
        val prec_of_term : string -> int
        val is_binder : string -> bool
        val is_infix : string -> bool
        val is_polymorphic : string -> bool
        datatype lambda
          = COMB of {Rand:term, Rator:term}
          | CONST of {Name:string, Ty:Type.hol_type}
          | LAMB of {Body:term, Bvar:term}
          | VAR of {Name:string, Ty:Type.hol_type}
        val ty_antiq : Type.hol_type -> term
        val free_vars : term -> term list
        val free_in : term -> term -> bool
        val all_vars : term -> term list
        val free_varsl : term list -> term list
        val all_varsl : term list -> term list
        val term_lt : term -> term -> bool
        val genvar : Type.hol_type -> term
        val genvars : Type.hol_type -> int -> term list
        val variant : term list -> term -> term
        val type_of : term -> Type.hol_type
        val type_vars_in_term : term -> Type.hol_type list
        val mk_var : {Name:string, Ty:Type.hol_type} -> term
        val mk_primed_var : {Name:string, Ty:Type.hol_type} -> term
        val list_mk_comb : term * term list -> term
        val mk_comb : {Rand:term, Rator:term} -> term
        val mk_abs : {Body:term, Bvar:term} -> term
        val dest_var : term -> {Name:string, Ty:Type.hol_type}
        val dest_const : term -> {Name:string, Ty:Type.hol_type}
        val dest_comb : term -> {Rand:term, Rator:term}
        val dest_abs : term -> {Body:term, Bvar:term}
        val is_var : term -> bool
        val is_const : term -> bool
        val is_comb : term -> bool
        val is_abs : term -> bool
        val dest_term : term -> lambda
        val rator : term -> term
        val rand : term -> term
        val bvar : term -> term
        val body : term -> term
        val aconv : term -> term -> bool
        val subst : term subst -> term -> term
        val inst : Type.hol_type subst -> term -> term
        val beta_conv : term -> term
      end
    type 'a net
    val empty_net : 'a net
    val enter : Term.term * 'a -> 'a net -> 'a net
    val lookup : Term.term -> 'a net -> 'a list
  end
val it = () : unit
GC #1.4.20.54.162.4959:   (10 ms)
GC #1.4.20.55.163.4976:   (40 ms)
[opening 0/net.sml]
functor NET : <sig>
val it = () : unit
[opening 0/library/lib_data.sig]
signature Lib_data_sig =
  sig
    type lib_id
    val new_lib_id : string -> lib_id
    val mk_lib_id : {name:string, timestamp:time} -> lib_id
    val lib_id_name : lib_id -> string
    val lib_id_timestamp : lib_id -> time
    val lib_id_eq : lib_id * lib_id -> bool
    type lib_data
    val dest_lib_data : lib_data
                        -> {code:string list, doc:string, help:string list,
                            lib_id:lib_id, loaded:string, parents:lib_id list,
                            path:string, theories:string list}
    val mk_lib_data : {code:string list, doc:string, help:string list,
                       lib_id:lib_id, loaded:string, parents:lib_id list,
                       path:string, theories:string list}
                      -> lib_data
  end
val it = () : unit
[opening 0/library/lib_data.sml]
structure Lib_data : Lib_data_sig
val it = () : unit
[opening Grammars/lib.yak.sig]
signature lib_TOKENS =
  sig
    type ('a,'b) token
    type svalue
    val EOF : 'a * 'a -> (svalue,'a) token
    val EOLEX : 'a * 'a -> (svalue,'a) token
    val string_constant : string * 'a * 'a -> (svalue,'a) token
    val num : string * 'a * 'a -> (svalue,'a) token
    val id : string * 'a * 'a -> (svalue,'a) token
    val loaded : 'a * 'a -> (svalue,'a) token
    val help : 'a * 'a -> (svalue,'a) token
    val code : 'a * 'a -> (svalue,'a) token
    val theories : 'a * 'a -> (svalue,'a) token
    val parents : 'a * 'a -> (svalue,'a) token
    val path : 'a * 'a -> (svalue,'a) token
    val doc : 'a * 'a -> (svalue,'a) token
    val lib_id : 'a * 'a -> (svalue,'a) token
    val comma : 'a * 'a -> (svalue,'a) token
    val eq : 'a * 'a -> (svalue,'a) token
    val rparen : 'a * 'a -> (svalue,'a) token
    val lparen : 'a * 'a -> (svalue,'a) token
    val rbracket : 'a * 'a -> (svalue,'a) token
    val lbracket : 'a * 'a -> (svalue,'a) token
    val rbrace : 'a * 'a -> (svalue,'a) token
    val lbrace : 'a * 'a -> (svalue,'a) token
  end
signature lib_LRVALS =
  sig
    structure Tokens :
      sig
        type ('a,'b) token
        type svalue
        val EOF : 'a * 'a -> (svalue,'a) token
        val EOLEX : 'a * 'a -> (svalue,'a) token
        val string_constant : string * 'a * 'a -> (svalue,'a) token
        val num : string * 'a * 'a -> (svalue,'a) token
        val id : string * 'a * 'a -> (svalue,'a) token
        val loaded : 'a * 'a -> (svalue,'a) token
        val help : 'a * 'a -> (svalue,'a) token
        val code : 'a * 'a -> (svalue,'a) token
        val theories : 'a * 'a -> (svalue,'a) token
        val parents : 'a * 'a -> (svalue,'a) token
        val path : 'a * 'a -> (svalue,'a) token
        val doc : 'a * 'a -> (svalue,'a) token
        val lib_id : 'a * 'a -> (svalue,'a) token
        val comma : 'a * 'a -> (svalue,'a) token
        val eq : 'a * 'a -> (svalue,'a) token
        val rparen : 'a * 'a -> (svalue,'a) token
        val lparen : 'a * 'a -> (svalue,'a) token
        val rbracket : 'a * 'a -> (svalue,'a) token
        val lbracket : 'a * 'a -> (svalue,'a) token
        val rbrace : 'a * 'a -> (svalue,'a) token
        val lbrace : 'a * 'a -> (svalue,'a) token
      end
    structure ParserData :
      sig
        type pos
        type svalue
        type arg
        type result
        structure LrTable : <sig>
        structure Token : <sig>
        structure Actions : <sig>
        structure EC : <sig>
        val table : LrTable.table
        sharing LrTable = Token.LrTable
      end
    sharing type Tokens.svalue = ParserData.svalue
    sharing type Tokens.token = ParserData.Token.token
  end
val it = () : unit
GC #1.4.20.56.164.5015:   (20 ms)
GC #1.4.20.56.165.5058:   (50 ms)
GC #1.4.20.57.166.5105:   (50 ms)
GC #1.4.20.57.167.5114:   (50 ms)
GC #1.4.21.58.168.5126:   (160 ms)
GC #1.4.21.59.169.5158:   (40 ms)
[opening Grammars/lib.yak.sml]
functor libLrValsFun : <sig>
val it = () : unit
GC #1.4.21.59.170.5222:   (10 ms)
GC #1.4.21.59.171.5296:   (50 ms)
GC #1.4.21.60.172.5309:   (80 ms)
GC #1.4.21.60.173.5388:   (40 ms)
[opening Grammars/lib.lex.sml]
functor LIB_LEX : <sig>
val it = () : unit
GC #1.4.21.61.174.5401:   (10 ms)
[opening 0/library/lib_io.sig]
signature Lib_io_sig =
  sig
    structure Lib_data :
      sig
        type lib_id
        val new_lib_id : string -> lib_id
        val mk_lib_id : {name:string, timestamp:time} -> lib_id
        val lib_id_name : lib_id -> string
        val lib_id_timestamp : lib_id -> time
        val lib_id_eq : lib_id * lib_id -> bool
        type lib_data
        val dest_lib_data : lib_data
                            -> {code:string list, doc:string, help:string list,
                                lib_id:lib_id, loaded:string,
                                parents:lib_id list, path:string,
                                theories:string list}
        val mk_lib_data : {code:string list, doc:string, help:string list,
                           lib_id:lib_id, loaded:string, parents:lib_id list,
                           path:string, theories:string list}
                          -> lib_data
      end
    val get_lib_by_name : string list -> string -> Lib_data.lib_data
    val get_lib_by_uid : string list -> Lib_data.lib_id -> Lib_data.lib_data
    val write_lib_to_disk : string * Lib_data.lib_data -> unit
  end
val it = () : unit
GC #1.4.21.61.175.5428:   (30 ms)
GC #1.4.21.61.176.5450:   (30 ms)
[opening 0/library/lib_io.sml]
functor LIB_IO : <sig>
val it = () : unit
[opening 0/library/lib.sig]
signature Library_sig =
  sig
    type lib
    val loaded_cell : (unit -> unit) ref
    val lib_eq : lib -> lib -> bool
    val new_library : {code:string list, doc:string, help:string list,
                       loaded:string, name:string, parents:lib list,
                       path:string, theories:string list}
                      -> lib
    val dest_library : lib
                       -> {code:string list, doc:string, help:string list,
                           name:string, parents:lib list, path:string,
                           theories:string list}
    val prim_load_library' : (string list -> unit)
                             -> {lib:lib, theory:string} -> unit
    val prim_load_library : (string -> unit)
                            -> {lib:lib, theory:string} -> unit
    val load_library : {lib:lib, theory:string} -> unit
    val load_library_in_place : lib -> unit
    val find_library : string -> lib
    val get_library_from_disk : string -> lib
    val move_library : lib * string -> unit
    val delete_library : lib -> unit
    val known_libraries : unit -> lib list
    val loaded_libraries : unit -> lib list
    val pp_library : ?.PrettyPrint.ppstream -> lib -> unit
    val lib_help : {lib:lib, topic:string} -> unit
  end
val it = () : unit
GC #1.4.21.61.177.5481:   (20 ms)
GC #1.4.21.61.178.5505:   (30 ms)
GC #1.4.21.62.179.5526:   (40 ms)
GC #1.4.21.62.180.5537:   (30 ms)
GC #1.4.21.63.181.5554:   (70 ms)
GC #1.4.21.63.182.5562:   (0 ms)
GC #1.4.21.63.183.5601:   (50 ms)
[opening 0/library/lib.sml]
functor LIBRARY : <sig>
val it = () : unit
GC #1.4.21.64.184.5617:   (20 ms)
[opening 0/exists_def.sig]
signature Exists_def_sig =
  sig
    structure Theory :
      sig
        structure Thm : <sig>
        val new_parent : string -> unit
        val new_type : {Arity:int, Name:string} -> unit
        val new_constant : {Name:string, Ty:Thm.Term.Type.hol_type} -> unit
        val new_infix : {Name:string, Prec:int, Ty:Thm.Term.Type.hol_type}
                        -> unit
        val new_binder : {Name:string, Ty:Thm.Term.Type.hol_type} -> unit
        val new_open_axiom : string * Thm.Term.term -> Thm.thm
        val store_definition : string * Thm.Term.term -> Thm.thm
        val save_thm : string * Thm.thm -> Thm.thm
        val arity : string -> int
        val fixity : string -> Thm.Term.fixity
        val precedence : string -> int
        val const_decl : string
                         -> {const:Thm.Term.term, place:Thm.Term.fixity,
                             theory:string}
        val is_constant : string -> bool
        val is_type : string -> bool
        val is_binder : string -> bool
        val is_infix : string -> bool
        val draft_mode : unit -> bool
        val current_theory : unit -> string
        val parents : string -> string list
        val ancestry : string -> string list
        val types : string -> {Arity:int, Name:string} list
        val constants : string -> Thm.Term.term list
        val infixes : string -> Thm.Term.term list
        val binders : string -> Thm.Term.term list
        val axioms : string -> (string * Thm.thm) list
        val axiom : string -> string -> Thm.thm
        val definitions : string -> (string * Thm.thm) list
        val definition : string -> string -> Thm.thm
        val theorems : string -> (string * Thm.thm) list
        val theorem : string -> string -> Thm.thm
        val print_theory_to_outstream : {outstream:Portable.outstream,
                                         theory:string}
                                        -> Portable.outstream
        val print_theory_to_file : {file:string, theory:string} -> unit
        val print_theory : string -> unit
        val html_theory : string -> unit
        val new_theory : string -> unit
        val close_theory : unit -> unit
        val load_theory : string -> unit
        val extend_theory : string -> unit
        val export_theory : unit -> unit
        val close : unit -> unit
        val delete_cache : unit -> unit
        val delete_theory_from_cache : string -> unit
        val theories_in_cache : unit -> string list
        val perform_atomic_theory_op : (unit -> 'a) -> 'a
        val loadLibThry : string -> string -> unit
      end
    val new_binder_definition : string * Theory.Thm.Term.term -> Theory.Thm.thm
  end
val it = () : unit
GC #1.4.21.64.185.5644:   (20 ms)
[opening 0/exists_def.sml]
functor EXISTS_DEF : <sig>
val it = () : unit
GC #1.4.21.64.186.5664:   (10 ms)
[opening 0/const_spec.sig]
signature Const_spec_sig =
  sig
    structure Theory :
      sig
        structure Thm : <sig>
        val new_parent : string -> unit
        val new_type : {Arity:int, Name:string} -> unit
        val new_constant : {Name:string, Ty:Thm.Term.Type.hol_type} -> unit
        val new_infix : {Name:string, Prec:int, Ty:Thm.Term.Type.hol_type}
                        -> unit
        val new_binder : {Name:string, Ty:Thm.Term.Type.hol_type} -> unit
        val new_open_axiom : string * Thm.Term.term -> Thm.thm
        val store_definition : string * Thm.Term.term -> Thm.thm
        val save_thm : string * Thm.thm -> Thm.thm
        val arity : string -> int
        val fixity : string -> Thm.Term.fixity
        val precedence : string -> int
        val const_decl : string
                         -> {const:Thm.Term.term, place:Thm.Term.fixity,
                             theory:string}
        val is_constant : string -> bool
        val is_type : string -> bool
        val is_binder : string -> bool
        val is_infix : string -> bool
        val draft_mode : unit -> bool
        val current_theory : unit -> string
        val parents : string -> string list
        val ancestry : string -> string list
        val types : string -> {Arity:int, Name:string} list
        val constants : string -> Thm.Term.term list
        val infixes : string -> Thm.Term.term list
        val binders : string -> Thm.Term.term list
        val axioms : string -> (string * Thm.thm) list
        val axiom : string -> string -> Thm.thm
        val definitions : string -> (string * Thm.thm) list
        val definition : string -> string -> Thm.thm
        val theorems : string -> (string * Thm.thm) list
        val theorem : string -> string -> Thm.thm
        val print_theory_to_outstream : {outstream:Portable.outstream,
                                         theory:string}
                                        -> Portable.outstream
        val print_theory_to_file : {file:string, theory:string} -> unit
        val print_theory : string -> unit
        val html_theory : string -> unit
        val new_theory : string -> unit
        val close_theory : unit -> unit
        val load_theory : string -> unit
        val extend_theory : string -> unit
        val export_theory : unit -> unit
        val close : unit -> unit
        val delete_cache : unit -> unit
        val delete_theory_from_cache : string -> unit
        val theories_in_cache : unit -> string list
        val perform_atomic_theory_op : (unit -> 'a) -> 'a
        val loadLibThry : string -> string -> unit
      end
    val new_specification : {consts:{const_name:string,
                                     fixity:Theory.Thm.Term.fixity} list,
                             name:string, sat_thm:Theory.Thm.thm}
                            -> Theory.Thm.thm
  end
val it = () : unit
[opening 0/const_spec.sml]
0/const_spec.sml:81.8-81.61 Warning: binding not exhaustive
          {Args=_ :: _ :: nil,Tyop="fun"} = ...
0/const_spec.sml:80.8-80.62 Warning: binding not exhaustive
          {Args=ty1 :: _ :: nil,Tyop="fun"} = ...
0/const_spec.sml:73.8-73.61 Warning: binding not exhaustive
          {Args=_ :: _ :: nil,Tyop="fun"} = ...
0/const_spec.sml:72.8-72.61 Warning: binding not exhaustive
          {Args=_ :: ty2 :: nil,Tyop="fun"} = ...
GC #1.4.21.64.187.5695:   (30 ms)
GC #1.4.21.64.188.5705:   (30 ms)
GC #1.4.21.64.189.5718:   (10 ms)
functor CONST_SPEC : <sig>
val it = () : unit
[opening 0/type_def.sig]
signature Type_def_sig =
  sig
    structure Theory :
      sig
        structure Thm : <sig>
        val new_parent : string -> unit
        val new_type : {Arity:int, Name:string} -> unit
        val new_constant : {Name:string, Ty:Thm.Term.Type.hol_type} -> unit
        val new_infix : {Name:string, Prec:int, Ty:Thm.Term.Type.hol_type}
                        -> unit
        val new_binder : {Name:string, Ty:Thm.Term.Type.hol_type} -> unit
        val new_open_axiom : string * Thm.Term.term -> Thm.thm
        val store_definition : string * Thm.Term.term -> Thm.thm
        val save_thm : string * Thm.thm -> Thm.thm
        val arity : string -> int
        val fixity : string -> Thm.Term.fixity
        val precedence : string -> int
        val const_decl : string
                         -> {const:Thm.Term.term, place:Thm.Term.fixity,
                             theory:string}
        val is_constant : string -> bool
        val is_type : string -> bool
        val is_binder : string -> bool
        val is_infix : string -> bool
        val draft_mode : unit -> bool
        val current_theory : unit -> string
        val parents : string -> string list
        val ancestry : string -> string list
        val types : string -> {Arity:int, Name:string} list
        val constants : string -> Thm.Term.term list
        val infixes : string -> Thm.Term.term list
        val binders : string -> Thm.Term.term list
        val axioms : string -> (string * Thm.thm) list
        val axiom : string -> string -> Thm.thm
        val definitions : string -> (string * Thm.thm) list
        val definition : string -> string -> Thm.thm
        val theorems : string -> (string * Thm.thm) list
        val theorem : string -> string -> Thm.thm
        val print_theory_to_outstream : {outstream:Portable.outstream,
                                         theory:string}
                                        -> Portable.outstream
        val print_theory_to_file : {file:string, theory:string} -> unit
        val print_theory : string -> unit
        val html_theory : string -> unit
        val new_theory : string -> unit
        val close_theory : unit -> unit
        val load_theory : string -> unit
        val extend_theory : string -> unit
        val export_theory : unit -> unit
        val close : unit -> unit
        val delete_cache : unit -> unit
        val delete_theory_from_cache : string -> unit
        val theories_in_cache : unit -> string list
        val perform_atomic_theory_op : (unit -> 'a) -> 'a
        val loadLibThry : string -> string -> unit
      end
    val new_type_definition : {inhab_thm:Theory.Thm.thm, name:string,
                               pred:Theory.Thm.Term.term}
                              -> Theory.Thm.thm
  end
val it = () : unit
GC #1.4.21.64.190.5771:   (10 ms)
[opening 0/type_def.sml]
0/type_def.sml:123.22-124.68 Warning: binding not exhaustive
          {Args=ty :: _ :: nil,Tyop=_} = ...
functor TYPE_DEF : <sig>
val it = () : unit
[opening 0/const_def.sig]
signature Const_def_sig =
  sig
    structure Theory :
      sig
        structure Thm : <sig>
        val new_parent : string -> unit
        val new_type : {Arity:int, Name:string} -> unit
        val new_constant : {Name:string, Ty:Thm.Term.Type.hol_type} -> unit
        val new_infix : {Name:string, Prec:int, Ty:Thm.Term.Type.hol_type}
                        -> unit
        val new_binder : {Name:string, Ty:Thm.Term.Type.hol_type} -> unit
        val new_open_axiom : string * Thm.Term.term -> Thm.thm
        val store_definition : string * Thm.Term.term -> Thm.thm
        val save_thm : string * Thm.thm -> Thm.thm
        val arity : string -> int
        val fixity : string -> Thm.Term.fixity
        val precedence : string -> int
        val const_decl : string
                         -> {const:Thm.Term.term, place:Thm.Term.fixity,
                             theory:string}
        val is_constant : string -> bool
        val is_type : string -> bool
        val is_binder : string -> bool
        val is_infix : string -> bool
        val draft_mode : unit -> bool
        val current_theory : unit -> string
        val parents : string -> string list
        val ancestry : string -> string list
        val types : string -> {Arity:int, Name:string} list
        val constants : string -> Thm.Term.term list
        val infixes : string -> Thm.Term.term list
        val binders : string -> Thm.Term.term list
        val axioms : string -> (string * Thm.thm) list
        val axiom : string -> string -> Thm.thm
        val definitions : string -> (string * Thm.thm) list
        val definition : string -> string -> Thm.thm
        val theorems : string -> (string * Thm.thm) list
        val theorem : string -> string -> Thm.thm
        val print_theory_to_outstream : {outstream:Portable.outstream,
                                         theory:string}
                                        -> Portable.outstream
        val print_theory_to_file : {file:string, theory:string} -> unit
        val print_theory : string -> unit
        val html_theory : string -> unit
        val new_theory : string -> unit
        val close_theory : unit -> unit
        val load_theory : string -> unit
        val extend_theory : string -> unit
        val export_theory : unit -> unit
        val close : unit -> unit
        val delete_cache : unit -> unit
        val delete_theory_from_cache : string -> unit
        val theories_in_cache : unit -> string list
        val perform_atomic_theory_op : (unit -> 'a) -> 'a
        val loadLibThry : string -> string -> unit
      end
    val new_definition : string * Theory.Thm.Term.term -> Theory.Thm.thm
    val new_infix_definition : string * Theory.Thm.Term.term * int
                               -> Theory.Thm.thm
    val new_binder_definition : string * Theory.Thm.Term.term -> Theory.Thm.thm
  end
val it = () : unit
GC #1.4.21.65.191.5832:   (20 ms)
[opening 0/const_def.sml]
functor CONST_DEF : <sig>
val it = () : unit
[opening 0/CoreHol.sig]
signature CoreHolSig =
  sig
    structure Type :
      sig
        eqtype hol_type
        val fresh_tyvar_stream : unit -> (int,hol_type) istream
        val type_subst : hol_type subst -> hol_type -> hol_type
        val type_vars : hol_type -> hol_type list
        val type_varsl : hol_type list -> hol_type list
        val mk_type : {Args:hol_type list, Tyop:string} -> hol_type
        val dest_type : hol_type -> {Args:hol_type list, Tyop:string}
        val mk_vartype : string -> hol_type
        val dest_vartype : hol_type -> string
        val is_vartype : hol_type -> bool
        val type_lt : hol_type -> hol_type -> bool
        val type_decl : string -> {arity:int, theory:string, tyc:hol_type}
      end
    structure Term :
      sig
        structure Type : <sig>
        datatype fixity = Binder | Infix of int | Prefix
        eqtype term
        val const_decl : string -> {const:term, place:fixity, theory:string}
        val fixity_of_term : string -> fixity
        val fixity_to_string : fixity -> string
        val prec_of_term : string -> int
        val is_binder : string -> bool
        val is_infix : string -> bool
        val is_polymorphic : string -> bool
        datatype lambda
          = COMB of {Rand:term, Rator:term}
          | CONST of {Name:string, Ty:Type.hol_type}
          | LAMB of {Body:term, Bvar:term}
          | VAR of {Name:string, Ty:Type.hol_type}
        val ty_antiq : Type.hol_type -> term
        val free_vars : term -> term list
        val free_in : term -> term -> bool
        val all_vars : term -> term list
        val free_varsl : term list -> term list
        val all_varsl : term list -> term list
        val term_lt : term -> term -> bool
        val genvar : Type.hol_type -> term
        val genvars : Type.hol_type -> int -> term list
        val variant : term list -> term -> term
        val type_of : term -> Type.hol_type
        val type_vars_in_term : term -> Type.hol_type list
        val mk_var : {Name:string, Ty:Type.hol_type} -> term
        val mk_primed_var : {Name:string, Ty:Type.hol_type} -> term
        val list_mk_comb : term * term list -> term
        val mk_comb : {Rand:term, Rator:term} -> term
        val mk_abs : {Body:term, Bvar:term} -> term
        val dest_var : term -> {Name:string, Ty:Type.hol_type}
        val dest_const : term -> {Name:string, Ty:Type.hol_type}
        val dest_comb : term -> {Rand:term, Rator:term}
        val dest_abs : term -> {Body:term, Bvar:term}
        val is_var : term -> bool
        val is_const : term -> bool
        val is_comb : term -> bool
        val is_abs : term -> bool
        val dest_term : term -> lambda
        val rator : term -> term
        val rand : term -> term
        val bvar : term -> term
        val body : term -> term
        val aconv : term -> term -> bool
        val subst : term subst -> term -> term
        val inst : Type.hol_type subst -> term -> term
        val beta_conv : term -> term
      end
    structure Match :
      sig
        structure Term : <sig>
        val match_type : Term.Type.hol_type
                         -> Term.Type.hol_type -> Term.Type.hol_type subst
        val match_term : Term.term
                         -> Term.term
                            -> Term.term subst * Term.Type.hol_type subst
      end
    structure Net :
      sig
        structure Term : <sig>
        type 'a net
        val empty_net : 'a net
        val enter : Term.term * 'a -> 'a net -> 'a net
        val lookup : Term.term -> 'a net -> 'a list
      end
    structure Preterm :
      sig
        structure Term : <sig>
        datatype preterm
          = Abs of {Body:preterm, Bvar:preterm}
          | Antiq of Term.term
          | Comb of {Rand:preterm, Rator:preterm}
          | Const of {Name:string, Ty:Term.Type.hol_type}
          | Constrained of preterm * Term.Type.hol_type
          | Var of {Name:string, Ty:Term.Type.hol_type}
        val TC : (int,Term.Type.hol_type) istream -> preterm -> unit
        val shrink_type : (Term.Type.hol_type * Term.Type.hol_type) list
                          -> Term.Type.hol_type -> Term.Type.hol_type
        val tyVars : preterm -> Term.Type.hol_type list
        val cleanup : preterm -> Term.term
        val typecheck : (int,Term.Type.hol_type) istream
                        -> preterm -> Term.term
        val preterm_to_term : preterm -> Term.term
      end
    structure Dsyntax :
      sig
        structure Term : <sig>
        val mk_const : {Name:string, Ty:Term.Type.hol_type} -> Term.term
        val mk_eq : {lhs:Term.term, rhs:Term.term} -> Term.term
        val mk_imp : {ant:Term.term, conseq:Term.term} -> Term.term
        val mk_select : {Body:Term.term, Bvar:Term.term} -> Term.term
        val mk_forall : {Body:Term.term, Bvar:Term.term} -> Term.term
        val mk_exists : {Body:Term.term, Bvar:Term.term} -> Term.term
        val mk_neg : Term.term -> Term.term
        val mk_conj : {conj1:Term.term, conj2:Term.term} -> Term.term
        val mk_disj : {disj1:Term.term, disj2:Term.term} -> Term.term
        val mk_cond : {cond:Term.term, larm:Term.term, rarm:Term.term}
                      -> Term.term
        val mk_pair : {fst:Term.term, snd:Term.term} -> Term.term
        val mk_let : {arg:Term.term, func:Term.term} -> Term.term
        val mk_cons : {hd:Term.term, tl:Term.term} -> Term.term
        val mk_list : {els:Term.term list, ty:Term.Type.hol_type} -> Term.term
        val mk_pabs : {body:Term.term, varstruct:Term.term} -> Term.term
        val dest_eq : Term.term -> {lhs:Term.term, rhs:Term.term}
        val lhs : Term.term -> Term.term
        val rhs : Term.term -> Term.term
        val dest_imp : Term.term -> {ant:Term.term, conseq:Term.term}
        val dest_select : Term.term -> {Body:Term.term, Bvar:Term.term}
        val dest_forall : Term.term -> {Body:Term.term, Bvar:Term.term}
        val dest_exists : Term.term -> {Body:Term.term, Bvar:Term.term}
        val dest_neg : Term.term -> Term.term
        val dest_conj : Term.term -> {conj1:Term.term, conj2:Term.term}
        val dest_disj : Term.term -> {disj1:Term.term, disj2:Term.term}
        val dest_cond : Term.term
                        -> {cond:Term.term, larm:Term.term, rarm:Term.term}
        val dest_pair : Term.term -> {fst:Term.term, snd:Term.term}
        val dest_let : Term.term -> {arg:Term.term, func:Term.term}
        val dest_cons : Term.term -> {hd:Term.term, tl:Term.term}
        val dest_list : Term.term
                        -> {els:Term.term list, ty:Term.Type.hol_type}
        val dest_pabs : Term.term -> {body:Term.term, varstruct:Term.term}
        val is_eq : Term.term -> bool
        val is_imp : Term.term -> bool
        val is_select : Term.term -> bool
        val is_forall : Term.term -> bool
        val is_exists : Term.term -> bool
        val is_neg : Term.term -> bool
        val is_conj : Term.term -> bool
        val is_disj : Term.term -> bool
        val is_cond : Term.term -> bool
        val is_pair : Term.term -> bool
        val is_let : Term.term -> bool
        val is_cons : Term.term -> bool
        val is_list : Term.term -> bool
        val is_pabs : Term.term -> bool
        val list_mk_abs : Term.term list * Term.term -> Term.term
        val list_mk_imp : Term.term list * Term.term -> Term.term
        val list_mk_forall : Term.term list * Term.term -> Term.term
        val gen_all : Term.term -> Term.term
        val list_mk_exists : Term.term list * Term.term -> Term.term
        val list_mk_conj : Term.term list -> Term.term
        val list_mk_disj : Term.term list -> Term.term
        val list_mk_pair : Term.term list -> Term.term
        val strip_comb : Term.term -> Term.term * Term.term list
        val strip_abs : Term.term -> Term.term list * Term.term
        val strip_imp : Term.term -> Term.term list * Term.term
        val strip_forall : Term.term -> Term.term list * Term.term
        val strip_exists : Term.term -> Term.term list * Term.term
        val strip_conj : Term.term -> Term.term list
        val strip_disj : Term.term -> Term.term list
        val strip_pair : Term.term -> Term.term list
        val infix_ty : Term.Type.hol_type
                       -> Term.Type.hol_type -> Term.Type.hol_type
        val bool : Term.Type.hol_type
        val de_abs : Term.term -> Term.term list * Term.term
        val find_term : (Term.term -> bool) -> Term.term -> Term.term
        val find_terms : (Term.term -> bool) -> Term.term -> Term.term list
        val subst_occs : int list list
                         -> Term.term subst -> Term.term -> Term.term
        val binder_restrictions : unit -> (string * string) list
        val associate_restriction : string * string -> unit
        val delete_restriction : string -> unit
      end
    structure Hol_pp :
      sig
        structure Term : <sig>
        val pp_type : ?.PrettyPrint.ppstream
                      -> Term.Type.hol_type -> int -> unit
        val pp_term : ?.PrettyPrint.ppstream -> Term.term -> unit
        val pp_self_parsing_type : ?.PrettyPrint.ppstream
                                   -> Term.Type.hol_type -> unit
        val pp_self_parsing_term : ?.PrettyPrint.ppstream -> Term.term -> unit
        val type_to_string : Term.Type.hol_type -> string
        val term_to_string : Term.term -> string
        val print_type : Term.Type.hol_type -> unit
        val print_term : Term.term -> unit
        structure Extend_hol_pp : <sig>
      end
    structure Thm :
      sig
        structure Term : <sig>
        type thm
        val reset_thm_count : unit -> unit
        val counting_thms : bool -> unit
        val thm_count : unit
                        -> {ABS:int, ASSUME:int, BETA_CONV:int, DISCH:int,
                            INST_TYPE:int, MP:int, REFL:int, SUBST:int,
                            axiom:int, definition:int, drule:int,
                            from_disk:int, other:int, valid_tac:int}
        val hyp : thm -> Term.term list
        val concl : thm -> Term.term
        val dest_thm : thm -> Term.term list * Term.term
        val thm_free_vars : thm -> Term.term list
        val hyp_union : thm list -> Term.term list
        val pp_thm : ?.PrettyPrint.ppstream -> thm -> unit
        val thm_to_string : thm -> string
        val print_thm : thm -> unit
        val ASSUME : Term.term -> thm
        val REFL : Term.term -> thm
        val BETA_CONV : Term.term -> thm
        val SUBST : {thm:thm, var:Term.term} list -> Term.term -> thm -> thm
        val ABS : Term.term -> thm -> thm
        val INST_TYPE : Term.Type.hol_type subst -> thm -> thm
        val DISCH : Term.term -> thm -> thm
        val MP : thm -> thm -> thm
        val mk_axiom_thm : Term.term list * Term.term -> thm
        val mk_definition_thm : Term.term list * Term.term -> thm
        val mk_drule_thm : Term.term list * Term.term -> thm
        val mk_disk_thm : Term.term list * Term.term -> thm
        val mk_tac_thm : Term.term list * Term.term -> thm
        val mk_thm : Term.term list * Term.term -> thm
        datatype just_arg
          = JA_INT of int
          | JA_INTLIST of int list
          | JA_PAIR of just_arg * just_arg
          | JA_STRING of string
          | JA_TERM of Term.term
          | JA_THM of thm
          | JA_TYPE of Term.Type.hol_type
        datatype step = STEP of {Just:just_arg list, Name:string, Thm:thm}
        val record_step : (step -> thm) ref
        val record_proof : bool -> unit
        val suspend_recording : unit -> unit
        val resume_recording : unit -> unit
        val is_recording_proof : unit -> bool
        val note : step * thm -> thm
      end
    structure Theory :
      sig
        structure Thm : <sig>
        val new_parent : string -> unit
        val new_type : {Arity:int, Name:string} -> unit
        val new_constant : {Name:string, Ty:Thm.Term.Type.hol_type} -> unit
        val new_infix : {Name:string, Prec:int, Ty:Thm.Term.Type.hol_type}
                        -> unit
        val new_binder : {Name:string, Ty:Thm.Term.Type.hol_type} -> unit
        val new_open_axiom : string * Thm.Term.term -> Thm.thm
        val store_definition : string * Thm.Term.term -> Thm.thm
        val save_thm : string * Thm.thm -> Thm.thm
        val arity : string -> int
        val fixity : string -> Thm.Term.fixity
        val precedence : string -> int
        val const_decl : string
                         -> {const:Thm.Term.term, place:Thm.Term.fixity,
                             theory:string}
        val is_constant : string -> bool
        val is_type : string -> bool
        val is_binder : string -> bool
        val is_infix : string -> bool
        val draft_mode : unit -> bool
        val current_theory : unit -> string
        val parents : string -> string list
        val ancestry : string -> string list
        val types : string -> {Arity:int, Name:string} list
        val constants : string -> Thm.Term.term list
        val infixes : string -> Thm.Term.term list
        val binders : string -> Thm.Term.term list
        val axioms : string -> (string * Thm.thm) list
        val axiom : string -> string -> Thm.thm
        val definitions : string -> (string * Thm.thm) list
        val definition : string -> string -> Thm.thm
        val theorems : string -> (string * Thm.thm) list
        val theorem : string -> string -> Thm.thm
        val print_theory_to_outstream : {outstream:Portable.outstream,
                                         theory:string}
                                        -> Portable.outstream
        val print_theory_to_file : {file:string, theory:string} -> unit
        val print_theory : string -> unit
        val html_theory : string -> unit
        val new_theory : string -> unit
        val close_theory : unit -> unit
        val load_theory : string -> unit
        val extend_theory : string -> unit
        val export_theory : unit -> unit
        val close : unit -> unit
        val delete_cache : unit -> unit
        val delete_theory_from_cache : string -> unit
        val theories_in_cache : unit -> string list
        val perform_atomic_theory_op : (unit -> 'a) -> 'a
        val loadLibThry : string -> string -> unit
      end
    structure Const_spec :
      sig
        structure Theory : <sig>
        val new_specification : {consts:{const_name:string,
                                         fixity:Theory.Thm.Term.fixity} list,
                                 name:string, sat_thm:Theory.Thm.thm}
                                -> Theory.Thm.thm
      end
    structure Type_def :
      sig
        structure Theory : <sig>
        val new_type_definition : {inhab_thm:Theory.Thm.thm, name:string,
                                   pred:Theory.Thm.Term.term}
                                  -> Theory.Thm.thm
      end
    structure Const_def :
      sig
        structure Theory : <sig>
        val new_definition : string * Theory.Thm.Term.term -> Theory.Thm.thm
        val new_infix_definition : string * Theory.Thm.Term.term * int
                                   -> Theory.Thm.thm
        val new_binder_definition : string * Theory.Thm.Term.term
                                    -> Theory.Thm.thm
      end
  end
val it = () : unit
GC #1.4.21.65.192.5905:   (10 ms)
GC #1.4.21.65.193.6051:   (100 ms)
GC #1.4.21.66.194.6088:   (120 ms)
GC #1.4.22.67.195.6101:   (140 ms)
GC #1.4.22.67.196.6124:   (20 ms)
GC #1.4.22.68.197.6135:   (30 ms)
GC #1.4.22.68.198.6191:   (40 ms)
GC #1.4.22.69.199.6232:   (10 ms)
[opening 0/CoreHol.sml]
structure CoreHol : CoreHolSig
val it = () : unit
[opening 0/parse_support.sig]
signature Parse_support_sig =
  sig
    type preterm_in_env
    type binder_in_env
    structure Preterm :
      sig
        structure Term : <sig>
        datatype preterm
          = Abs of {Body:preterm, Bvar:preterm}
          | Antiq of Term.term
          | Comb of {Rand:preterm, Rator:preterm}
          | Const of {Name:string, Ty:Term.Type.hol_type}
          | Constrained of preterm * Term.Type.hol_type
          | Var of {Name:string, Ty:Term.Type.hol_type}
        val typecheck : (int,Term.Type.hol_type) istream
                        -> preterm -> Term.term
      end
    datatype arg = Hty of Preterm.Term.Type.hol_type | Rec_occ
    datatype parse
      = PTM of Preterm.preterm
      | TY of Preterm.Term.Type.hol_type
      | TY_SPEC of {clauses:{args:arg list, constructor:string} list,
                    ty_name:string}
    val make_preterm : preterm_in_env -> Preterm.preterm
    val make_aq : Preterm.Term.term -> preterm_in_env
    val make_binding_occ : (int,Preterm.Term.Type.hol_type) istream
                           -> string -> binder_in_env
    val make_aq_binding_occ : (int,Preterm.Term.Type.hol_type) istream
                              -> Preterm.Term.term -> binder_in_env
    val make_atom : (int,Preterm.Term.Type.hol_type) istream
                    -> string -> preterm_in_env
    val make_string : string -> preterm_in_env
    val list_make_comb : preterm_in_env list -> preterm_in_env
    val bind_term : string
                    -> binder_in_env list -> preterm_in_env -> preterm_in_env
    val bind_restr_term : (int,Preterm.Term.Type.hol_type) istream
                          -> string
                             -> binder_in_env list
                                -> preterm_in_env
                                   -> preterm_in_env -> preterm_in_env
    val make_vstruct : (int,Preterm.Term.Type.hol_type) istream
                       -> binder_in_env list -> binder_in_env
    val make_constrained_vstruct : binder_in_env
                                   -> Preterm.Term.Type.hol_type
                                      -> binder_in_env
    val make_constrained : preterm_in_env
                           -> Preterm.Term.Type.hol_type -> preterm_in_env
    val make_let : (int,Preterm.Term.Type.hol_type) istream
                   -> (binder_in_env list * preterm_in_env) list
                      -> preterm_in_env -> preterm_in_env
    val make_list : (int,Preterm.Term.Type.hol_type) istream
                    -> preterm_in_env list -> preterm_in_env
    val make_set : (int,Preterm.Term.Type.hol_type) istream
                   -> preterm_in_env list -> preterm_in_env
    val make_set_abs : (int,Preterm.Term.Type.hol_type) istream
                       -> preterm_in_env * preterm_in_env -> preterm_in_env
    val make_atomic_type : string * string option -> Preterm.Term.Type.hol_type
    val make_type_app : string * Preterm.Term.Type.hol_type list
                        -> Preterm.Term.Type.hol_type
    val make_type_clause : {args:Preterm.Term.Type.hol_type list,
                            constructor:string}
                           -> {args:arg list, constructor:string}
    val rec_occ : Preterm.Term.Type.hol_type
    val prec_parse : preterm_in_env list -> preterm_in_env
    val is_binder : string -> bool
    val extract_type_antiq : Preterm.Term.term -> Preterm.Term.Type.hol_type
  end
val it = () : unit
GC #1.4.22.69.200.6265:   (30 ms)
GC #1.4.22.69.201.6283:   (40 ms)
[opening 0/parse_support.sml]
0/parse_support.sml:456.8-456.60 Warning: binding not exhaustive
          (_,tm) :: nil = ...
0/parse_support.sml:2.1-472.4 Warning: match nonexhaustive
          tm as Const {Name=Name,Ty=_} => ...
          Constrained (tm,_) => ...
  
0/parse_support.sml:275.25-275.43 Warning: binding not exhaustive
          b :: rst = ...
0/parse_support.sml:2.1-472.4 Warning: match nonexhaustive
          Tyapp {Args=_ :: ty :: nil,Tyop="fun"} => ...
  
0/parse_support.sml:2.1-472.4 Warning: match nonexhaustive
          Tyapp {Args=ty :: _ :: nil,Tyop="fun"} => ...
  
0/parse_support.sml:175.4-177.74 Warning: match nonexhaustive
          (tm1 :: (rst  as _ :: _),E) => ...
  
0/parse_support.sml:76.8-76.68 Warning: binding not exhaustive
          Const (c  as {Name=Name,Ty=Ty}) = ...
GC #1.4.22.69.202.6334:   (80 ms)
GC #1.4.22.70.203.6347:   (90 ms)
GC #1.4.22.70.204.6371:   (60 ms)
GC #1.5.23.71.205.6380:   (250 ms)
GC #1.5.24.72.206.6408:   (110 ms)
GC #1.5.24.72.207.6445:   (20 ms)
GC #1.5.24.72.208.6449:   (10 ms)
GC #1.5.24.72.209.6485:   (30 ms)
GC #1.5.24.73.210.6530:   (80 ms)
GC #1.5.24.74.211.6550:   (10 ms)
structure Parse_support : Parse_support_sig
val it = () : unit
[opening Grammars/hol.yak.sig]
signature Hol_TOKENS =
  sig
    type ('a,'b) token
    type svalue
    val EOF : 'a * 'a -> (svalue,'a) token
    val EOLEX : 'a * 'a -> (svalue,'a) token
    val string_ : string * 'a * 'a -> (svalue,'a) token
    val of_ : 'a * 'a -> (svalue,'a) token
    val in_ : 'a * 'a -> (svalue,'a) token
    val and_ : 'a * 'a -> (svalue,'a) token
    val let_ : 'a * 'a -> (svalue,'a) token
    val bar : 'a * 'a -> (svalue,'a) token
    val type_plus : 'a * 'a -> (svalue,'a) token
    val type_hash : 'a * 'a -> (svalue,'a) token
    val arrow : 'a * 'a -> (svalue,'a) token
    val eq : 'a * 'a -> (svalue,'a) token
    val eq_gt : 'a * 'a -> (svalue,'a) token
    val semi_colon : 'a * 'a -> (svalue,'a) token
    val dot : 'a * 'a -> (svalue,'a) token
    val dcolon : 'a * 'a -> (svalue,'a) token
    val colon : 'a * 'a -> (svalue,'a) token
    val type_comma : 'a * 'a -> (svalue,'a) token
    val rbrace : 'a * 'a -> (svalue,'a) token
    val lbrace : 'a * 'a -> (svalue,'a) token
    val rbracket : 'a * 'a -> (svalue,'a) token
    val lbracket : 'a * 'a -> (svalue,'a) token
    val type_rparen : 'a * 'a -> (svalue,'a) token
    val type_lparen : 'a * 'a -> (svalue,'a) token
    val rparen : 'a * 'a -> (svalue,'a) token
    val lparen : 'a * 'a -> (svalue,'a) token
    val aq : ?.CoreHol.PrivateTerm.term * 'a * 'a -> (svalue,'a) token
    val qualified_binder : (string * string) * 'a * 'a -> (svalue,'a) token
    val binder : string * 'a * 'a -> (svalue,'a) token
    val type_var_ident : string * 'a * 'a -> (svalue,'a) token
    val qualified_type_ident : (string * string) * 'a * 'a -> (svalue,'a) token
    val type_ident : string * 'a * 'a -> (svalue,'a) token
    val qualified_ident : (string * string) * 'a * 'a -> (svalue,'a) token
    val symbolic_ident : string * 'a * 'a -> (svalue,'a) token
    val ident : string * 'a * 'a -> (svalue,'a) token
  end
signature Hol_LRVALS =
  sig
    structure Tokens :
      sig
        type ('a,'b) token
        type svalue
        val EOF : 'a * 'a -> (svalue,'a) token
        val EOLEX : 'a * 'a -> (svalue,'a) token
        val string_ : string * 'a * 'a -> (svalue,'a) token
        val of_ : 'a * 'a -> (svalue,'a) token
        val in_ : 'a * 'a -> (svalue,'a) token
        val and_ : 'a * 'a -> (svalue,'a) token
        val let_ : 'a * 'a -> (svalue,'a) token
        val bar : 'a * 'a -> (svalue,'a) token
        val type_plus : 'a * 'a -> (svalue,'a) token
        val type_hash : 'a * 'a -> (svalue,'a) token
        val arrow : 'a * 'a -> (svalue,'a) token
        val eq : 'a * 'a -> (svalue,'a) token
        val eq_gt : 'a * 'a -> (svalue,'a) token
        val semi_colon : 'a * 'a -> (svalue,'a) token
        val dot : 'a * 'a -> (svalue,'a) token
        val dcolon : 'a * 'a -> (svalue,'a) token
        val colon : 'a * 'a -> (svalue,'a) token
        val type_comma : 'a * 'a -> (svalue,'a) token
        val rbrace : 'a * 'a -> (svalue,'a) token
        val lbrace : 'a * 'a -> (svalue,'a) token
        val rbracket : 'a * 'a -> (svalue,'a) token
        val lbracket : 'a * 'a -> (svalue,'a) token
        val type_rparen : 'a * 'a -> (svalue,'a) token
        val type_lparen : 'a * 'a -> (svalue,'a) token
        val rparen : 'a * 'a -> (svalue,'a) token
        val lparen : 'a * 'a -> (svalue,'a) token
        val aq : ?.CoreHol.PrivateTerm.term * 'a * 'a -> (svalue,'a) token
        val qualified_binder : (string * string) * 'a * 'a -> (svalue,'a) token
        val binder : string * 'a * 'a -> (svalue,'a) token
        val type_var_ident : string * 'a * 'a -> (svalue,'a) token
        val qualified_type_ident : (string * string) * 'a * 'a
                                   -> (svalue,'a) token
        val type_ident : string * 'a * 'a -> (svalue,'a) token
        val qualified_ident : (string * string) * 'a * 'a -> (svalue,'a) token
        val symbolic_ident : string * 'a * 'a -> (svalue,'a) token
        val ident : string * 'a * 'a -> (svalue,'a) token
      end
    structure ParserData :
      sig
        type pos
        type svalue
        type arg
        type result
        structure LrTable : <sig>
        structure Token : <sig>
        structure Actions : <sig>
        structure EC : <sig>
        val table : LrTable.table
        sharing LrTable = Token.LrTable
      end
    sharing type Tokens.svalue = ParserData.svalue
    sharing type Tokens.token = ParserData.Token.token
  end
val it = () : unit
GC #1.5.24.74.212.6583:   (40 ms)
GC #1.5.24.74.213.6605:   (100 ms)
GC #1.5.24.75.214.6608:   (40 ms)
GC #1.5.24.75.215.6689:   (110 ms)
GC #1.5.24.75.216.6720:   (100 ms)
GC #1.5.24.75.217.6744:   (80 ms)
GC #1.5.24.75.218.6769:   (150 ms)
GC #1.6.25.76.219.6777:   (330 ms)
GC #1.6.25.76.220.6817:   (40 ms)
GC #1.6.25.76.221.6855:   (50 ms)
GC #1.6.25.76.222.6904:   (30 ms)
GC #1.6.25.76.223.6994:   (0 ms)
[opening Grammars/hol.yak.sml]
functor HolLrValsFun : <sig>
val it = () : unit
GC #1.6.25.76.224.7004:   (10 ms)
GC #1.6.25.76.225.7024:   (40 ms)
GC #1.6.25.76.226.7038:   (70 ms)
GC #1.6.25.76.227.7053:   (60 ms)
[opening Grammars/hol.lex.sml]
Grammars/hol.lex.sml:554.25-554.40 Warning: binding contains no variables
          () = ...
Grammars/hol.lex.sml:553.15-553.45 Warning: binding not exhaustive
          L as ref (_ :: t) = ...
Grammars/hol.lex.sml:564.23-564.38 Warning: binding contains no variables
          () = ...
Grammars/hol.lex.sml:563.15-563.45 Warning: binding not exhaustive
          L as ref (_ :: t) = ...
Grammars/hol.lex.sml:573.24-573.67 Warning: binding contains no variables
          () = ...
Grammars/hol.lex.sml:572.24-572.39 Warning: binding contains no variables
          () = ...
Grammars/hol.lex.sml:571.15-571.45 Warning: binding not exhaustive
          L as ref (_ :: t) = ...
Grammars/hol.lex.sml:577.24-577.75 Warning: binding contains no variables
          () = ...
Grammars/hol.lex.sml:576.24-576.39 Warning: binding contains no variables
          () = ...
Grammars/hol.lex.sml:575.15-575.45 Warning: binding not exhaustive
          L as ref (x :: t) = ...
Grammars/hol.lex.sml:585.14-585.44 Warning: binding not exhaustive
          L as ref (x :: t) = ...
Grammars/hol.lex.sml:637.19-637.34 Warning: binding contains no variables
          () = ...
Grammars/hol.lex.sml:636.14-636.44 Warning: binding not exhaustive
          L as ref (x :: t) = ...
GC #1.6.25.76.228.7078:   (80 ms)
GC #1.6.25.76.229.7099:   (30 ms)
GC #1.6.25.76.230.7110:   (30 ms)
GC #1.6.25.76.231.7130:   (50 ms)
GC #1.6.25.76.232.7155:   (30 ms)
GC #1.6.25.76.233.7158:   (10 ms)
GC #1.6.25.76.234.7199:   (30 ms)
GC #1.6.25.76.235.7296:   (70 ms)
GC #1.6.26.77.236.7325:   (30 ms)
functor HolLex : <sig>
val it = () : unit
[opening 0/parse.sig]
signature Parse_sig =
  sig
    structure Parse_support :
      sig
        type preterm_in_env
        type binder_in_env
        structure Preterm : <sig>
        datatype arg = Hty of Preterm.Term.Type.hol_type | Rec_occ
        datatype parse
          = PTM of Preterm.preterm
          | TY of Preterm.Term.Type.hol_type
          | TY_SPEC of {clauses:{args:arg list, constructor:string} list,
                        ty_name:string}
        val make_preterm : preterm_in_env -> Preterm.preterm
        val make_aq : Preterm.Term.term -> preterm_in_env
        val make_binding_occ : (int,Preterm.Term.Type.hol_type) istream
                               -> string -> binder_in_env
        val make_aq_binding_occ : (int,Preterm.Term.Type.hol_type) istream
                                  -> Preterm.Term.term -> binder_in_env
        val make_atom : (int,Preterm.Term.Type.hol_type) istream
                        -> string -> preterm_in_env
        val make_string : string -> preterm_in_env
        val list_make_comb : preterm_in_env list -> preterm_in_env
        val bind_term : string
                        -> binder_in_env list
                           -> preterm_in_env -> preterm_in_env
        val bind_restr_term : (int,Preterm.Term.Type.hol_type) istream
                              -> string
                                 -> binder_in_env list
                                    -> preterm_in_env
                                       -> preterm_in_env -> preterm_in_env
        val make_vstruct : (int,Preterm.Term.Type.hol_type) istream
                           -> binder_in_env list -> binder_in_env
        val make_constrained_vstruct : binder_in_env
                                       -> Preterm.Term.Type.hol_type
                                          -> binder_in_env
        val make_constrained : preterm_in_env
                               -> Preterm.Term.Type.hol_type -> preterm_in_env
        val make_let : (int,Preterm.Term.Type.hol_type) istream
                       -> (binder_in_env list * preterm_in_env) list
                          -> preterm_in_env -> preterm_in_env
        val make_list : (int,Preterm.Term.Type.hol_type) istream
                        -> preterm_in_env list -> preterm_in_env
        val make_set : (int,Preterm.Term.Type.hol_type) istream
                       -> preterm_in_env list -> preterm_in_env
        val make_set_abs : (int,Preterm.Term.Type.hol_type) istream
                           -> preterm_in_env * preterm_in_env -> preterm_in_env
        val make_atomic_type : string * string option
                               -> Preterm.Term.Type.hol_type
        val make_type_app : string * Preterm.Term.Type.hol_type list
                            -> Preterm.Term.Type.hol_type
        val make_type_clause : {args:Preterm.Term.Type.hol_type list,
                                constructor:string}
                               -> {args:arg list, constructor:string}
        val rec_occ : Preterm.Term.Type.hol_type
        val prec_parse : preterm_in_env list -> preterm_in_env
        val is_binder : string -> bool
        val extract_type_antiq : Preterm.Term.term
                                 -> Preterm.Term.Type.hol_type
      end
    val parse0 : (int,Parse_support.Preterm.Term.Type.hol_type) istream
                 -> string
                    -> Parse_support.Preterm.Term.term list
                       -> Parse_support.parse
    val type_parser : Parse_support.Preterm.Term.term SMLofNJ.frag list
                      -> Parse_support.Preterm.Term.Type.hol_type
    val term_parser : Parse_support.Preterm.Term.term SMLofNJ.frag list
                      -> Parse_support.Preterm.Term.term
    val preterm_parser : (int,Parse_support.Preterm.Term.Type.hol_type) istream
                         -> Parse_support.Preterm.Term.term SMLofNJ.frag list
                            -> Parse_support.Preterm.preterm
    val -- : Parse_support.Preterm.Term.term SMLofNJ.frag list
             -> 'a -> Parse_support.Preterm.Term.term
    val == : Parse_support.Preterm.Term.term SMLofNJ.frag list
             -> 'a -> Parse_support.Preterm.Term.Type.hol_type
    val string_to_type : string -> Parse_support.Preterm.Term.Type.hol_type
    val string_to_preterm : (int,Parse_support.Preterm.Term.Type.hol_type) 
                              istream
                            -> string -> Parse_support.Preterm.preterm
    val string_to_term : string -> Parse_support.Preterm.Term.term
    val type_spec_parser : Parse_support.Preterm.Term.term SMLofNJ.frag list
                           -> {clauses:{args:Parse_support.arg list,
                                        constructor:string} list,
                               ty_name:string}
    val string_to_type_spec : string
                              -> {clauses:{args:Parse_support.arg list,
                                           constructor:string} list,
                                  ty_name:string}
  end
val it = () : unit
GC #1.6.26.77.237.7365:   (40 ms)
GC #1.6.26.77.238.7400:   (60 ms)
GC #1.6.26.77.239.7407:   (60 ms)
GC #1.6.26.77.240.7428:   (30 ms)
GC #1.6.26.77.241.7432:   (10 ms)
GC #1.6.26.77.242.7468:   (50 ms)
[opening 0/parse.sml]
structure Parse : Parse_sig
val it = () : unit
GC #1.6.26.77.243.7509:   (50 ms)
structure Library : Library_sig
GC #1.6.26.77.244.7534:   (20 ms)
[opening 0/theory/add_to_sml.sig]
signature Add_to_sml_sig =
  sig
    val L : (string * CoreHol.Thm.thm) list ref
    val parser : CoreHol.Thm.thm SMLofNJ.frag list -> CoreHol.Thm.thm
    val add_to_sml : (string * CoreHol.Thm.thm) list -> unit
    val add_axioms_to_sml : string -> unit
    val add_definitions_to_sml : string -> unit
    val add_theorems_to_sml : string -> unit
    val add_theory_to_sml : string -> unit
    val add_theory_structure_to_sml : {structure_name:string,
                                       theory_name:string}
                                      -> unit
    type autoload_info
    val set_autoloads : autoload_info -> unit
    val get_autoloads : string -> autoload_info option
  end
val it = () : unit
GC #1.6.26.77.245.7583:   (30 ms)
GC #1.6.26.77.246.7596:   (50 ms)
GC #1.6.26.77.247.7637:   (50 ms)
[opening 0/theory/add_to_sml.sml]
structure Add_to_sml : Add_to_sml_sig
val it = () : unit
GC #1.6.26.77.248.7645:   (10 ms)
[opening 0/install.sig]
signature Install_sig =
  sig
    val install_system_theory : string -> unit
    val install : string -> unit
  end
val it = () : unit
GC #1.6.26.77.249.7680:   (30 ms)
[opening 0/install.sml]
structure Install : Install_sig
val it = () : unit
structure Abbrev :
  sig
    type conv = ?.CoreHol.PrivateTerm.term -> CoreHol.Thm.thm
    type goal = ?.CoreHol.PrivateTerm.term list * ?.CoreHol.PrivateTerm.term
    type tactic = goal -> tactic_result
    type tactic_result = goal list * validation
    type thm_tactic = CoreHol.Thm.thm -> tactic
    type thm_tactical = thm_tactic -> thm_tactic
    type validation = CoreHol.Thm.thm list -> CoreHol.Thm.thm
  end
val it = () : unit
[opening /Nfs/bescot/grp11/hol/hol90.10/src/0/hol0.sml]
val it = fn : ?.PrettyPrint.ppstream -> CoreHol.Thm.thm -> unit
opening Abbrev
  type conv = ?.CoreHol.PrivateTerm.term -> CoreHol.Thm.thm
  type goal = ?.CoreHol.PrivateTerm.term list * ?.CoreHol.PrivateTerm.term
  type tactic = goal -> tactic_result
  type tactic_result = goal list * validation
  type thm_tactic = CoreHol.Thm.thm -> tactic
  type thm_tactical = thm_tactic -> thm_tactic
  type validation = CoreHol.Thm.thm list -> CoreHol.Thm.thm
opening Exception
  exception HOL_ERR of {message:string, origin_function:string,
                        origin_structure:string}
  val print_HOL_ERR : exn -> unit
  val Raise : exn -> 'a
structure EMPTY : sig end
functor CACHE : <sig>
functor CONST_DEF : <sig>
GC #1.6.26.77.250.7708:   (10 ms)
functor CONST_SPEC : <sig>
functor DSYNTAX : <sig>
functor EXISTS_DEF : <sig>
functor HOL_LEX : <sig>
functor HOL_PP : <sig>
functor HolLrValsFun : <sig>
functor INSTALL : <sig>
functor MATCH : <sig>
functor NET : <sig>
functor PARSE_SUPPORT : <sig>
functor PRETERM : <sig>
functor TERM : <sig>
functor THM : <sig>
functor THY_LEX : <sig>
functor THY_PARSE : <sig>
functor THY_PP : <sig>
functor thyLrValsFun : <sig>
functor TYPE_DEF : <sig>
functor UID : <sig>
val it = () : unit
GC #2.7.27.78.251.7731:   (560 ms)
write 1,0: 8328 bytes [0xec790000..0xec792088) @ 0x2000
write 1,1: 7136 bytes [0xec840008..0xec841be8) @ 0x5000
write 1,2: 2876 bytes [0xec8f0000..0xec8f0b3c) @ 0x7000
write 1,3: 1108 bytes [0xec990000..0xec990454) @ 0x8000
write 2,0: 32880 bytes [0xed810000..0xed818070) @ 0x9000
write 2,1: 84640 bytes [0xed850008..0xed864aa8) @ 0x12000
write 2,2: 2748 bytes [0xed8e0000..0xed8e0abc) @ 0x27000
write 2,3: 34312 bytes [0xed8f0000..0xed8f8608) @ 0x28000
write 2,0: 28 big objects (136 pages) @ 0x31000
write 3,0: 4040 bytes [0xef310000..0xef310fc8) @ 0x531c0
write 3,1: 14040 bytes [0xef320008..0xef3236e0) @ 0x541c0
write 3,2: 628 bytes [0xef360000..0xef360274) @ 0x581c0
write 3,3: 2880 bytes [0xef370000..0xef370b40) @ 0x591c0
write 3,0: 1 big objects (56 pages) @ 0x5a1c0
write 4,0: 7120 bytes [0xef290000..0xef291bd0) @ 0x681d0
write 4,1: 39456 bytes [0xef2a0008..0xef2a9a28) @ 0x6a1d0
write 4,2: 1568 bytes [0xef2c0000..0xef2c0620) @ 0x741d0
write 4,3: 1376 bytes [0xef2d0000..0xef2d0560) @ 0x751d0
write 4,0: 1 big objects (51 pages) @ 0x761d0
write 5,0: 790780 bytes [0xec250000..0xec3110fc) @ 0x82de0
write 5,1: 1465880 bytes [0xec3b0008..0xec515e20) @ 0x144de0
write 5,2: 340788 bytes [0xec650000..0xec6a3334) @ 0x2aade0
write 5,3: 147320 bytes [0xec6f0000..0xec713f78) @ 0x2fede0
write 5,0: 370 big objects (7226 pages) @ 0x322de0
val it = () : unit
- val it = () : unit
- [opening /Nfs/bescot/grp11/hol/hol90.10/theories/src/min.sig]
signature Min_sig = sig end
val it = () : unit
GC #0.0.0.0.1.12:   (20 ms)
[opening /Nfs/bescot/grp11/hol/hol90.10/theories/src/mk_min.sml]

Theory "min" declared.

Theory "min" exported.
structure Min : Min_sig
val it = () : unit
- val it = () : unit
- [opening /Nfs/bescot/grp11/hol/hol90.10/theories/src/min.sig]
signature Min_sig = sig end
val it = () : unit
GC #0.0.0.0.1.13:   (20 ms)
[opening /Nfs/bescot/grp11/hol/hol90.10/theories/src/ld_min.sml]

Loading theory "min"
structure Min : Min_sig
val it = () : unit
[opening /Nfs/bescot/grp11/hol/hol90.10/src/0/exists_def.sig]
signature Exists_def_sig =
  sig
    structure Theory :
      sig
        structure Thm : <sig>
        val new_parent : string -> unit
        val new_type : {Arity:int, Name:string} -> unit
        val new_constant : {Name:string, Ty:Thm.Term.Type.hol_type} -> unit
        val new_infix : {Name:string, Prec:int, Ty:Thm.Term.Type.hol_type}
                        -> unit
        val new_binder : {Name:string, Ty:Thm.Term.Type.hol_type} -> unit
        val new_open_axiom : string * Thm.Term.term -> Thm.thm
        val store_definition : string * Thm.Term.term -> Thm.thm
        val save_thm : string * Thm.thm -> Thm.thm
        val arity : string -> int
        val fixity : string -> Thm.Term.fixity
        val precedence : string -> int
        val const_decl : string
                         -> {const:Thm.Term.term, place:Thm.Term.fixity,
                             theory:string}
        val is_constant : string -> bool
        val is_type : string -> bool
        val is_binder : string -> bool
        val is_infix : string -> bool
        val draft_mode : unit -> bool
        val current_theory : unit -> string
        val parents : string -> string list
        val ancestry : string -> string list
        val types : string -> {Arity:int, Name:string} list
        val constants : string -> Thm.Term.term list
        val infixes : string -> Thm.Term.term list
        val binders : string -> Thm.Term.term list
        val axioms : string -> (string * Thm.thm) list
        val axiom : string -> string -> Thm.thm
        val definitions : string -> (string * Thm.thm) list
        val definition : string -> string -> Thm.thm
        val theorems : string -> (string * Thm.thm) list
        val theorem : string -> string -> Thm.thm
        val print_theory_to_outstream : {outstream:Portable.outstream,
                                         theory:string}
                                        -> Portable.outstream
        val print_theory_to_file : {file:string, theory:string} -> unit
        val print_theory : string -> unit
        val html_theory : string -> unit
        val new_theory : string -> unit
        val close_theory : unit -> unit
        val load_theory : string -> unit
        val extend_theory : string -> unit
        val export_theory : unit -> unit
        val close : unit -> unit
        val delete_cache : unit -> unit
        val delete_theory_from_cache : string -> unit
        val theories_in_cache : unit -> string list
        val perform_atomic_theory_op : (unit -> 'a) -> 'a
        val loadLibThry : string -> string -> unit
      end
    val new_binder_definition : string * Theory.Thm.Term.term -> Theory.Thm.thm
  end
val it = () : unit
GC #0.0.0.0.2.40:   (20 ms)
GC #0.0.0.1.3.57:   (50 ms)
[opening /Nfs/bescot/grp11/hol/hol90.10/src/0/exists_def.sml]
functor EXISTS_DEF : <sig>
val it = () : unit
[opening /Nfs/bescot/grp11/hol/hol90.10/theories/src/exists.sig]
signature Exists_sig = sig val EXISTS_DEF : CoreHol.Thm.thm end
val it = () : unit
[opening /Nfs/bescot/grp11/hol/hol90.10/theories/src/mk_exists.sml]

Declaring theory "bool".

Theory "min" already consistent with disk, hence not exported.

Theory "bool" closed.

Theory "bool" exported.
structure Exists : Exists_sig
val it = () : unit
GC #0.0.0.1.4.88:   (0 ms)
[opening /Nfs/bescot/grp11/hol/hol90.10/theories/src/bool.sig]
signature boolThrySig =
  sig
    structure Min : sig end
    val T_DEF : CoreHol.Thm.thm
    val FORALL_DEF : CoreHol.Thm.thm
    val AND_DEF : CoreHol.Thm.thm
    val OR_DEF : CoreHol.Thm.thm
    val F_DEF : CoreHol.Thm.thm
    val NOT_DEF : CoreHol.Thm.thm
    val EXISTS_UNIQUE_DEF : CoreHol.Thm.thm
    val LET_DEF : CoreHol.Thm.thm
    val COND_DEF : CoreHol.Thm.thm
    val ONE_ONE_DEF : CoreHol.Thm.thm
    val ONTO_DEF : CoreHol.Thm.thm
    val TYPE_DEFINITION : CoreHol.Thm.thm
    val BOOL_CASES_AX : CoreHol.Thm.thm
    val IMP_ANTISYM_AX : CoreHol.Thm.thm
    val ETA_AX : CoreHol.Thm.thm
    val SELECT_AX : CoreHol.Thm.thm
    val INFINITY_AX : CoreHol.Thm.thm
  end
val it = () : unit
GC #0.0.0.1.5.123:   (20 ms)
[opening /Nfs/bescot/grp11/hol/hol90.10/theories/src/mk_bool.sml]

Extending theory "bool"

Theory "bool" exported.
structure boolThry : boolThrySig
val it = () : unit
- 