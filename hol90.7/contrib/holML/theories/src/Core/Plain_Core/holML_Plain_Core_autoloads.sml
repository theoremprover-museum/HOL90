val _ = set_autoloads
{Theory = "holML_Plain_Core",
 Axioms = [],
 Definitions =
 ["is_ASSGval_DEF","is_SVALval_DEF","SVALval_arg_DEF","is_BASval_DEF",
  "is_CONval_DEF",
  "is_APPCONval_DEF",
  "is_EXVALval_DEF",
  "is_RECORDval_DEF",
  "is_ADDRval_DEF",
  "is_CLOSUREval_DEF","CLOSUREval_arg_DEF",
  "is_NAMEexval_DEF",
  "is_NAMEVALexval_DEF",
  "RECORD_arg_DEF",
  "CLOSURE_arg1_DEF","CLOSURE_arg2_DEF","CLOSURE_arg3_DEF","ENV_arg1_DEF",
  "ENV_arg2_DEF","ENV_arg3_DEF","VARENV_arg_DEF","STRENV_arg_DEF",
  "empty_record_DEF","empty_varenv_DEF","empty_strenv_DEF",
  "label_in_rec_DEF",
  "lookup_label_DEF","field1_val_DEF","field2_val_DEF",
  "insert_into_record_DEF",
  "add_record_DEF",
  "intfield1_DEF","intfield2_DEF",
  "strfield1_DEF","strfield2_DEF","lookupstrid_DEF","lookuplongstrid_env_DEF",
  "lookupvar_DEF","lookupexcon_DEF","lookuplongvar_env_DEF",
  "lookuplongexcon_env_DEF","insert_into_varenv_DEF",
  "add_varenv_DEF","insert_into_strenv_DEF",
  "add_strenv_DEF","add_env_DEF","add_nonemptylist_env_DEF","rec_helper_DEF",
  "rec_varenv_DEF","PACK_arg_DEF","is_VALvp_DEF","is_PACKvp_DEF",
  "VALvp_arg_DEF","PACKvp_arg_DEF","is_RECORDrp_DEF","RECORDrp_arg_DEF",
  "PACKrp_arg_DEF","is_VALvpf_DEF","is_PACKvpf_DEF","VALvpf_arg_DEF",
  "PACKvpf_arg_DEF","is_ENVep_DEF","ENVep_arg_DEF","PACKep_arg_DEF",
  "is_VARENVvep_DEF","VARENVvep_arg_DEF","PACKvep_arg_DEF",
  "is_EXCONENVeep_DEF","EXCONENVeep_arg_DEF","PACKeep_arg_DEF",
  "is_VARENVvef_DEF","is_FAILvef_DEF","VARENVvef_arg_DEF",
  "MEM_arg_DEF","STATE_arg1_DEF","STATE_arg2_DEF",
  "lookupaddr_mem_DEF","lookupaddr_DEF","new_exname_DEF","add_exname_DEF",
  "new_addr_DEF",
  "insert_into_mem_DEF","insert_into_state_mem_DEF","explode_str_DEF",
  "implode_DEF","initial_varenv_DEF","initial_exconenv_DEF",
  "initial_strenv_DEF","initial_env_DEF","initial_state_DEF",
  "apply_DEF","eval_exbind_pred_DEF","eval_exbind_DEF",
  "eval_pat_pred_DEF","eval_atpat_DEF","eval_patrow_DEF",
  "eval_pred_DEF","eval_atexp_DEF","eval_exprow_DEF","eval_exp_DEF",
  "eval_match_DEF","eval_mrule_DEF","eval_dec_DEF","eval_valbind_DEF",
  "eval_pat_DEF"],
 Theorems =
 ["env_existence","env_induct","env_unique","env_constructors_distinct",
  "env_constructors_one_one","env_cases",
  "LABEL_11","label_in_rec_lemma","lookup_label_lemma",
  "pack_Axiom","pack_induction_thm","pack_cases_thm",
  "pack_constructors_one_one","val_pack_Axiom","val_pack_induction_thm",
  "val_pack_cases_thm","val_pack_constructors_one_one",
  "val_pack_constructors_distinct","record_pack_Axiom",
  "record_pack_induction_thm","record_pack_cases_thm",
  "record_pack_constructors_one_one","record_pack_constructors_distinct",
  "val_pack_fail_Axiom","val_pack_fail_induction_thm",
  "val_pack_fail_cases_thm","val_pack_fail_constructors_one_one",
  "val_pack_fail_constructors_distinct",
  "env_pack_Axiom","env_pack_induction_thm","env_pack_cases_thm",
  "env_pack_constructors_one_one","env_pack_constructors_distinct",
  "varenv_pack_Axiom","varenv_pack_induction_thm","varenv_pack_cases_thm",
  "varenv_pack_constructors_one_one","varenv_pack_constructors_distinct",
  "exconenv_pack_Axiom","exconenv_pack_induction_thm",
  "exconenv_pack_cases_thm","exconenv_pack_constructors_one_one",
  "exconenv_pack_constructors_distinct","varenv_fail_Axiom",
  "varenv_fail_induction_thm","varenv_fail_cases_thm",
  "varenv_fail_constructors_one_one","varenv_fail_constructors_distinct",
  "mem_Axiom","mem_induction_thm","mem_cases_thm","mem_constructors_one_one",
  "state_Axiom","state_induction_thm","state_cases_thm",
  "state_constructors_one_one","EVAL_EXBIND_RULES_SATISFIED",
  "EVAL_PAT_RULES_SATISFIED","EVAL_RULES_SATISFIED",
  "eval_exbind_induction","eval_pat_induction","eval_induction"]}