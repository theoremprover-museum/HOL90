head	1.1;
access;
symbols;
locks; strict;
comment	@# @;


1.1
date	96.02.08.00.36.00;	author drs1004;	state Exp;
branches;
next	;


desc
@@


1.1
log
@New theory mechanism, code reorganisation and other enhancements by Don Syme.
@
text
@
structure Quant_convs : Quant_convs_sig =
struct

    open Lib Rterms Parse;
       infix |-> -->
       open Drule Conv Ho_match Theorems Tactic Tactical Rules Thm_cont;
	   
    infix THEN

    val ERR = Exception.ERR "Quant_convs";
    val WRAP_ERR = Exception.WRAP_ERR "Quant_convs";
	
(* =====================================================================*)
(* What follows is a complete set of conversions for moving ! and ? into*)
(* and out of the basic logical connectives ~, /\, \/, ==>, and =.	*)
(*									*)
(* Naming scheme:							*)
(*									*)
(*   1: for moving quantifiers inwards:  <quant>_<conn>_CONV		*)
(*									*)
(*   2: for moving quantifiers outwards: [dir]_<conn>_<quant>_CONV      *)
(*									*)
(* where								*)
(*									*)
(*   <quant> := FORALL | EXISTS						*)
(*   <conn>  := NOT | AND | OR | IMP | EQ				*)
(*   [dir]   := LEFT | RIGHT			(optional)		*)
(*									*)
(*									*)
(* [TFM 90.11.09]							*)
(* =====================================================================*)

(* ---------------------------------------------------------------------
 * NOT_FORALL_CONV, implements the following axiom scheme:		
 *									
 *      |- (~!x.tm) = (?x.~tm)						
 * 
 * NOT_FORALL_CONV (--`~(!x. P x)`--);
 * NOT_FORALL_CONV (--`~(!x. x < x)`--);
 * NOT_FORALL_CONV (--`~(!y. y < y)`--);
 *
 * Pre Higher Order Matching Version:
 * 
 * fun NOT_FORALL_CONV tm =
 *    let val all = dest_neg tm
 *        val {Bvar,Body} = dest_forall all
 *        val exists = mk_exists{Bvar = Bvar, Body = mk_neg Body} 
 *        val nott = ASSUME (mk_neg Body) 
 *        val not_all = mk_neg all
 *        val th1 = DISCH all (MP nott (SPEC Bvar (ASSUME all))) 
 *        val imp1 = DISCH exists (CHOOSE (Bvar, ASSUME exists) (NOT_INTRO th1)) 
 *        val th2 = CCONTR Body (MP (ASSUME(mk_neg exists))
 *                               (EXISTS(exists,Bvar) nott)) 
 *        val th3 = CCONTR exists (MP (ASSUME not_all) (GEN Bvar th2)) 
 *    in
 *    IMP_ANTISYM_RULE (DISCH not_all th3) imp1 
 *    end
 *    handle _ => ERR("NOT_FORALL_CONV", "");
 * ---------------------------------------------------------------------*)

fun wrap s (f:Abbrev.conv) x = f x handle e => WRAP_ERR(s,e);
val match = HO_PART_MATCH lhs;

val NOT_FORALL_CONV = wrap "NOT_FORALL_CONV" (match NOT_FORALL_THM);

(* ---------------------------------------------------------------------
 * NOT_EXISTS_CONV, implements the following axiom scheme.		
 *									
 *	|- (~?x.tm) = (!x.~tm)						
 *									
 * fun NOT_EXISTS_CONV tm =
 *    let val {Bvar,Body} = dest_exists (dest_neg tm) 
 *        val all = mk_forall{Bvar = Bvar, Body = mk_neg Body}
 *        val rand_tm = rand tm
 *        val asm1 = ASSUME Body 
 *        val thm1 = MP (ASSUME tm) (EXISTS (rand_tm, Bvar) asm1) 
 *        val imp1 = DISCH tm (GEN Bvar (NOT_INTRO (DISCH Body thm1))) 
 *        val asm2 = ASSUME  all 
 *        and asm3 = ASSUME rand_tm
 *        val thm2 = DISCH rand_tm (CHOOSE (Bvar,asm3) (MP (SPEC Bvar asm2) asm1))
 *        val imp2 = DISCH all (NOT_INTRO thm2) 
 *    in
 *    IMP_ANTISYM_RULE imp1 imp2
 *    end
 *    handle _ => ERR("NOT_EXISTS_CONV", "");
 * ---------------------------------------------------------------------*)

val NOT_EXISTS_CONV = wrap "NOT_EXISTS_CONV" (match NOT_EXISTS_THM);

(* ---------------------------------------------------------------------*)
(* EXISTS_NOT_CONV, implements the following axiom scheme.		*)
(*									*)
(*	|- (?x.~tm) = (~!x.tm)						*)
(*									*)
(* ---------------------------------------------------------------------*)
val EXISTS_NOT_CONV = wrap "EXISTS_NOT_CONV" (match EXISTS_NOT_THM);

(*
 * fun EXISTS_NOT_CONV tm = 
 *    let val {Bvar,Body} = dest_exists tm
 *    in
 *    SYM(NOT_FORALL_CONV (mk_neg (mk_forall{Bvar = Bvar, Body = dest_neg Body})))
 *    end
 *    handle _ => ERR("EXISTS_NOT_CONV", "");
*)

(* ---------------------------------------------------------------------*)
(* FORALL_NOT_CONV, implements the following axiom scheme.		*)
(*									*)
(*	|- (!x.~tm) = (~?x.tm)						*)
(*									*)
(* ---------------------------------------------------------------------*)
val FORALL_NOT_CONV = wrap "FORALL_NOT_CONV" (match FORALL_NOT_THM);

(*
 * fun FORALL_NOT_CONV tm = 
 *    let val {Bvar,Body} = dest_forall tm
 *    in
 *    SYM(NOT_EXISTS_CONV (mk_neg (mk_exists{Bvar = Bvar,Body = dest_neg Body})))
 *    end
 *    handle _ => ERR("FORALL_NOT_CONV", "");
*)


(* ---------------------------------------------------------------------*)
(* FORALL_AND_CONV : move universal quantifiers into conjunction.	*)
(*									*)
(* A call to FORALL_AND_CONV "!x. P /\ Q"  returns:			*)
(*									*)
(*   |- (!x. P /\ Q) = (!x.P) /\ (!x.Q)					*)
(* ---------------------------------------------------------------------*)

val FORALL_AND_CONV = wrap "FORALL_AND_CONV" (match FORALL_AND_THM);
(*
 * fun FORALL_AND_CONV tm = 
 *     let val {Bvar,Body} = dest_forall tm
 *         val {...} = dest_conj Body
 *         val (Pth,Qth) = CONJ_PAIR (SPEC Bvar (ASSUME tm)) 
 *         val imp1 = DISCH tm (CONJ (GEN Bvar Pth) (GEN Bvar Qth)) 
 *         val xtm = rand(concl imp1) 
 *         val spec_bv = SPEC Bvar
 *         val (t1,t2) = (spec_bv##spec_bv) (CONJ_PAIR (ASSUME xtm)) 
 *     in
 *     IMP_ANTISYM_RULE imp1 (DISCH xtm (GEN Bvar (CONJ t1 t2)))
 *     end
 *     handle _ => ERR("FORALL_AND_CONV", "");
*)

(* ---------------------------------------------------------------------*)
(* EXISTS_OR_CONV : move existential quantifiers into disjunction.	*)
(*									*)
(* A call to EXISTS_OR_CONV "?x. P \/ Q"  returns:			*)
(*									*)
(*   |- (?x. P \/ Q) = (?x.P) \/ (?x.Q)					*)
(* ---------------------------------------------------------------------*)

val EXISTS_OR_CONV = wrap "EXISTS_OR_CONV" (match EXISTS_OR_THM);
(*

 * fun EXISTS_OR_CONV tm = 
 *    let val {Bvar,Body} = dest_exists tm
 *        val {disj1,disj2} = dest_disj Body
 *        val ep = mk_exists{Bvar = Bvar, Body = disj1} 
 *        and eq = mk_exists{Bvar = Bvar, Body = disj2}
 *        val ep_or_eq = mk_disj{disj1 = ep, disj2 = eq}
 *        val aP = ASSUME disj1
 *        val aQ = ASSUME disj2
 *        val Pth = EXISTS(ep,Bvar) aP
 *        and Qth = EXISTS(eq,Bvar) aQ 
 *        val thm1 = DISJ_CASES_UNION (ASSUME Body) Pth Qth 
 *        val imp1 = DISCH tm (CHOOSE (Bvar,ASSUME tm) thm1) 
 *        val t1 = DISJ1 aP disj2 
 *        and t2 = DISJ2 disj1 aQ 
 *        val th1 = EXISTS(tm,Bvar) t1 
 *        and th2 = EXISTS(tm,Bvar) t2 
 *        val e1 = CHOOSE (Bvar,ASSUME ep) th1 
 *        and e2 = CHOOSE (Bvar,ASSUME eq) th2 
 *    in
 *    IMP_ANTISYM_RULE imp1 (DISCH ep_or_eq (DISJ_CASES (ASSUME ep_or_eq) e1 e2))
 *    end
 *    handle _ => ERR("EXISTS_OR_CONV", "");
*)

(* ---------------------------------------------------------------------*)
(* AND_FORALL_CONV : move universal quantifiers out of conjunction.	*)
(*									*)
(* A call to AND_FORALL_CONV "(!x. P) /\ (!x. Q)"  returns:		*)
(*									*)
(*   |- (!x.P) /\ (!x.Q) = (!x. P /\ Q) 				*)
(* ---------------------------------------------------------------------*)

val AND_FORALL_CONV = wrap "AND_FORALL_CONV" (match AND_FORALL_THM);

(*
 * fun AND_FORALL_CONV tm = 
 *    let val {conj1,conj2} = dest_conj tm
 *        val {Bvar = x, Body = P} = dest_forall conj1
 *                                   handle _ => raise BAD_STRUCT
 *        val {Bvar = y, Body = Q} = dest_forall conj2
 *                                   handle _ => raise BAD_STRUCT
 *    in
 *    if (not (x=y))
 *    then ERR("AND_FORALL_CONV","forall'ed variables not the same")
 *    else let val specx = SPEC x
 *             val (t1,t2) = (specx##specx) (CONJ_PAIR (ASSUME tm)) 
 *             val imp1 = DISCH tm (GEN x (CONJ t1 t2)) 
 *             val rtm = rand(concl imp1) 
 *             val (Pth,Qth) = CONJ_PAIR (SPEC x (ASSUME rtm)) 
 *         in
 *         IMP_ANTISYM_RULE imp1 (DISCH rtm (CONJ (GEN x Pth) (GEN x Qth)))
 *         end
 *    end
 *    handle BAD_STRUCT => ERR("AND_FORALL_CONV","argument not well-formed")
 *         | e => WRAP_ERR("AND_FORALL_CONV",e);
 *)


(* ---------------------------------------------------------------------*)
(* LEFT_AND_FORALL_CONV : move universal quantifier out of conjunction.	*)
(*									*)
(* A call to LEFT_AND_FORALL_CONV "(!x.P) /\  Q"  returns:		*)
(*									*)
(*   |- (!x.P) /\ Q = (!x'. P[x'/x] /\ Q) 				*)
(* 									*)
(* Where x' is a primed variant of x not free in the input term		*)
(* ---------------------------------------------------------------------*)
val LEFT_AND_FORALL_CONV = wrap "LEFT_AND_FORALL_CONV" (match LEFT_AND_FORALL_THM);

(* fun LEFT_AND_FORALL_CONV tm = 
 *    let val {conj1,...} = dest_conj tm
 *        val {Bvar,...} = dest_forall conj1
 *        val x' = variant (free_vars tm) Bvar 
 *        val specx' = SPEC x'
 *        and genx' = GEN x'
 *        val (t1,t2) = (specx' ## I) (CONJ_PAIR (ASSUME tm)) 
 *        val imp1 = DISCH tm (genx' (CONJ t1 t2)) 
 *        val rtm = rand(concl imp1) 
 *        val (Pth,Qth) = CONJ_PAIR (specx' (ASSUME rtm)) 
 *    in
 *    IMP_ANTISYM_RULE imp1 (DISCH rtm (CONJ (genx' Pth)  Qth))
 *    end
 *    handle _ => ERR("LEFT_AND_FORALL_CONV", "");
*)


(* ---------------------------------------------------------------------*)
(* RIGHT_AND_FORALL_CONV : move universal quantifier out of conjunction.*)
(*									*)
(* A call to RIGHT_AND_FORALL_CONV "P /\ (!x.Q)"  returns:		*)
(*									*)
(*   |-  P /\ (!x.Q) = (!x'. P /\ Q[x'/x]) 				*)
(* 									*)
(* where x' is a primed variant of x not free in the input term		*)
(* ---------------------------------------------------------------------*)

val RIGHT_AND_FORALL_CONV = wrap "RIGHT_AND_FORALL_CONV" (match RIGHT_AND_FORALL_THM);

(*
 * fun RIGHT_AND_FORALL_CONV tm = 
 *    let val {conj2, ...} = dest_conj tm
 *        val {Bvar,...} = dest_forall conj2
 *        val x' = variant (free_vars tm) Bvar
 *        val specx' = SPEC x'
 *        val genx' = GEN x'
 *        val (t1,t2) = (I ## specx') (CONJ_PAIR (ASSUME tm)) 
 *        val imp1 = DISCH tm (genx' (CONJ t1 t2)) 
 *        val rtm = rand(concl imp1) 
 *        val (Pth,Qth) = CONJ_PAIR (specx' (ASSUME rtm)) 
 *    in
 *    IMP_ANTISYM_RULE imp1 (DISCH rtm (CONJ Pth (genx' Qth)))
 *    end
 *    handle _ => ERR("RIGHT_AND_FORALL_CONV","");
 *)

(* ---------------------------------------------------------------------*)
(* OR_EXISTS_CONV : move existential quantifiers out of disjunction.	*)
(*									*)
(* A call to OR_EXISTS_CONV "(?x. P) \/ (?x. Q)"  returns:		*)
(*									*)
(*   |- (?x.P) \/ (?x.Q) = (?x. P \/ Q) 				*)
(* ---------------------------------------------------------------------*)
val OR_EXISTS_CONV = wrap "OR_EXISTS_CONV" (match OR_EXISTS_THM);
(*
 * fun OR_EXISTS_CONV tm = 
 *    let val {disj1,disj2} = dest_disj tm
 *        val {Bvar = x, Body = P} = dest_exists disj1
 *        val {Bvar = y, Body = Q} = dest_exists disj2
 *    in
 *    if (not (x=y)) 
 *    then ERR("OR_EXISTS_CONV",
 *                    "existentially quantified variables not the same")
 *    else let val aP = ASSUME P
 *             and aQ = ASSUME Q
 *             and P_or_Q = mk_disj{disj1 = P, disj2 = Q}
 *             val otm = mk_exists {Bvar = x, Body = P_or_Q}
 *             val t1 = DISJ1 aP Q 
 *             and t2 = DISJ2 P aQ
 *             val eotm = EXISTS(otm,x)   
 *             val e1 = CHOOSE (x,ASSUME disj1) (eotm t1)
 *             and e2 = CHOOSE (x,ASSUME disj2) (eotm t2)
 *             val thm1 = DISJ_CASES (ASSUME tm) e1 e2 
 *             val imp1 = DISCH tm thm1 
 *             val Pth = EXISTS(disj1,x) aP 
 *             and Qth = EXISTS(disj2,x) aQ 
 *             val thm2 = DISJ_CASES_UNION (ASSUME P_or_Q) Pth Qth 
 *         in
 *         IMP_ANTISYM_RULE imp1 (DISCH otm (CHOOSE (x,ASSUME otm) thm2))
 *         end
 *    end
 *    handle e => WRAP_ERR("OR_EXISTS_CONV",e);
*)

(* ---------------------------------------------------------------------
 * LEFT_OR_EXISTS_CONV : move existential quantifier out of disjunction.
 *									
 * A call to LEFT_OR_EXISTS_CONV "(?x.P) \/  Q"  returns:		
 *									
 *   |- (?x.P) \/ Q = (?x'. P[x'/x] \/ Q) 				
 * 									
 * Where x' is a primed variant of x not free in the input term		
 *
* LEFT_OR_EXISTS_CONV (--`(?x. x < y) \/ (x > y)`--);
* LEFT_OR_EXISTS_CONV (--`(?x'. x' < y) \/ (x' > y)`--);

 * ---------------------------------------------------------------------*)
val LEFT_OR_EXISTS_CONV = wrap "LEFT_OR_EXISTS_CONV" (match LEFT_OR_EXISTS_THM);

(*fun LEFT_OR_EXISTS_CONV tm = 
 *    let val {disj1,disj2} = dest_disj tm
 *        val {Bvar,Body} = dest_exists disj1
 *        val x' = variant (free_vars tm) Bvar 
 *        val newp = subst[{redex = Bvar, residue = x'}] Body
 *        val newp_thm = ASSUME newp
 *        val new_disj = mk_disj {disj1 = newp, disj2 = disj2}
 *        val otm = mk_exists {Bvar = x', Body = new_disj}
 *        and Qth = ASSUME disj2
 *        val t1 = DISJ1 newp_thm disj2 
 *        and t2 = DISJ2 newp (ASSUME disj2) 
 *        val th1 = EXISTS(otm,x') t1 
 *        and th2 = EXISTS(otm,x') t2 
 *        val thm1 = DISJ_CASES (ASSUME tm) (CHOOSE(x',ASSUME disj1)th1) th2 
 *        val imp1 = DISCH tm thm1 
 *        val Pth = EXISTS(disj1,x') newp_thm
 *        val thm2 = DISJ_CASES_UNION (ASSUME new_disj) Pth Qth 
 *    in
 *    IMP_ANTISYM_RULE imp1 (DISCH otm (CHOOSE (x',ASSUME otm) thm2))
 *    end
 *    handle _ => ERR("LEFT_OR_EXISTS_CONV", "");
 *)
(* ---------------------------------------------------------------------*)
(* RIGHT_OR_EXISTS_CONV: move existential quantifier out of disjunction.*)
(*									*)
(* A call to RIGHT_OR_EXISTS_CONV "P \/ (?x.Q)"  returns:		*)
(*									*)
(*   |-  P \/ (?x.Q) = (?x'. P \/ Q[x'/x]) 				*)
(* 									*)
(* where x' is a primed variant of x not free in the input term		*)
(* ---------------------------------------------------------------------*)
val RIGHT_OR_EXISTS_CONV = wrap "RIGHT_OR_EXISTS_CONV" (match RIGHT_OR_EXISTS_THM);
(*
 * fun RIGHT_OR_EXISTS_CONV tm = 
 *    let val {disj1,disj2} = dest_disj tm
 *        val {Bvar,Body} = dest_exists disj2
 *        val x' = variant (free_vars tm) Bvar 
 *        val newq = subst[{redex = Bvar, residue = x'}] Body
 *        val newq_thm = ASSUME newq
 *        and Pth = ASSUME disj1
 *        val P_or_newq = mk_disj{disj1 = disj1, disj2 = newq}
 *        val otm = mk_exists{Bvar = x',Body = P_or_newq}
 *        val eotm' = EXISTS(otm,x')
 *        val th1 = eotm' (DISJ2 disj1 newq_thm)
 *        and th2 = eotm' (DISJ1 Pth newq)
 *        val thm1 = DISJ_CASES (ASSUME tm) th2 (CHOOSE(x',ASSUME disj2) th1)
 *        val imp1 = DISCH tm thm1 
 *        val Qth = EXISTS(disj2,x') newq_thm
 *        val thm2 = DISJ_CASES_UNION (ASSUME P_or_newq) Pth Qth 
 *    in
 *    IMP_ANTISYM_RULE imp1 (DISCH otm (CHOOSE (x',ASSUME otm) thm2))
 *    end
 *    handle _ => ERR("RIGHT_OR_EXISTS_CONV", "");
 *)

(* ---------------------------------------------------------------------*)
(* EXISTS_AND_CONV : move existential quantifier into conjunction.	*)
(*									*)
(* A call to EXISTS_AND_CONV "?x. P /\ Q"  returns:			*)
(*									*)
(*    |- (?x. P /\ Q) = (?x.P) /\ Q        [x not free in Q]		*)
(*    |- (?x. P /\ Q) = P /\ (?x.Q)        [x not free in P]		*)
(*    |- (?x. P /\ Q) = (?x.P) /\ (?x.Q)   [x not free in P /\ Q]	*)
(* ---------------------------------------------------------------------*)
val EXISTS_AND_CONV = 
    wrap "EXISTS_AND_CONV" (FIRST_CONV [match TRIV_EXISTS_AND_THM,
					match LEFT_EXISTS_AND_THM,
					match RIGHT_EXISTS_AND_THM]);
(*
 * fun EXISTS_AND_CONV tm =
 *    let val {Bvar, Body} = dest_exists tm
 *                           handle _ =>
 * 			      ERR("EXISTS_AND_CONV","expecting `?x. P /\\ Q`")
 *        val {conj1,conj2} = dest_conj Body
 *                            handle _ =>
 * 			       ERR("EXISTS_AND_CONV","expecting `?x. P /\\ Q`")
 *        val fP = free_in Bvar conj1 
 *        and fQ =  free_in Bvar conj2
 *    in
 *    if (fP andalso fQ) 
 *    then ERR("EXISTS_AND_CONV",
 *                        ("`"^(#Name(dest_var Bvar))^
 * 				  "` free in both conjuncts"))
 *    else let val (t1,t2) = CONJ_PAIR(ASSUME Body) 
 *             val econj1 = mk_exists{Bvar = Bvar, Body = conj1}
 *             val econj2 = mk_exists{Bvar = Bvar, Body = conj2}
 *             val eP = if fQ 
 *                      then t1
 *                      else EXISTS (econj1,Bvar) t1
 *             and eQ = if fP 
 *                      then t2 
 *                      else EXISTS (econj2,Bvar) t2
 *             val imp1 = DISCH tm (CHOOSE(Bvar,ASSUME tm) (CONJ eP eQ)) 
 *             val th = EXISTS (tm,Bvar) (CONJ(ASSUME conj1) (ASSUME conj2))
 *             val th1 = if (fP orelse (not fQ))
 *                       then CHOOSE(Bvar,ASSUME econj1)th 
 *                       else th
 *             val thm1 = if (fQ orelse (not fP))
 *                        then CHOOSE(Bvar,ASSUME econj2)th1
 *                        else th1
 *             val otm = rand(concl imp1) 
 *             val (t1,t2) = CONJ_PAIR(ASSUME otm) 
 *             val thm2 = PROVE_HYP t1 (PROVE_HYP t2 thm1) 
 *         in
 *         IMP_ANTISYM_RULE imp1 (DISCH otm thm2)
 *         end
 *    end
 *    handle e => WRAP_ERR("EXISTS_AND_CONV",e);
*)


(* ---------------------------------------------------------------------*)
(* AND_EXISTS_CONV : move existential quantifier out of conjunction.	*)
(*									*)
(*   |- (?x.P) /\ (?x.Q) = (?x. P /\ Q) 				*)
(* 									*)
(* provided x is free in neither P nor Q.				*)
(* ---------------------------------------------------------------------*)
val AND_EXISTS_CONV = wrap "AND_EXISTS_CONV" (match TRIV_AND_EXISTS_THM);

(*
 * fun AND_EXISTS_CONV tm = 
 *    let val {conj1,conj2} = dest_conj tm
 *        val {Bvar = x, Body = P} = dest_exists conj1
 *        val {Bvar = y, Body = Q} = dest_exists conj2
 *    in
 *    if (not(x=y)) 
 *    then ERR("AND_EXISTS_CONV","expecting (?x.P) /\\ (?x.Q)")
 *    else if (free_in x P orelse free_in x Q) 
 *         then ERR("AND_EXISTS_CONV",
 * 		    ("`"^(#Name(dest_var x))^"` free in conjunct(s)"))
 *         else SYM (EXISTS_AND_CONV
 *                     (mk_exists{Bvar = x,
 *                                Body = mk_conj{conj1 = P, conj2 = Q}}))
 *    end
 *    handle e => WRAP_ERR("AND_EXISTS_CONV",e)
*)

(* ---------------------------------------------------------------------*)
(* LEFT_AND_EXISTS_CONV: move existential quantifier out of conjunction	*)
(*									*)
(* A call to LEFT_AND_EXISTS_CONV "(?x.P) /\  Q"  returns:		*)
(*									*)
(*   |- (?x.P) /\ Q = (?x'. P[x'/x] /\ Q) 				*)
(* 									*)
(* Where x' is a primed variant of x not free in the input term		*)
(* ---------------------------------------------------------------------*)
val LEFT_AND_EXISTS_CONV = wrap "LEFT_AND_EXISTS_CONV" (match LEFT_AND_EXISTS_THM);
(*
 * fun LEFT_AND_EXISTS_CONV tm = 
 *    let val {conj1,conj2} = dest_conj tm 
 *        val {Bvar,Body} = dest_exists conj1 
 *        val x' = variant (free_vars tm) Bvar 
 *        val newp = subst[{redex = Bvar, residue = x'}] Body
 *        val new_conj = mk_conj {conj1 = newp, conj2 = conj2} 
 *        val otm = mk_exists{Bvar = x', Body = new_conj}
 *        val (EP,Qth) = CONJ_PAIR(ASSUME tm) 
 *        val thm1 = EXISTS(otm,x')(CONJ(ASSUME newp)(ASSUME conj2)) 
 *        val imp1 = DISCH tm (MP (DISCH conj2 (CHOOSE(x',EP)thm1)) Qth) 
 *        val (t1,t2) = CONJ_PAIR (ASSUME new_conj) 
 *        val thm2 = CHOOSE (x',ASSUME otm) (CONJ (EXISTS (conj1,x') t1) t2) 
 *    in
 *    IMP_ANTISYM_RULE imp1 (DISCH otm thm2)
 *    end
 *    handle _ => ERR("LEFT_AND_EXISTS_CONV", "");
 *)
 
(* ---------------------------------------------------------------------*)
(* RIGHT_AND_EXISTS_CONV: move existential quantifier out of conjunction*)
(*									*)
(* A call to RIGHT_AND_EXISTS_CONV "P /\ (?x.Q)"  returns:		*)
(*									*)
(*   |- P /\ (?x.Q) = (?x'. P /\ (Q[x'/x]) 				*)
(* 									*)
(* where x' is a primed variant of x not free in the input term		*)
(* ---------------------------------------------------------------------*)
val RIGHT_AND_EXISTS_CONV = wrap "RIGHT_AND_EXISTS_CONV" (match RIGHT_AND_EXISTS_THM);
(*
 * fun RIGHT_AND_EXISTS_CONV tm = 
 *    let val {conj1,conj2} = dest_conj tm 
 *        val {Bvar,Body} = dest_exists conj2
 *        val x' = variant (free_vars tm) Bvar 
 *        val newq = subst[{redex = Bvar, residue = x'}]Body 
 *        val new_conj = mk_conj{conj1 = conj1,conj2 = newq}
 *        val otm = mk_exists{Bvar = x',Body = new_conj}
 *        val (Pth,EQ) = CONJ_PAIR(ASSUME tm) 
 *        val thm1 = EXISTS(otm,x')(CONJ(ASSUME conj1)(ASSUME newq)) 
 *        val imp1 = DISCH tm (MP (DISCH conj1 (CHOOSE(x',EQ)thm1)) Pth) 
 *        val (t1,t2) = CONJ_PAIR (ASSUME new_conj) 
 *        val thm2 = CHOOSE (x',ASSUME otm) (CONJ t1 (EXISTS (conj2,x') t2)) 
 *    in
 *    IMP_ANTISYM_RULE imp1 (DISCH otm thm2)
 *    end
 *    handle _ => ERR("RIGHT_AND_EXISTS_CONV","");
 *)
 

(* ---------------------------------------------------------------------*)
(* FORALL_OR_CONV : move universal quantifier into disjunction.		*)
(*									*)
(* A call to FORALL_OR_CONV "!x. P \/ Q"  returns:			*)
(*									*)
(*   |- (!x. P \/ Q) = (!x.P) \/ Q	 [if x not free in Q]		*)
(*   |- (!x. P \/ Q) = P \/ (!x.Q)	 [if x not free in P]		*)
(*   |- (!x. P \/ Q) = (!x.P) \/ (!x.Q)	 [if x free in neither P nor Q]	*)
(* ---------------------------------------------------------------------*)

val FORALL_OR_CONV = 
    wrap "FORALL_OR_CONV" (FIRST_CONV [match TRIV_FORALL_OR_THM,
					match LEFT_FORALL_OR_THM,
					match RIGHT_FORALL_OR_THM]);
(*
 * fun FORALL_OR_CONV tm =
 *    let val {Bvar,Body} = dest_forall tm
 *        val {disj1,disj2} = dest_disj Body
 *        val fdisj1 = free_in Bvar disj1
 *        and fdisj2 =  free_in Bvar disj2 
 *    in
 *    if (fdisj1 andalso fdisj2) 
 *    then ERR("FORALL_OR_CONV",
 *                        ("`"^(#Name(dest_var Bvar))^
 * 				       "` free in both disjuncts"))
 *    else let val disj1_thm = ASSUME disj1
 *             val disj2_thm = ASSUME disj2
 *             val thm1 = SPEC Bvar (ASSUME tm) 
 *             val imp1 = 
 *                if fdisj1 
 *                then let val thm2 = CONTR disj1 (MP (ASSUME (mk_neg disj2)) 
 *                                                    disj2_thm)
 *                         val thm3 = DISJ1(GEN Bvar
 *                                              (DISJ_CASES thm1 disj1_thm thm2))
 *                                         disj2 
 *                         val thm4 = DISJ2 (mk_forall{Bvar = Bvar, Body = disj1})
 *                                          (ASSUME disj2) 
 *                     in
 *                     DISCH tm (DISJ_CASES(SPEC disj2 EXCLUDED_MIDDLE) thm4 thm3)
 *                     end
 *                else if fdisj2 
 *                     then let val thm2 = CONTR disj2(MP (ASSUME (mk_neg disj1)) 
 *                                                     (ASSUME disj1))
 *                              val thm3 = DISJ2 disj1(GEN Bvar(DISJ_CASES thm1 
 *                                                                         thm2
 *                                                                     disj2_thm))
 *                              val thm4 = DISJ1(ASSUME disj1) 
 *                                              (mk_forall{Bvar=Bvar, Body=disj2})
 *                          in
 *                          DISCH tm (DISJ_CASES (SPEC disj1 EXCLUDED_MIDDLE) 
 *                                               thm4 thm3)
 *                          end
 *                     else let val (t1,t2) = (GEN Bvar(ASSUME disj1), 
 *                                             GEN Bvar(ASSUME disj2)) 
 *                          in
 *                          DISCH tm (DISJ_CASES_UNION thm1 t1 t2)
 *                          end
 *             val otm = rand(concl imp1) 
 *             val {disj1,disj2} = dest_disj otm
 *             val thm5 = (if (fdisj1 orelse (not fdisj2)) then SPEC Bvar else I) 
 *                        (ASSUME disj1) 
 *             val thm6 = (if (fdisj2 orelse (not fdisj1)) then SPEC Bvar else I)
 *                        (ASSUME disj2)
 *             val imp2 = GEN Bvar (DISJ_CASES_UNION (ASSUME otm) thm5 thm6) 
 *         in
 *         IMP_ANTISYM_RULE imp1 (DISCH otm imp2)
 *         end
 *    end
 *    handle e => WRAP_ERR("FORALL_OR_CONV",e)
*)

(* ---------------------------------------------------------------------*)
(* OR_FORALL_CONV : move existential quantifier out of conjunction.	*)
(*									*)
(*   |- (!x.P) \/ (!x.Q) = (!x. P \/ Q) 				*)
(* 									*)
(* provided x is free in neither P nor Q.				*)
(* ---------------------------------------------------------------------*)

val OR_FORALL_CONV = wrap "OR_FORALL_CONV" (match TRIV_OR_FORALL_THM);
(*
 * fun OR_FORALL_CONV tm = 
 *    let val {disj1,disj2} = dest_disj tm
 *        val {Bvar = x, Body = P} = dest_forall disj1
 *        val {Bvar = y, Body = Q} = dest_forall disj2
 *    in
 *    if (not(x=y)) 
 *    then ERR("OR_FORALL_CONV","expecting (!x.P) \\/ (!x.Q)")
 *    else if (free_in x P orelse free_in x Q) 
 *         then ERR("OR_FORALL_CONV",
 *                             ("`"^(#Name(dest_var x))^"` free in disjuncts(s)"))
 *         else SYM (FORALL_OR_CONV
 *                    (mk_forall{Bvar = x, Body = mk_disj{disj1 = P, disj2 = Q}}))
 *    end
 * handle e => WRAP_ERR("OR_FORALL_CONV",e);
 *)
    

(* ---------------------------------------------------------------------*)
(* LEFT_OR_FORALL_CONV : move universal quantifier out of conjunction.	*)
(*									*)
(* A call to LEFT_OR_FORALL_CONV "(!x.P) \/  Q"  returns:		*)
(*									*)
(*   |- (!x.P) \/ Q = (!x'. P[x'/x] \/ Q) 				*)
(* 									*)
(* Where x' is a primed variant of x not free in the input term		*)
(* ---------------------------------------------------------------------*)
val LEFT_OR_FORALL_CONV = wrap "LEFT_OR_FORALL_CONV" (match LEFT_OR_FORALL_THM);

(*
 * fun LEFT_OR_FORALL_CONV tm = 
 *    let val {disj1,disj2} = dest_disj tm
 *        val {Bvar,Body} = dest_forall disj1
 *        val x' = variant (free_vars tm) Bvar
 *        val newp = subst[{redex = Bvar, residue = x'}] Body
 *        val aQ = ASSUME disj2
 *        val Pth = DISJ1 (SPEC x' (ASSUME disj1)) disj2
 *        val Qth = DISJ2 newp aQ 
 *        val imp1 = DISCH tm (GEN x' (DISJ_CASES (ASSUME tm) Pth Qth)) 
 *        val otm = rand(concl imp1) 
 *        val thm1 = SPEC x' (ASSUME otm) 
 *        val thm2 = CONTR newp (MP(ASSUME(mk_neg disj2)) aQ) 
 *        val thm3 = DISJ1 (GEN x' (DISJ_CASES thm1 (ASSUME newp) thm2)) disj2 
 *        val thm4 = DISJ2 disj1 aQ 
 *        val imp2 = DISCH otm(DISJ_CASES(SPEC disj2 EXCLUDED_MIDDLE)thm4 thm3) 
 *    in
 *    IMP_ANTISYM_RULE imp1 imp2
 *    end
 *    handle _ => ERR("LEFT_OR_FORALL_CONV", "");
*)
(* ---------------------------------------------------------------------*)
(* RIGHT_OR_FORALL_CONV : move universal quantifier out of conjunction.	*)
(*									*)
(* A call to RIGHT_OR_FORALL_CONV "P \/ (!x.Q)"  returns:		*)
(*									*)
(*   |- P \/ (!x.Q) = (!x'. P \/ (Q[x'/x]) 				*)
(* 									*)
(* where x' is a primed variant of x not free in the input term		*)
(* ---------------------------------------------------------------------*)
val RIGHT_OR_FORALL_CONV = wrap "RIGHT_OR_FORALL_CONV" (match RIGHT_OR_FORALL_THM);

(*
 * fun RIGHT_OR_FORALL_CONV tm = 
 *    let val {disj1,disj2} = dest_disj tm
 *        val {Bvar,Body} = dest_forall disj2
 *        val x' = variant (free_vars tm) Bvar
 *        val newq = subst[{redex = Bvar, residue = x'}] Body
 *        val Qth = DISJ2 disj1 (SPEC x' (ASSUME disj2))
 *        val Pthm = ASSUME disj1
 *        val Pth = DISJ1 Pthm newq 
 *        val imp1 = DISCH tm (GEN x' (DISJ_CASES (ASSUME tm) Pth Qth)) 
 *        val otm = rand(concl imp1) 
 *        val thm1 = SPEC x' (ASSUME otm) 
 *        val thm2 = CONTR newq (MP(ASSUME(mk_neg disj1)) Pthm) 
 *        val thm3 = DISJ2 disj1 (GEN x' (DISJ_CASES thm1 thm2 (ASSUME newq))) 
 *        val thm4 = DISJ1 Pthm disj2 
 *        val imp2 = DISCH otm(DISJ_CASES(SPEC disj1 EXCLUDED_MIDDLE)thm4 thm3) 
 *    in
 *    IMP_ANTISYM_RULE imp1 imp2
 *    end
 *    handle _ => ERR("RIGHT_OR_FORALL_CONV", "");
*)

(* ---------------------------------------------------------------------*)
(* FORALL_IMP_CONV, implements the following axiom schemes.		*)
(*									*)
(*	|- (!x. P==>Q[x]) = (P ==> (!x.Q[x]))	  [x not free in P]	*)
(*									*)
(*	|- (!x. P[x]==>Q) = ((?x.P[x]) ==> Q)	  [x not free in Q]	*)
(*									*)
(*	|- (!x. P==>Q) = ((?x.P) ==> (!x.Q))	  [x not free in P==>Q]	*)
(* ---------------------------------------------------------------------*)

val FORALL_IMP_CONV = 
    wrap "FORALL_IMP_CONV" (FIRST_CONV [match TRIV_FORALL_IMP_THM,
					match LEFT_FORALL_IMP_THM,
					match RIGHT_FORALL_IMP_THM]);

(*
 * fun FORALL_IMP_CONV tm = 
 *    let val {Bvar,Body} = dest_forall tm
 *        val {ant,conseq} = dest_imp Body
 *        val fant = free_in Bvar ant 
 *        and fconseq =  free_in Bvar conseq
 *        val ant_thm = ASSUME ant
 *        val tm_thm = ASSUME tm
 *    in
 *    if (fant andalso fconseq) 
 *    then ERR("FORALL_IMP_CONV",
 * 		       ("`"^(#Name(dest_var Bvar))^
 * 				  "` free on both sides of `==>`"))
 *    else if fant 
 *         then let val asm = mk_exists{Bvar = Bvar, Body = ant} 
 *                  val th1 = CHOOSE(Bvar,ASSUME asm)
 *                                  (UNDISCH(SPEC Bvar tm_thm))
 *                  val imp1 = DISCH tm (DISCH asm th1) 
 *                  val cncl = rand(concl imp1) 
 *                  val th2 = MP (ASSUME cncl) (EXISTS (asm,Bvar) ant_thm) 
 *                  val imp2 = DISCH cncl (GEN Bvar (DISCH ant th2)) 
 *              in
 *              IMP_ANTISYM_RULE imp1 imp2 
 *              end
 *        else if fconseq 
 *             then let val imp1 = DISCH ant(GEN Bvar(UNDISCH(SPEC Bvar tm_thm))) 
 *                      val cncl = concl imp1 
 *                      val imp2 = GEN Bvar(DISCH ant
 *                                           (SPEC Bvar(UNDISCH (ASSUME cncl))))
 *                  in
 *                  IMP_ANTISYM_RULE (DISCH tm imp1) (DISCH cncl imp2)
 *                  end
 *             else let val asm = mk_exists{Bvar = Bvar, Body = ant} 
 *                      val th1 = GEN Bvar (CHOOSE(Bvar,ASSUME asm)
 *                                             (UNDISCH(SPEC Bvar tm_thm))) 
 *                      val imp1 = DISCH tm (DISCH asm th1) 
 *                      val cncl = rand(concl imp1) 
 *                      val th2 = SPEC Bvar (MP (ASSUME cncl) 
 *                                           (EXISTS (asm,Bvar) ant_thm)) 
 *                      val imp2 = DISCH cncl (GEN Bvar (DISCH ant th2)) 
 *                  in
 *                  IMP_ANTISYM_RULE imp1 imp2
 *                  end
 *    end
 *    handle e => WRAP_ERR("FORALL_IMP_CONV",e)
 *)

(* ---------------------------------------------------------------------*)
(* LEFT_IMP_EXISTS_CONV, implements the following theorem-scheme:	*)
(*									*)
(*    |- (?x. t1[x]) ==> t2  =  !x'. t1[x'] ==> t2			*)
(*									*)
(* where x' is a variant of x chosen not to be free in (?x.t1[x])==>t2  *)
(*									*)
(* Author: Tom Melham                                                   *)
(* Revised: [TFM 90.07.01]						*)
(*----------------------------------------------------------------------*)
val LEFT_IMP_EXISTS_CONV = wrap "LEFT_IMP_EXISTS_CONV" (match LEFT_IMP_EXISTS_THM);
(*
 * 
 * fun LEFT_IMP_EXISTS_CONV tm = 
 *    let val {ant, ...} = dest_imp tm 
 *        val {Bvar,Body} = dest_exists ant 
 *        val x' = variant (free_vars tm) Bvar 
 *        val t' = subst [Bvar |-> x'] Body 
 *        val th1 = GEN x' (DISCH t'(MP(ASSUME tm)(EXISTS(ant,x')(ASSUME t')))) 
 *        val rtm = concl th1 
 *        val th2 = CHOOSE (x',ASSUME ant) (UNDISCH(SPEC x'(ASSUME rtm))) 
 *    in
 *    IMP_ANTISYM_RULE (DISCH tm th1) (DISCH rtm (DISCH ant th2))
 *    end
 *    handle _ => ERR("LEFT_IMP_EXISTS_CONV", "");
*)

(* ---------------------------------------------------------------------*)
(* RIGHT_IMP_FORALL_CONV, implements the following theorem-scheme:	*)
(*									*)
(*    |- (t1 ==> !x. t2)  =  !x'. t1 ==> t2[x'/x]			*)
(*									*)
(* where x' is a variant of x chosen not to be free in the input term.	*)
(*----------------------------------------------------------------------*)
val RIGHT_IMP_FORALL_CONV = wrap "RIGHT_IMP_FORALL_CONV" (match RIGHT_IMP_FORALL_THM);
(*
 * fun RIGHT_IMP_FORALL_CONV tm = 
 *    let val {ant,conseq} = dest_imp tm
 *        val {Bvar,Body} = dest_forall conseq
 *        val x' = variant (free_vars tm) Bvar 
 *        val t' = subst [Bvar |-> x'] Body 
 *        val imp1 = DISCH tm (GEN x' (DISCH ant(SPEC x'(UNDISCH(ASSUME tm))))) 
 *        val ctm = rand(concl imp1) 
 *        val alph = GEN_ALPHA_CONV Bvar (mk_forall{Bvar = x', Body = t'}) 
 *        val thm1 = EQ_MP alph (GEN x'(UNDISCH (SPEC x' (ASSUME ctm)))) 
 *        val imp2 = DISCH ctm (DISCH ant thm1) 
 *    in
 *    IMP_ANTISYM_RULE imp1 imp2
 *    end
 *    handle _ => ERR("RIGHT_IMP_FORALL_CONV","");
 *)


(* ---------------------------------------------------------------------*)
(* EXISTS_IMP_CONV, implements the following axiom schemes.		*)
(*									*)
(*	|- (?x. P==>Q[x]) = (P ==> (?x.Q[x]))	  [x not free in P]	*)
(*									*)
(*	|- (?x. P[x]==>Q) = ((!x.P[x]) ==> Q)	  [x not free in Q]	*)
(*									*)
(*	|- (?x. P==>Q) = ((!x.P) ==> (?x.Q))	  [x not free in P==>Q]	*)
(* ---------------------------------------------------------------------*)

val EXISTS_IMP_CONV = 
    wrap "EXISTS_IMP_CONV" (FIRST_CONV [match TRIV_EXISTS_IMP_THM,
					match LEFT_EXISTS_IMP_THM,
					match RIGHT_EXISTS_IMP_THM]);
(*
 * fun EXISTS_IMP_CONV tm = 
 *    let val {Bvar,Body} = dest_exists tm
 *        val {ant = P,conseq = Q} = dest_imp Body
 *        val fP = free_in Bvar P
 *        and fQ =  free_in Bvar Q 
 *    in
 *    if (fP andalso fQ)
 *    then ERR("EXISTS_IMP_CONV",
 * 		       ("`"^(#Name(dest_var Bvar))^
 * 				  "` free on both sides of `==>`"))
 *    else if fP 
 *         then let val allp = mk_forall{Bvar = Bvar, Body = P} 
 *                  val th1 = SPEC Bvar (ASSUME allp) 
 *                  val thm1 = MP (ASSUME Body) th1 
 *                  val imp1 = DISCH tm (CHOOSE(Bvar,ASSUME tm)(DISCH allp thm1)) 
 *                  val otm = rand(concl imp1) 
 *                  val thm2 = EXISTS(tm,Bvar)(DISCH P (UNDISCH(ASSUME otm))) 
 *                  val notP = mk_neg P
 *                  val notP_thm = ASSUME notP
 *                  val nex =  mk_exists{Bvar = Bvar, Body = notP}
 *                  val asm1 = EXISTS (nex, Bvar) notP_thm
 *                  val th2 = CCONTR P (MP (ASSUME (mk_neg nex)) asm1) 
 *                  val th3 = CCONTR nex (MP (ASSUME (mk_neg allp))
 *                                           (GEN Bvar th2)) 
 *                  val thm4 = DISCH P (CONTR Q (UNDISCH notP_thm))
 *                  val thm5 = CHOOSE(Bvar,th3)(EXISTS(tm,Bvar)thm4) 
 *  *                  val thm6 = DISJ_CASES (SPEC allp EXCLUDED_MIDDLE) thm2 thm5 
 *              in
 *              IMP_ANTISYM_RULE imp1 (DISCH otm thm6) 
 *              end
 *         else if fQ 
 *              then let val thm1 = EXISTS (mk_exists{Bvar = Bvar, Body = Q},Bvar)
 *                                         (UNDISCH(ASSUME Body)) 
 *                       val imp1 = DISCH tm (CHOOSE(Bvar,ASSUME tm)
 *                                                  (DISCH P thm1)) 
 *                       val thm2 = UNDISCH (ASSUME (rand(concl imp1))) 
 *                       val thm3 = CHOOSE (Bvar,thm2) (EXISTS (tm,Bvar) 
 *                                                          (DISCH P (ASSUME Q))) 
 *                       val thm4 = EXISTS(tm,Bvar)
 *                                        (DISCH P
 *                                          (CONTR Q(UNDISCH(ASSUME(mk_neg P)))))
 *                       val thm5 = DISJ_CASES (SPEC P EXCLUDED_MIDDLE) thm3 thm4 
 *                   in
 *                   IMP_ANTISYM_RULE imp1 (DISCH(rand(concl imp1)) thm5) 
 *                   end
 *             else let val eQ = mk_exists{Bvar = Bvar, Body = Q}
 *                      and aP = mk_forall{Bvar = Bvar, Body = P}
 *                      val thm1 = EXISTS(eQ,Bvar)(UNDISCH(ASSUME Body)) 
 *                      val thm2 = DISCH aP (PROVE_HYP (SPEC Bvar (ASSUME aP))
 *                                                     thm1)
 *                      val imp1 = DISCH tm (CHOOSE(Bvar,ASSUME tm) thm2) 
 *                      val thm2 = CHOOSE(Bvar,UNDISCH (ASSUME(rand(concl imp1))))
 *                                       (ASSUME Q) 
 *                      val thm3 = DISCH P (PROVE_HYP (GEN Bvar (ASSUME P)) thm2) 
 *                      val imp2 = DISCH (rand(concl imp1)) (EXISTS(tm,Bvar) thm3)
 *                  in
 *                  IMP_ANTISYM_RULE imp1 imp2
 *                  end
 *    end
 *    handle e => WRAP_ERR("EXISTS_IMP_CONV",e)
*)

(* ---------------------------------------------------------------------*)
(* LEFT_IMP_FORALL_CONV, implements the following theorem-scheme:	*)
(*									*)
(*    |- (!x. t1[x]) ==> t2  =  ?x'. t1[x'] ==> t2			*)
(*									*)
(* where x' is a variant of x chosen not to be free in the input term	*)
(*----------------------------------------------------------------------*)
val LEFT_IMP_FORALL_CONV = wrap "LEFT_IMP_FORALL_CONV" (match LEFT_IMP_FORALL_THM);
(*
 * fun LEFT_IMP_FORALL_CONV tm = 
 *    let val {ant,conseq} = dest_imp tm 
 *        val {Bvar,Body} = dest_forall ant 
 *        val x' = variant (free_vars tm) Bvar 
 *        val t1' = subst [Bvar |-> x'] Body 
 *        val not_t1'_thm = ASSUME (mk_neg t1')
 *        val th1 = SPEC x' (ASSUME ant) 
 *        val new_imp = mk_imp{ant = t1', conseq = conseq}
 *        val thm1 = MP (ASSUME new_imp) th1 
 *        val otm = mk_exists{Bvar = x', Body = new_imp}
 *        val imp1 = DISCH otm (CHOOSE(x',ASSUME otm)(DISCH ant thm1)) 
 *        val thm2 = EXISTS(otm,x') (DISCH t1' (UNDISCH(ASSUME tm))) 
 *        val nex =  mk_exists{Bvar = x', Body = mk_neg t1'}
 *        val asm1 = EXISTS (nex, x') not_t1'_thm 
 *        val th2 = CCONTR t1' (MP (ASSUME (mk_neg nex)) asm1) 
 *        val th3 = CCONTR nex (MP(ASSUME(mk_neg ant)) (GEN x' th2)) 
 *        val thm4 = DISCH t1' (CONTR conseq (UNDISCH not_t1'_thm)) 
 *        val thm5 = CHOOSE(x',th3)
 *                         (EXISTS(mk_exists{Bvar = x',Body = concl thm4},x')thm4)
 *        val thm6 = DISJ_CASES (SPEC ant EXCLUDED_MIDDLE) thm2 thm5 
 *    in
 *    IMP_ANTISYM_RULE (DISCH tm thm6) imp1
 *    end
 *    handle _ => ERR("LEFT_IMP_FORALL_CONV", "");
*)

(* ---------------------------------------------------------------------*)
(* RIGHT_IMP_EXISTS_CONV, implements the following theorem-scheme:	*)
(*									*)
(*    |- (t1 ==> ?x. t2)  =  ?x'. t1 ==> t2[x'/x]			*)
(*									*)
(* where x' is a variant of x chosen not to be free in the input term.	*)
(*----------------------------------------------------------------------*)
val RIGHT_IMP_EXISTS_CONV = wrap "RIGHT_IMP_EXISTS_CONV" (match RIGHT_IMP_EXISTS_THM);

(*fun RIGHT_IMP_EXISTS_CONV tm = 
 *    let val {ant,conseq} = dest_imp tm
 *        val {Bvar,Body} = dest_exists conseq
 *        val x' = variant (free_vars tm) Bvar 
 *        val t2' = subst [Bvar |-> x'] Body
 *        val new_imp = mk_imp{ant = ant, conseq = t2'}
 *        val otm = mk_exists{Bvar = x', Body = new_imp}
 *        val thm1 = EXISTS(conseq,x')(UNDISCH(ASSUME new_imp)) 
 *        val imp1 = DISCH otm (CHOOSE(x',ASSUME otm) (DISCH ant thm1)) 
 *        val thm2 = UNDISCH (ASSUME tm) 
 *        val thm3 = CHOOSE (x',thm2) (EXISTS (otm,x') (DISCH ant (ASSUME t2'))) 
 *        val thm4 = DISCH ant (CONTR t2'(UNDISCH(ASSUME(mk_neg ant)))) 
 *        val thm5 = EXISTS(otm,x') thm4 
 *        val thm6 = DISJ_CASES (SPEC ant EXCLUDED_MIDDLE) thm3 thm5 
 *    in
 *    IMP_ANTISYM_RULE (DISCH tm thm6) imp1
 *    end
 *    handle e => WRAP_ERR("RIGHT_IMP_EXISTS_CONV",e);
 *)

(* ---------------------------------------------------------------------*)
(* X_SKOLEM_CONV : introduce a skolem function.				*)
(*									*)
(*   |- (!x1...xn. ?y. tm[x1,...,xn,y])					*)
(*        =								*)
(*      (?f. !x1...xn. tm[x1,..,xn,f x1 ... xn]				*)
(*									*)
(* The first argument is the function f.				*)
(* ---------------------------------------------------------------------*)


fun X_SKOLEM_CONV v = 
   if (not(is_var v)) 
   then ERR("X_SKOLEM_CONV","first argument not a variable")
   else 
fn tm =>
  let val (xs,ex) = strip_forall tm
      val (ab as {Bvar,Body}) = dest_exists ex handle _ =>  
                                ERR("X_SKOLEM_CONV",
                                "expecting `!x1...xn. ?y.tm`")
      val fx = Term.list_mk_comb(v,xs) handle _ => 
               ERR("X_SKOLEM_CONV","function variable has the wrong type")
  in 
  if (free_in v tm) 
  then ERR("X_SKOLEM_CONV",
             ("`"^(#Name(dest_var v))^"` free in the input term"))
  else let val pat_bod = list_mk_forall(xs,subst[Bvar |-> fx]Body)
           val pat = mk_exists{Bvar = v, Body = pat_bod}
           val fnn = list_mk_abs(xs,mk_select ab) 
           val bth = SYM(LIST_BETA_CONV (Term.list_mk_comb(fnn,xs))) 
           val thm1 = SUBST [{var = Bvar, thm = bth}] Body 
                            (SELECT_RULE (SPECL xs (ASSUME tm)))
           val imp1 = DISCH tm (EXISTS (pat,fnn) (GENL xs thm1)) 
           val thm2 = SPECL xs (ASSUME pat_bod)
           val thm3 = GENL xs (EXISTS (ex,fx) thm2) 
           val imp2 = DISCH pat (CHOOSE (v,ASSUME pat) thm3) 
       in
       IMP_ANTISYM_RULE imp1 imp2
       end
  end
handle e => WRAP_ERR("X_SKOLEM_CONV",e);
    

(* ---------------------------------------------------------------------*)
(* SKOLEM_CONV : introduce a skolem function.				*)
(*									*)
(*   |- (!x1...xn. ?y. tm[x1,...,xn,y])					*)
(*        =								*)
(*      (?y'. !x1...xn. tm[x1,..,xn,y' x1 ... xn]			*)
(*									*)
(* Where y' is a primed variant of y not free in the input term.	*)
(* ---------------------------------------------------------------------*)

local
fun mkfty tm ty = type_of tm --> ty
in
fun SKOLEM_CONV tm =
   let val (xs,ex) = strip_forall tm
       val {Bvar, ...} = dest_exists ex
       val {Name,Ty} = dest_var Bvar
       val fv = mk_var{Name = Name, Ty = itlist mkfty xs Ty}
   in
   X_SKOLEM_CONV (variant (free_vars tm) fv) tm
   end
   handle e => WRAP_ERR("SKOLEM_CONV", e)
end;



(* ---------------------------------------------------------------------
 * SELECT_CONV: a conversion for introducing "?" when P [@@x.P[x]].	
 *									
 * SELECT_CONV "P [@@x.P [x]]" ---> |- P [@@x.P [x]] = ?x. P[x]		
 * 
 * Added: TFM 88.03.31							
 * ---------------------------------------------------------------------*)
(* fun SELECT_CONV tm =                                                 
**   let val epsl = find_terms is_select tm                             
**       fun findfn t = (tm = subst [{redex = #Bvar (dest_select t),
**                                    residue = t}]
**                                  (#Body (dest_select t)))
**       val sel = first findfn epsl
**       val ex  = mk_exists(dest_select sel)
**       val imp1 = DISCH_ALL (SELECT_RULE (ASSUME ex)) 
**       and imp2 = DISCH_ALL (EXISTS (ex,sel) (ASSUME tm)) 
**   in
**   IMP_ANTISYM_RULE imp2 imp1
**   end
**   handle _ => ERR("SELECT_CONV", "");
*)


 local
 val f = mk_var{Name="f",Ty= ==`:'a->bool`==} 
 val th1 = AP_THM Boolean.EXISTS_DEF f 
 val th2 = CONV_RULE (RAND_CONV BETA_CONV) th1 
 val tyv = Type.mk_vartype "'a" 
 fun EXISTS_CONV{Bvar,Body} = 
    let val ty = type_of Bvar
        val ins = INST_TYPE [tyv |-> ty] th2
        val th = INST[inst[tyv |-> ty] f |-> mk_abs{Bvar=Bvar,Body=Body}] ins
    in CONV_RULE (RAND_CONV BETA_CONV) th
    end
 fun find_first p tm =
    if (p tm)
    then tm 
    else if (is_abs tm)
         then find_first p (body tm) 
         else if is_comb tm 
              then let val {Rator,Rand} = dest_comb tm 
                   in (find_first p Rator) handle _ => (find_first p Rand)
                   end
              else ERR("SELECT_CONV.find_first","")
 in
 fun SELECT_CONV tm =
    let fun right t = 
           let val {Bvar,Body} = dest_select t
           in Term.aconv (subst[Bvar |-> t] Body) tm
           end handle _ => false
        val epi = find_first right tm 
    in
    SYM (EXISTS_CONV (dest_select epi))
    end
    handle e => WRAP_ERR("SELECT_CONV",e)
 end;


val SELECT_REFL = prove
 ((--`!x:'a. (@@y. y = x) = x`--),
  GEN_TAC THEN CONV_TAC SELECT_CONV THEN
  EXISTS_TAC (--`x:'a`--) THEN REFL_TAC);;

val SELECT_REFL_2 = 
    CONV_RULE ((RAND_CONV o ABS_CONV o RATOR_CONV o 
		RAND_CONV o RAND_CONV o ABS_CONV) SYM_CONV) SELECT_REFL;
    

(* ---------------------------------------------------------------------*)
(* SWAP_EXISTS_CONV: swap the order of existentially quantified vars.	*)
(*									*)
(* SWAP_EXISTS_CONV "?x y.t[x,y]" ---> |- ?x y.t[x,y] = ?y x.t[x,y]	*)
(*									*)
(* AUTHOR: Paul Loewenstein 3 May 1988                             	*)
(* ---------------------------------------------------------------------*)
 
fun SWAP_EXISTS_CONV xyt =
   let val {Bvar = x,Body = yt} = dest_exists xyt
       val {Bvar = y, Body = t} = dest_exists yt
       val xt = mk_exists {Bvar = x, Body = t}
       val yxt = mk_exists{Bvar = y, Body = xt}
       val t_thm = ASSUME t
   in
   IMP_ANTISYM_RULE
         (DISCH xyt (CHOOSE (x,ASSUME xyt) (CHOOSE (y, (ASSUME yt))
          (EXISTS (yxt,y) (EXISTS (xt,x) t_thm)))))
         (DISCH yxt (CHOOSE (y,ASSUME yxt) (CHOOSE (x, (ASSUME xt))
 	 (EXISTS (xyt,x) (EXISTS (yt,y) t_thm)))))
   end
   handle e => WRAP_ERR("SWAP_EXISTS_CONV", e);

(* ---------------------------------------------------------------------*)
(* EXISTS_UNIQUE_CONV: expands with the definition of unique existence.	*)
(*									*)
(* 									*)
(* EXISTS_UNIQUE_CONV "?!x.P[x]" yields the theorem: 			*)
(* 									*)
(*     |- ?!x.P[x] = ?x.P[x] /\ !x y. P[x] /\ P[y] ==> (x=y)		*)
(* 									*)
(* ADDED: TFM 90.05.06							*)
(*									*)
(* REVISED: now uses a variant of x for y in 2nd conjunct [TFM 90.06.11]*)
(* ---------------------------------------------------------------------*)


(*
val EXISTS_UNIQUE_CONV = wrap "EXISTS_UNIQUE_CONV" (match EXISTS_UNIQUE_THM);
*)

 local
 val v = genvar (==`:bool`==)
 val alpha = ==`:'a`==
 fun alpha_subst ty = [alpha |-> ty]
 val check = assert (fn c => (#Name(dest_const c) = "?!"))
 fun MK_BIN f (e1,e2) = MK_COMB((AP_TERM f e1),e2) 
 val rule = CONV_RULE o RAND_CONV o GEN_ALPHA_CONV
 fun MK_ALL x y tm = rule y (FORALL_EQ x tm) 
 fun handle_ant{conj1, conj2} = (BETA_CONV conj1, BETA_CONV conj2)
 fun conv (nx,ny) t = 
    let val ([ox,oy],imp) = strip_forall t
        val {ant,conseq} = dest_imp imp
        val ant' = MK_BIN conjunction (handle_ant (dest_conj ant))
    in
    MK_ALL ox nx (MK_ALL oy ny (MK_BIN implies (ant',REFL conseq))) 
    end
 in
fun EXISTS_UNIQUE_CONV tm =
    let val {Rator,Rand} = dest_comb tm
        val _ = check Rator
        val (ab as {Bvar,Body}) = dest_abs Rand
        val def = INST_TYPE (alpha_subst (type_of Bvar))
                            Boolean.EXISTS_UNIQUE_DEF
        val exp = RIGHT_BETA(AP_THM def Rand) 
        and y = variant (all_vars Body) Bvar
    in
    SUBST [{var = v, thm = conv (Bvar,y) (rand(rand(concl exp)))}] 
          (mk_eq{lhs = tm,rhs = mk_conj{conj1 = mk_exists ab, 
                                        conj2 = v}})
          exp
    end
    handle _ => ERR("EXISTS_UNIQUE_CONV", "")
 end;



(* ===================================================================== *)
(* A rule defined using conversions.                                     *)
(* ===================================================================== *)


(* ---------------------------------------------------------------------*)
(* EXISTENCE: derives existence from unique existence:		        *)
(* 									*)
(*    |- ?!x. P[x]							*)
(* --------------------							*)
(*    |- ?x. P[x]							*)
(* 									*)
(* ---------------------------------------------------------------------*)


local
val EXISTS_UNIQUE_DEF = Boolean.EXISTS_UNIQUE_DEF
val P = --`P:'a -> bool`--
val th1 = SPEC P (CONV_RULE (X_FUN_EQ_CONV P) EXISTS_UNIQUE_DEF)
val th2 = CONJUNCT1(UNDISCH(fst(EQ_IMP_RULE(RIGHT_BETA th1))))
val imp = GEN P (DISCH (--`$?! ^P`--) th2)
val check = assert (fn c => (#Name(dest_const c) = "?!"))
val alpha = ==`:'a`==
in
fun EXISTENCE th =
   let val {Rator,Rand} = dest_comb(concl th)
       val _ = check Rator
       val {Bvar,...} = dest_abs Rand
   in
   MP (SPEC Rand (INST_TYPE [alpha |-> type_of Bvar] imp)) th
   end
   handle _ => ERR("EXISTENCE", "")
end;


(* ---------------------------------------------------------------------*)
(*  UNIQUENESS					                        *)
(*									*)
(* This function derives uniqueness from unique existence:		*)
(* 									*)
(*        |- ?!x. P[x]							*)
(* --------------------------------------- 				*)
(*  |- !v1 v2. P[v1] /\ P[v2] ==> (v1=v2)				*)
(* 									*)
(* The variables v1 and v2 are genvars.					*)
(* ---------------------------------------------------------------------*)


local
infix ~
infix ==>
fun (x ~ y) = mk_eq{lhs = x, rhs = y};
fun (x ==> y) = mk_imp{ant = x, conseq = y}
val AP_AND = AP_TERM conjunction;
val P = --`P:'a->bool`-- 
and v1 = genvar(==`:'a`==)
and v2 = genvar(==`:'a`==)
val th1 = SPEC P (CONV_RULE (X_FUN_EQ_CONV P) Boolean.EXISTS_UNIQUE_DEF) 
val th2 = CONJUNCT2(UNDISCH(fst(EQ_IMP_RULE(RIGHT_BETA th1)))) 
val imp = GEN P (DISCH (--`$?! ^P`--) (SPECL [v1, v2] th2)) 
fun AND (e1,e2) = MK_COMB(AP_AND e1, e2)
fun beta_conj{conj1,conj2} = (BETA_CONV conj1, BETA_CONV conj2)
fun conv tm = AND (beta_conj (dest_conj tm)) 
val check = assert (fn c => (#Name(dest_const c) = "?!")) 
and v = genvar bool_ty
val alpha = ==`:'a`==
in
fun UNIQUENESS th =
  let val {Rator,Rand} = dest_comb(concl th)
      val _ = check Rator
      val s = [alpha |-> type_of (bvar Rand)]
      val uniq = MP (SPEC Rand (INST_TYPE s imp)) th 
      val red = conv (#ant(dest_imp(concl uniq))) 
      val (V1,V2) = let val i = Term.inst s
                    in (i v1,i v2) 
                    end
  in 
  GEN V1 (GEN V2 (SUBST[{var=v,thm=red}](v ==> (V1 ~ V2)) uniq))
  end 
  handle e => WRAP_ERR("UNIQUENESS",e)
end;




(* ---------------------------------------------------------------------*)
(* bool_EQ_CONV: conversion for boolean equality.			*)
(*									*)
(* bool_EQ_CONV "b1 = b2" returns:					*)
(*									*)
(*    |- (b1 = b2) = T	   if b1 and b2 are identical boolean terms	*)
(*    |- (b1 = b2)  = b2	   if b1 = "T"				*)
(*    |- (b1 = b2)  = b1	   if b2 = "T"				*)
(* 									*)
(* Added TFM 88.03.31							*)
(* Revised TFM 90.07.24							*)
(* ---------------------------------------------------------------------*)
local
val (Tb::bT::_) = map (GEN (--`b:bool`--))
                      (CONJUNCTS(SPEC (--`b:bool`--) EQ_CLAUSES))
in
fun bool_EQ_CONV tm = 
   let val {lhs,rhs} = (dest_eq tm)
       val _ = if (type_of rhs = bool_ty) 
               then () 
               else ERR("bool_EQ_CONV","does not have boolean type")
   in if (lhs=rhs) 
      then EQT_INTRO (REFL lhs) 
      else if (lhs=truth)
           then SPEC rhs Tb 
           else if (rhs=truth) 
                then SPEC lhs bT
                else ERR("bool_EQ_CONV","inapplicable")
   end
   handle e => WRAP_ERR("bool_EQ_CONV",e)
end;


(* ---------------------------------------------------------------------*)
(* COND_CONV: conversion for simplifying conditionals:			*)
(*									*)
(*   --------------------------- COND_CONV "T => u | v"			*)
(*     |- (T => u | v) = u 						*)
(*                                                                      *)
(*									*)
(*   --------------------------- COND_CONV "F => u | v"			*)
(*     |- (F => u | v) = v 						*)
(*									*)
(*									*)
(*   --------------------------- COND_CONV "b => u | u"			*)
(*     |- (b => u | u) = u 						*)
(*									*)
(*   --------------------------- COND_CONV "b => u | v"	(u =alpha v)	*)
(*     |- (b => u | v) = u 						*)
(*									*)
(* COND_CONV "P=>u|v" fails if P is neither "T" nor "F" and u =/= v.	*)
(* ---------------------------------------------------------------------*)
local
val vt = genvar (==`:'a`==) 
and vf =  genvar (==`:'a`==) 
val gen = GENL [vt,vf] 
val (CT,CF) = (gen ## gen) (CONJ_PAIR (SPECL [vt,vf] COND_CLAUSES))
val alpha = ==`:'a`==
exception BAD_STRUCT
in
fun COND_CONV tm =
   let val {cond,larm,rarm} = dest_cond tm handle _ => raise BAD_STRUCT
       val INST_TYPE' = INST_TYPE [alpha |-> type_of larm]
   in
   if (cond=truth) 
   then SPEC rarm (SPEC larm (INST_TYPE' CT)) 
   else if (cond=falsity) 
        then SPEC rarm (SPEC larm (INST_TYPE' CF)) 
        else if (larm=rarm) 
             then SPEC larm (SPEC cond (INST_TYPE' COND_ID)) 
             else if (aconv larm rarm) 
                  then let val cnd = AP_TERM (rator tm) (ALPHA rarm larm)
                           val th = SPEC larm (SPEC cond (INST_TYPE' COND_ID)) 
                       in
                       TRANS cnd th 
                       end
                  else ERR("COND_CONV", "")
   end
   handle BAD_STRUCT => ERR("COND_CONV", "not a cond")
        | e => WRAP_ERR("Conv",e)
end;


(* -------------------------------------------------------------------- *)
(* COND_CASES_TAC: tactic for doing a case split on the condition p	*)
(*                 in a conditional (p => u | v).			*)
(*									*)
(* Find a conditional "p => u | v" that is free in the goal and whose 	*)
(* condition p is not a constant. Perform a case split on the condition.*)
(*                                                                      *)
(*									*)
(*	t[p=>u|v]							*)
(*    =================	 COND_CASES_TAC					*)
(*       {p}  t[u]							*)
(*       {~p}  t[v]							*)
(*									*)
(* 						[Revised: TFM 90.05.11] *)
(* -------------------------------------------------------------------- *)

local
fun is_good_cond tm = not(is_const(#cond(dest_cond tm))) 
                      handle _ => false
val alpha =  ==`:'a`==
in
fun COND_CASES_TAC (asl,w) =
   let val cond = find_term
                   (fn tm => is_good_cond tm andalso free_in tm w)  w
           handle _ => ERR("COND_CASES_TAC","")
       val {cond,larm,rarm} = dest_cond cond
       val inst = INST_TYPE[alpha |-> type_of larm] COND_CLAUSES
       val (ct,cf) = CONJ_PAIR (SPEC rarm (SPEC larm inst))
   in
   DISJ_CASES_THEN2
     (fn th =>  SUBST1_TAC (EQT_INTRO th) THEN 
                SUBST1_TAC ct THEN ASSUME_TAC th)
     (fn th => SUBST1_TAC (EQF_INTRO th) THEN 
               SUBST1_TAC cf THEN ASSUME_TAC th)
     (SPEC cond EXCLUDED_MIDDLE)
     (asl,w)
   end
end;


end;


@
