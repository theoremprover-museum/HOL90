val it = () : unit
- GC #0.0.0.0.1.13:   (0 ms)
GC #0.0.0.1.2.36:   (10 ms)
GC #0.0.0.1.3.46:   (0 ms)
[opening /usr/groups/hol/hol90.10/src/3/sources.sml]
[opening ../theories/src/ld_HOL.sml]

Loading theory "HOL"

Theory "BASIC_HOL" already consistent with disk, hence not exported.
structure HOL : sig end
val it = () : unit
GC #0.0.0.1.4.71:   (0 ms)
GC #0.0.0.1.5.97:   (20 ms)
GC #0.0.1.2.6.135:   (40 ms)
GC #0.0.1.2.7.150:   (10 ms)
GC #0.0.1.2.8.169:   (10 ms)
GC #0.0.2.3.9.188:   (50 ms)
GC #0.0.2.3.10.303:   (10 ms)
[opening 3/core.sml]
structure Core :
  sig
    structure Extend_hol_pp : <sig>
    structure Min : <sig>
    structure Parse_support : <sig>
    structure Term : <sig>
    structure Theory : <sig>
    structure Thm : <sig>
    structure Type : <sig>
    type autoload_info =
      {Axioms:string list, Definitions:string list, Theorems:string list,
       Theory:string}
    type conv = term -> thm
    datatype fixity = Binder | Infix of int | Prefix
    datatype 'a frag = ANTIQUOTE of 'a | QUOTE of string
    type goal = term list * term
    datatype hol_type = ...
    type ('a,'b) istream
    datatype just_arg
      = JA_INT of int
      | JA_INTLIST of int list
      | JA_PAIR of just_arg * just_arg
      | JA_STRING of string
      | JA_TERM of term
      | JA_THM of thm
      | JA_TYPE of hol_type
    datatype lambda
      = COMB of {Rand:term, Rator:term}
      | CONST of {Name:string, Ty:hol_type}
      | LAMB of {Body:term, Bvar:term}
      | VAR of {Name:string, Ty:hol_type}
    type lib
    datatype 'a net = ...
    type rewrites
    datatype step = STEP of {Just:just_arg list, Name:string, Thm:thm}
    type 'a subst = {redex:'a, residue:'a} list
    type tactic = goal -> tactic_result
    type tactic_result = goal list * validation
    datatype term = ...
    datatype thm = ...
    type thm_tactic = thm -> tactic
    type thm_tactical = thm_tactic -> thm_tactic
    type time = time
    type validation = thm list -> thm
    exception HOL_ERR of {message:string, origin_function:string,
                          origin_structure:string}
    exception NOT_FOUND
    exception NO_CHANGE
    val ## : ('a -> 'c) * ('b -> 'd) -> 'a * 'b -> 'c * 'd
    val -- : term frag list -> 'a -> term
    val == : term frag list -> 'a -> hol_type
    val A : ('a -> 'b) -> 'a -> 'b
    val ABS : term -> thm -> thm
    val ABS_CONV : conv -> conv
    val ABS_REP_THM : thm
    val ABS_SIMP : thm
    val ACCEPT_TAC : thm_tactic
    val AC_CONV : thm * thm -> conv
    val ADD_ASSUM : term -> thm -> thm
    val ALL_CONV : conv
    val ALL_TAC : tactic
    val ALL_THEN : thm_tactical
    val ALPHA : term -> term -> thm
    val ALPHA_CONV : term -> term -> thm
    val AND1_THM : thm
    val AND2_THM : thm
    val AND_CLAUSES : thm
    val AND_DEF : thm
    val AND_EXISTS_CONV : conv
    val AND_FORALL_CONV : conv
    val AND_IMP_INTRO : thm
    val AND_INTRO_THM : thm
    val ANTE_CONJ_CONV : conv
    val ANTE_RES_THEN : thm_tactical
    val AP_TERM : term -> thm -> thm
    val AP_TERM_TAC : tactic
    val AP_THM : thm -> term -> thm
    val AP_THM_TAC : tactic
    val ASM_CASES_TAC : term -> tactic
    val ASM_REWRITE_RULE : thm list -> thm -> thm
    val ASM_REWRITE_TAC : thm list -> tactic
    val ASSUME : term -> thm
    val ASSUME_TAC : thm_tactic
    val ASSUM_LIST : (thm list -> tactic) -> tactic
    val B : ('a -> 'c) -> ('b -> 'a) -> 'b -> 'c
    val BETA_CONV : term -> thm
    val BETA_RULE : thm -> thm
    val BETA_TAC : tactic
    val BODY_CONJUNCTS : thm -> thm list
    val BOOL_CASES_AX : thm
    val BOOL_CASES_TAC : term -> tactic
    val BOOL_EQ_DISTINCT : thm
    val C : ('b -> 'a -> 'c) -> 'a -> 'b -> 'c
    val CASES_THENL : thm_tactic list -> thm_tactic
    val CCONTR : term -> thm -> thm
    val CCONTR_TAC : tactic
    val CHANGED_CONV : conv -> conv
    val CHANGED_TAC : tactic -> tactic
    val CHECK_ASSUME_TAC : thm_tactic
    val CHOOSE : term * thm -> thm -> thm
    val CHOOSE_TAC : thm_tactic
    val CHOOSE_THEN : thm_tactical
    val COND_ABS : thm
    val COND_CASES_TAC : tactic
    val COND_CLAUSES : thm
    val COND_CONV : conv
    val COND_DEF : thm
    val COND_EXPAND : thm
    val COND_ID : thm
    val COND_RAND : thm
    val COND_RATOR : thm
    val CONJ : thm -> thm -> thm
    val CONJUNCT1 : thm -> thm
    val CONJUNCT2 : thm -> thm
    val CONJUNCTS : thm -> thm list
    val CONJUNCTS_CONV : term * term -> thm
    val CONJUNCTS_THEN : thm_tactical
    val CONJUNCTS_THEN2 : thm_tactic -> thm_tactical
    val CONJ_ASSOC : thm
    val CONJ_DISCH : term -> thm -> thm
    val CONJ_DISCHL : term list -> thm ->GC #0.0.2.3.11.402:   (0 ms)
 thm
    val CONJ_LIST : int -> thm -> thm list
    val CONJ_PAIR : thm -> thm * thm
    val CONJ_SET_CONV : term list -> term list -> thm
    val CONJ_SYM : thm
    val CONJ_TAC : tactic
    val CONTR : term -> thm -> thm
    val CONTRAPOS : thm -> thm
    val CONTRAPOS_CONV : conv
    val CONTR_TAC : thm_tactic
    val CONV_RULE : conv -> thm -> thm
    val CONV_TAC : conv -> tactic
    val DEPTH_CONV : conv -> conv
    val DE_MORGAN_THM : thm
    val DISCARD_TAC : thm -> tactic
    val DISCH : term -> thm -> thm
    val DISCH_ALL : thm -> thm
    val DISCH_TAC : tactic
    val DISCH_THEN : thm_tactic -> tactic
    val DISJ1 : thm -> term -> thm
    val DISJ1_TAC : tactic
    val DISJ2 : term -> thm -> thm
    val DISJ2_TAC : tactic
    val DISJ_ASSOC : thm
    val DISJ_CASES : thm -> thm -> thm -> thm
    val DISJ_CASES_TAC : thm_tactic
    val DISJ_CASES_THEN : thm_tactical
    val DISJ_CASES_THEN2 : thm_tactic -> thm_tactical
    val DISJ_CASES_THENL : thm_tactic list -> thm_tactic
    val DISJ_CASES_UNION : thm -> thm -> thm -> thm
    val DISJ_IMP : thm -> thm
    val DISJ_SYM : thm
    val EQF_ELIM : thm -> thm
    val EQF_INTRO : thm -> thm
    val EQT_ELIM : thm -> thm
    val EQT_INTRO : thm -> thm
    val EQ_CLAUSES : thm
    val EQ_EXPAND : thm
    val EQ_EXT : thm
    val EQ_IMP_RULE : thm -> thm * thm
    val EQ_IMP_THM : thm
    val EQ_MP : thm -> thm -> thm
    val EQ_REFL : thm
    val EQ_SYM : thm
    val EQ_SYM_EQ : thm
    val EQ_TAC : tactic
    val EQ_TRANS : thm
    val ETA_AX : thm
    val ETA_CONV : term -> thm
    val EVERY : tactic list -> tactic
    val EVERY_ASSUM : thm_tactic -> tactic
    val EVERY_CONV : conv list -> conv
    val EVERY_TCL : thm_tactical list -> thm_tactical
    val EXCLUDED_MIDDLE : thm
    val EXISTENCE : thm -> thm
    val EXISTS : term * term -> thm -> thm
    val EXISTS_AND_CONV : conv
    val EXISTS_DEF : thm
    val EXISTS_EQ : term -> thm -> thm
    val EXISTS_IMP : term -> thm -> thm
    val EXISTS_IMP_CONV : conv
    val EXISTS_NOT_CONV : conv
    val EXISTS_OR_CONV : conv
    val EXISTS_SIMP : thm
    val EXISTS_TAC : term -> tactic
    val EXISTS_UNIQUE_CONV : conv
    val EXISTS_UNIQUE_DEF : thm
    val EXT : thm -> thm
    val FAIL_TAC : string -> goal -> 'a
    val FALSITY : thm
    val FILTER_ASM_REWRITE_RULE : (term -> bool) -> thm list -> thm -> thm
    val FILTER_ASM_REWRITE_TAC : (term -> bool) -> thm list -> tactic
    val FILTER_DISCH_TAC : term -> tactic
    val FILTER_DISCH_THEN : thm_tactic -> term -> tactic
    val FILTER_GEN_TAC : term -> tactic
    val FILTER_ONCE_ASM_REWRITE_RULE : (term -> bool) -> thm list -> thm -> thm
    val FILTER_ONCE_ASM_REWRITE_TAC : (term -> bool) -> thm list -> tactic
    val FILTER_PURE_ASM_REWRITE_RULE : (term -> bool) -> thm list -> thm -> thm
    val FILTER_PURE_ASM_REWRITE_TAC : (term -> bool) -> thm list -> tactic
    val FILTER_PURE_ONCE_ASM_REWRITE_RULE : (term -> bool)
                                            -> thm list -> thm -> thm
    val FILTER_PURE_ONCE_ASM_REWRITE_TAC : (term -> bool) -> thm list -> tactic
    val FILTER_STRIP_TAC : term -> tactic
    val FILTER_STRIP_THEN : thm_tactic -> term -> tactic
    val FIRST : tactic list -> tactic
    val FIRST_ASSUM : thm_tactic -> tactic
    val FIRST_CONV : conv list -> conv
    val FIRST_TCL : thm_tactical list -> thm_tactical
    val FORALL_AND_CONV : conv
    val FORALL_DEF : thm
    val FORALL_EQ : term -> thm -> thm
    val FORALL_IMP_CONV : conv
    val FORALL_NOT_CONV : conv
    val FORALL_OR_CONV : conv
    val FORALL_SIMP : thm
    val FREEZE_THEN : thm_tactical
    val FRONT_CONJ_CONV : term list -> term -> thm
    val FUN_EQ_CONV : conv
    val F_DEF : thm
    val F_IMP : thm
    val GEN : term -> thm -> thm
    val GENL : term list -> thm -> thm
    val GEN_ALL : thm -> thm
    val GEN_ALPHA_CONV : term -> term -> thm
    val GEN_REWRITE_CONV : (conv -> conv) -> rewrites -> thm list -> conv
    val GEN_REWRITE_RULE : (conv -> conv) -> rewrites -> thm list -> thm -> thm
    val GEN_REWRITE_TAC : (conv -> conv) -> rewrites -> thm list -> tactic
    val GEN_TAC : tactic
    val GSPEC : thm -> thm
    val GSUBST_TAC : (term subst -> term -> term) -> thm list -> tactic
    val GSYM : thm -> thm
    val HOLdir : string ref
    val I : 'a -> 'a
    val IMP_ANTISYM_AX : thm
    val IMP_ANTISYM_RULE : thm -> thm -> thm
    val IMP_CANON : thm -> thm list
    val IMP_CLAUSES : thm
    val IMP_CONJ : thm -> thm -> thm
    val IMP_DISJ_THM : thm
    val IMP_ELIM : thm -> thm
    val IMP_F : thm
    val IMP_F_EQ_F : thm
    val IMP_RES_TAC : thm_tactic
    val IMP_RES_THEN : thm_tactic -> thm -> tactic
    val IMP_TRANS : thm -> thm -> thm
    val INDUCT_THEN : thm -> thm_tactic -> tactic
    val INFINITY_AX : thm
    val INST : term subst -> thm -> thm
    val INST_TYPE : hol_type subst -> thm -> thm
    val INST_TY_TERM : term subst * hol_type subst -> thm -> thm
    val ISPEC : term -> thm -> thm
    val ISPECL : term list -> thm -> thm
    val K : 'b -> 'a -> 'b
    val L : (string * thm) list ref
    val LEFT_AND_EXISTS_CONV : conv
    val LEFT_AND_FORALL_CONV : conv
    val LEFT_AND_OVER_OR : thm
    val LEFT_IMP_EXISTS_CONV : conv
    val LEFT_IMP_FORALL_CONV : conv
    val LEFT_OR_EXISTS_CONV : conv
    val LEFT_OR_FORALL_CONV : conv
    val LEFT_OR_OVER_AND : thm
    val LET_DEF : thm
    val LIST_BETA_CONV : term -> thm
    val LIST_CONJ : thm list -> thm
    val LIST_MK_EXISTS : term list -> thm -> thm
    val LIST_MP : thm list -> thm -> thm
    val MAP_EVERY : ('a -> tactic) -> 'a list -> tactic
    val MAP_FIRST : ('a -> tactic) -> 'a list -> tactic
    val MATCH_ACCEPT_TAC : thm_tactic
    val MATCH_MP : thm -> thm -> thm
    val MATCH_MP_TAC : thm_tactic
    val MK_ABS : thm -> thm
    val MK_COMB : thm * thm -> thm
    val MK_EXISTS : thm -> thm
    val MP : thm -> thm -> thm
    val MP_TAC : thm_tactic
    val NEG_DISCH : term -> thm -> thm
    val NOT_AND : thm
    val NOT_CLAUSES : thm
    val NOT_DEF : thm
    val NOT_ELIM : thm -> thm
    val NOT_EQ_SYM : thm -> thm
    val NOT_EXISTS_CONV : conv
    val NOT_F : thm
    val NOT_FORALL_CONV : conv
    val NOT_IMP : thm
    val NOT_INTRO : thm -> thm
    val NO_CONV : conv
    val NO_TAC : goal -> 'a
    val NO_THEN : thm_tactical
    val ONCE_ASM_REWRITE_RULE : thm list -> thm -> thm
    val ONCE_ASM_REWRITE_TAC : thm list -> tactic
    val ONCE_DEPTH_CONV : conv -> conv
    val ONCE_REWRITE_CONV : thm list -> conv
    val ONCE_REWRITE_RULE : thm list -> thm -> thm
    val ONCE_REWRITE_TAC : thm list -> tactic
    val ONE_ONE_DEF : thm
    val ONTO_DEF : thm
    val ORELSE : tactic * tactic -> tactic
    val ORELSEC : conv * conv -> conv
    val ORELSE_TCL : thm_tactical * thm_tactical -> thm_tactical
    val OR_CLAUSES : thm
    val OR_DEF : thm
    val OR_ELIM_THM : thm
    val OR_EXISTS_CONV : conv
    val OR_FORALL_CONV : conv
    val OR_IMP_THM : thm
    val OR_INTRO_THM1 : thm
    val OR_INTRO_THM2 : thm
    val PART_MATCH : (term -> term) -> thm -> conv
    val POP_ASSUM : thm_tactic -> tactic
    val POP_ASSUM_LIST : (thm list -> tactic) -> tactic
    val PROVE_HYP : thm -> thm -> thm
    val PURE_ASM_REWRITE_RULE : thm list -> thm -> thm
    val PURE_ASM_REWRITE_TAC : thm list -> tactic
    val PURE_ONCE_ASM_REWRITE_RULE : thm list -> thm -> thm
    val PURE_ONCE_ASM_REWRITE_TAC : thm list -> tactic
    val PURE_ONCE_REWRITE_CONV : thm list -> conv
    val PURE_ONCE_REWRITE_RULE : thm list -> thm -> thm
    val PURE_ONCE_REWRITE_TAC : thm list -> tactic
    val PURE_REWRITE_CONV : thm list -> conv
    val PURE_REWRITE_RULE : thm list -> thm -> thm
    val PURE_REWRITE_TAC : thm list -> tactic
    val RAND_CONV : conv -> conv
    val RATOR_CONV : conv -> conv
    val REDEPTH_CONV : conv -> conv
    val REFL : term -> thm
    val REFL_CLAUSE : thm
    val REFL_TAC : tactic
    val REPEAT : tactic -> tactic
    val REPEATC : conv -> conv
    val REPEAT_GTCL : thm_tactical -> (thm -> tactic) -> thm_tactic
    val REPEAT_TCL : thm_tactical -> thm_tactical
    val RES_CANON : thm -> thm list
    val RES_TAC : tactic
    val RES_THEN : thm_tactic -> tactic
    val REWRITES_CONV : rewrites -> conv
    val REWRITE_CONV : thm list -> conv
    val REWRITE_RULE : thm list -> thm -> thm
    val REWRITE_TAC : thm list -> tactic
    val REWR_CONV : thm -> conv
    val RIGHT_AND_EXISTS_CONV : conv
    val RIGHT_AND_FORALL_CONV : conv
    val RIGHT_AND_OVER_OR : thm
    val RIGHT_BETA : thm -> thm
    val RIGHT_CONV_RULE : conv -> thm -> thm
    val RIGHT_IMP_EXISTS_CONV : conv
    val RIGHT_IMP_FORALL_CONV : conv
    val RIGHT_LIST_BETA : thm -> thm
    val RIGHT_OR_EXISTS_CONV : conv
    val RIGHT_OR_FORALL_CONV : conv
    val RIGHT_OR_OVER_AND : thm
    val RULE_ASSUM_TAC : (thm -> thm) -> tactic
    val Raise : exn -> 'a
    val S : ('b -> 'a -> 'c) -> ('b -> 'a) -> 'b -> 'c
    val SELECT_AX : thm
    val SELECT_CONV : conv
    val SELECT_ELIM : thm -> term * thm -> thm
    val SELECT_EQ : term -> thm -> thm
    val SELECT_INTRO : thm -> thm
    val SELECT_REFL : thm
    val SELECT_RULE : thm -> thm
    val SELECT_UNIQUE : thm
    val SKOLEM_CONV : conv
    val SPEC : term -> thm -> thm
    val SPECL : term list -> thm -> thm
    val SPEC_ALL : thm -> thm
    val SPEC_TAC : term * term -> tactic
    val SPEC_VAR : thm -> term * thm
    val STRIP_ASSUME_TAC : thm_tactic
    val STRIP_GOAL_THEN : thm_tactic -> tactic
    val STRIP_TAC : tactic
    val STRIP_THM_THEN : thm_tactical
    val STRUCT_CASES_TAC : thm_tactic
    val SUBGOAL_THEN : term -> thm_tactic -> tactic
    val SUBS : thm list -> thm -> thm
    val SUBST : {thm:thm, var:term} list -> term -> thm -> thm
    val SUBST1_TAC : thm -> tactic
    val SUBST_ALL_TAC : thm -> tactic
    val SUBST_CONV : {thm:thm, var:term} list -> term -> term -> thm
    val SUBST_MATCH : thm -> thm -> thm
    val SUBST_OCCS_TAC : (int list * thm) list -> tactic
    val SUBST_TAC : thm list -> tactic
    val SUBS_OCCS : (int list * thm) list -> thm -> thm
    val SUB_CONV : conv -> conv
    val SWAP_EXISTS_CONV : conv
    val SYM : thm -> thm
    val SYM_CONV : conv
    val TAC_PROOF : goal * tactic -> thm
    val THEN : tactic * tactic -> tactic
    val THENC : conv * conv -> conv
    val THENL : tactic * tactic list -> tactic
    val THEN_TCL : thm_tactical * thm_tactical -> thm_tactical
    val TOP_DEPTH_CONV : conv -> conv
    val TRANS : thm -> thm -> thm
    val TRUTH : thm
    val TRY : tactic -> tactic
    val TRY_CONV : conv -> conv
    val TYPE_DEFINITION : thm
    val T_DEF : thm
    val U : ''a list list -> ''a list
    val UNDISCH : thm -> thm
    val UNDISCH_ALL : thm -> thm
    val UNDISCH_TAC : term -> tactic
    val VALID : tactic -> tactic
    val W : ('a -> 'a -> 'b) -> 'a -> 'b
    val X_CASES_THEN : term list list -> thm_tactical
    val X_CASES_THENL : (('a list -> 'b list -> ('a * 'b) list)
                         -> thm_tactic list -> (term list * thm_tactic) list)
                        -> thm_tactic list -> thm_tactic
    val X_CHOOSE_TAC : term -> thm_tactic
    val X_CHOOSE_THEN : term -> thm_tactical
    val X_FUN_EQ_CONV : term -> conv
    val X_GEN_TAC : term -> tactic
    val X_SKOLEM_CONV : term -> conv
    val aconv : term -> term -> bool
    val add_axioms_to_sml : string -> unit
    val add_definitions_to_sml : string -> unit
    val add_implicit_rewrites : thm list -> unit
    val add_rewrites : rewrites -> thm list -> rewrites
    val add_theorems_to_sml : string -> unit
    val add_theory_structure_to_sml : {structure_name:string,
                                       theory_name:string}
                                      -> unit
    val add_theory_to_sml : string -> unit
    val add_to_sml : (string * thm) list -> unit
    val all : ('a -> bool) -> 'a list -> bool
    val all2 : ('a -> 'b -> bool) -> 'a list -> 'b list -> bool
    val all_vars : term -> term list
    val all_varsl : term list -> term list
    val allow_theorems_with_assumptions : bool ref
    val ancestry : string -> string list
    val append : 'a list -> 'a list -> 'a list
    val append_path : string -> string list ref -> unit
    val arity : string -> int
    val assert : ('a -> bool) -> 'a -> 'a
    val assert_neg_defined : unit -> unit
    val assert_nums_defined : unit -> unit
    val assert_strings_defined : unit -> unit
    val assoc : ''a -> (''a * 'b) list -> 'b
    val assoc1 : ''a -> (''a * 'b) list -> (''a * 'b) option
    val assoc2 : ''b -> ('a * ''b) list -> ('a * ''b) option
    val associate_restriction : string * string -> unit
    val axiom : string -> string -> thm
    val axioms : string -> (string * thm) list
    val beta_conv : term -> term
    val binder_restrictions : unit -> (string * string) list
    val binders : string -> term list
    val body : term -> term
    val bool : hol_type
    val bool_EQ_CONV : conv
    val bool_rewrites : rewrites
    val bvar : term -> term
    val can : ('b -> 'a) -> 'b -> bool
    val clean_directory : string -> unit
    val close : unit -> unit
    val close_theory : unit -> unit
    val combine : 'a list * 'b list -> ('a * 'b) list
    val compile : string -> unit
    val concat : string -> string -> string
    val concl : thm -> term
    val cons_path : string -> string list ref -> unit
    val const_decl : string -> {const:term, place:fixity, theory:string}
    val constants : string -> term list
    val counting_thms : bool -> unit
    val current_theory : unit -> string
    val curry : ('a * 'b -> 'c) -> 'a -> 'b -> 'c
    val de_abs : term -> term list * term
    val define_new_type_bijections : {ABS:string, REP:string, name:string,
                                      tyax:thm}
                                     -> thm
    val definition : string -> string -> thm
    val definitions : string -> (string * thm) list
    val delete_cache : unit -> unit
    val delete_library : lib -> unit
    val delete_restriction : string -> unit
    val delete_theory_from_cache : string -> unit
    val dest_abs : term -> {Body:term, Bvar:term}
    val dest_comb : term -> {Rand:term, Rator:term}
    val dest_cond : term -> {cond:term, larm:term, rarm:term}
    val dest_conj : term -> {conj1:term, conj2:term}
    val dest_cons : term -> {hd:term, tl:term}
    val dest_const : term -> {Name:string, Ty:hol_type}
    val dest_disj : term -> {disj1:term, disj2:term}
    val dest_eq : term -> {lhs:term, rhs:term}
    val dest_exists : term -> {Body:term, Bvar:term}
    val dest_forall : term -> {Body:term, Bvar:term}
    val dest_imp : term -> {ant:term, conseq:term}
    val dest_let : term -> {arg:term, func:term}
    val dest_library : lib
                       -> {code:string list, doc:string, help:string list,
                           name:string, parents:lib list, path:string,
                           theories:string list}
    val dest_list : term -> {els:term list, ty:hol_type}
    val dest_neg : term -> term
    val dest_pabs : term -> {body:term, varstruct:term}
    val dest_pair : term -> {fst:term, snd:term}
    val dest_rewrites : rewrites -> thm list
    val dest_select : term -> {Body:term, Bvar:term}
    val dest_term : term -> lambda
    val dest_thm : thm -> term list * term
    val dest_type : hol_type -> {Args:hol_type list, Tyop:string}
    val dest_var : term -> {Name:string, Ty:hol_type}
    val dest_vartype : hol_type -> string
    val disch : term * term list -> term list
    val draft_mode : unit -> bool
    val el : int -> 'a list -> 'a
    val empty_net : 'a net
    val empty_rewrites : rewrites
    val end_itlist : ('a -> 'a -> 'a) -> 'a list -> 'a
    val enter : term * 'a -> 'a net -> 'a net
    val equal : ''a -> ''a -> bool
    val exists : ('a -> bool) -> 'a list -> bool
    val export_theory : unit -> unit
    val extend_theory : string -> unit
    val file_exists_for_reading : string -> bool
    val filter : ('a -> bool) -> 'a list -> 'a list
    val find_library : string -> lib
    val find_path : string list -> string -> string
    val find_term : (term -> bool) -> term -> term
    val find_terms : (term -> bool) -> term -> term list
    val first : ('a -> bool) -> 'a list -> 'a
    val fixity : string -> fixity
    val fixity_of_term : string -> fixity
    val fixity_to_string : fixity -> string
    val flatten : 'a list list -> 'a list
    val for : int -> int -> (int -> 'a) -> 'a list
    val for_se : int -> int -> (int -> 'a) -> unit
    val free_in : term -> term -> bool
    val free_vars : term -> term list
    val free_varsl : term list -> term list
    val fresh_tyvar_stream : unit -> (int,hol_type) istream
    val front_last : 'a list -> 'a list * 'a
    val fst : 'b * 'a -> 'b
    val funpow : int -> ('a -> 'a) -> 'a -> 'a
    val gather : ('a -> bool) -> 'a list -> 'a list
    val gen_all : term -> term
    val genvar : hol_type -> term
    val genvars : hol_type -> int -> term list
    val get_autoloads : string -> autoload_info option
    val get_library_from_disk : string -> lib
    val goal_line : string ref
    val help_path : string list ref
    val html_theory : string -> unit
    val hyp : thm -> term list
    val hyp_union : thm list -> term list
    val implicit_rewrites : unit -> rewrites
    val in_at_end : bool ref
    val in_type_spec : string option ref
    val infix_at_front : bool ref
    val infix_ty : hol_type -> hol_type -> hol_type
    val infixes : string -> term list
    val insert : ''a -> ''a list -> ''a list
    val inst : hol_type subst -> term -> term
    val install : string -> unit
    val install_system_theory : string -> unit
    val int_sort : int list -> int list
    val int_to_string : int -> string
    val interp : bool ref
    val interpret : string -> unit
    val intersect : ''a list -> ''a list -> ''a list
    val is_abs : term -> bool
    val is_binder : string -> bool
    val is_comb : term -> bool
    val is_cond : term -> bool
    val is_conj : term -> bool
    val is_cons : term -> bool
    val is_const : term -> bool
    val is_constant : string -> bool
    val is_disj : term -> bool
    val is_eq : term -> bool
    val is_exists : term -> bool
    val is_forall : term -> bool
    val is_imp : term -> bool
    val is_infix : string -> bool
    val is_let : term -> bool
    val is_list : term -> bool
    val is_neg : term -> bool
    val is_pabs : term -> bool
    val is_pair : term -> bool
    val is_polymorphic : string -> bool
    val is_recording_proof : unit -> bool
    val is_select : term -> bool
    val is_type : string -> bool
    val is_var : term -> bool
    val is_vartype : hol_type -> bool
    val itlist : ('a -> 'b -> 'b) -> 'a list -> 'b -> 'b
    val itlist2 : ('a -> 'b -> 'c -> 'c) -> 'a list -> 'b list -> 'c -> 'c
    val known_libraries : unit -> lib list
    val last : 'a list -> 'a
    val lhs : term -> term
    val lib_eq : lib -> lib -> bool
    val lib_help : {lib:lib, topic:string} -> unit
    val library_path : string list ref
    val linewidth : int ref
    val list_mk_abs : term list * term -> term
    val list_mk_comb : term * term list -> term
    val list_mk_conj : term list -> term
    val list_mk_disj : term list -> term
    val list_mk_exists : term list * term -> term
    val list_mk_forall : term list * term -> term
    val list_mk_imp : term list * term -> term
    val list_mk_pair : term list -> term
    val list_of_array : 'a array -> 'a list
    val loadLibThry : string -> string -> unit
    val load_library : {lib:lib, theory:string} -> unit
    val load_library_in_place : lib -> unit
    val load_theory : string -> unit
    val loaded_cell : (unit -> unit) ref
    val loaded_libraries : unit -> lib list
    val lookup : term -> 'a net -> 'a list
    val map2 : ('a -> 'b -> 'c) -> 'a list -> 'b list -> 'c list
    val mapfilter : ('a -> 'b) -> 'a list -> 'b list
    val match_term : term -> term -> term subst * hol_type subst
    val match_type : hol_type -> hol_type -> hol_type subst
    val max_print_depth : int ref
    val mem : ''a -> ''a list -> bool
    val mesg : bool -> string -> unit
    val mk_abs : {Body:term, Bvar:term} -> term
    val mk_axiom_thm : term list * term -> thm
    val mk_comb : {Rand:term, Rator:term} -> term
    val mk_cond : {cond:term, larm:term, rarm:term} -> term
    val mk_conj : {conj1:term, conj2:term} -> term
    val mk_cons : {hd:term, tl:term} -> term
    val mk_const : {Name:string, Ty:hol_type} -> term
    val mk_definition_thm : term list * term -> thm
    val mk_disj : {disj1:term, disj2:term} -> term
    val mk_disk_thm : term list * term -> thm
    val mk_drule_thm : term list * term -> thm
    val mk_eq : {lhs:term, rhs:term} -> term
    val mk_exists : {Body:term, Bvar:term} -> term
    val mk_forall : {Body:term, Bvar:term} -> term
    val mk_imp : {ant:term, conseq:term} -> term
    val mk_istream : ('a -> 'a) -> 'a -> ('a -> 'b) -> ('a,'b) istream
    val mk_let : {arg:term, func:term} -> term
    val mk_list : {els:term list, ty:hol_type} -> term
    val mk_neg : term -> term
    val mk_pabs : {body:term, varstruct:term} -> term
    val mk_pair : {fst:term, snd:term} -> term
    val mk_primed_var : {Name:string, Ty:hol_type} -> term
    val mk_rewrites : thm -> thm list
    val mk_select : {Body:term, Bvar:term} -> term
    val mk_set : ''a list -> ''a list
    val mk_tac_thm : term list * term -> thm
    val mk_thm : term list * term -> thm
    val mk_type : {Args:hol_type list, Tyop:string} -> hol_type
    val mk_var : {Name:string, Ty:hol_type} -> term
    val mk_vartype : string -> hol_type
    val move_library : lib * string -> unit
    val neg_defined : unit -> bool
    val new_binder : {Name:string, Ty:hol_type} -> unit
    val new_binder_definition : string * term -> thm
    val new_constant : {Name:string, Ty:hol_type} -> unit
    val new_definition : string * term -> thm
    val new_infix : {Name:string, Prec:int, Ty:hol_type} -> unit
    val new_infix_definition : string * term * int -> thm
    val new_library : {code:string list, doc:string, help:string list,
                       loaded:string, name:string, parents:lib list,
                       path:string, theories:string list}
                      -> lib
    val new_open_axiom : string * term -> thm
    val new_parent : string -> unit
    val new_recursive_definition : {def:term, fixity:fixity, name:string,
                                    rec_axiom:thm}
                                   -> thm
    val new_specification : {consts:{const_name:string, fixity:fixity} list,
                             name:string, sat_thm:thm}
                            -> thm
    val new_theory : string -> unit
    val new_type : {Arity:int, Name:string} -> unit
    val new_type_definition : {inhab_thm:thm, name:string, pred:term} -> thm
    val next : ('a,'b) istream -> ('a,'b) istream
    val note : step * thm -> thm
    val notify_on_tyvar_guess : bool ref
    val null_intersection : ''a list -> ''a list -> bool
    val nums_defined : unit -> bool
    val op_U : ('a -> 'a -> bool) -> 'a list list -> 'a list
    val op_intersect : ('a -> 'a -> bool) -> 'a list -> 'a list -> 'a list
    val op_mem : ('a -> 'b -> bool) -> 'a -> 'b list -> bool
    val op_union : ('a -> 'a -> bool) -> 'a list -> 'a list -> 'a list
    val ordof : string * int -> int
    val output_HOL_ERR : ({message:string, origin_function:string,
                           origin_structure:string}
                          -> unit) ref
    val output_help : string ref
    val parents : string -> string list
    val parse0 : (int,hol_type) istream
                 -> string -> term list -> Parse_support.parse
    val parser : thm frag list -> thm
    val partition : ('a -> bool) -> 'a list -> 'a list * 'a list
    val paths : {HOLdir:string ref, help_path:string list ref,
                 library_path:string list ref, theory_path:string list ref}
    val perform_atomic_theory_op : (unit -> 'a) -> 'a
    val pp_flags : {in_at_end:bool ref, infix_at_front:bool ref,
                    show_dB:bool ref, show_restrict:bool ref,
                    show_types:bool ref, stack_infixes:bool ref}
    val pp_library : ?.PrettyPrint.ppstream -> lib -> unit
    val pp_rewrites : ?.PrettyPrint.ppstream -> rewrites -> unit
    val pp_self_parsing_term : ?.PrettyPrint.ppstream -> term -> unit
    val pp_self_parsing_type : ?.PrettyPrint.ppstream -> hol_type -> unit
    val pp_term : ?.PrettyPrint.ppstream -> term -> unit
    val pp_thm : ?.PrettyPrint.ppstream -> thm -> unit
    val pp_type : ?.PrettyPrint.ppstream -> hol_type -> int -> unit
    val prec_of_term : string -> int
    val precedence : string -> int
    val preterm_parser : (int,hol_type) istream
                         -> term frag list -> Preterm.preterm
    val prim_load_library : (string -> unit)
                            -> {lib:lib, theory:string} -> unit
    val prim_load_library' : (string list -> unit)
                             -> {lib:lib, theory:string} -> unit
    val print_HOL_ERR : exn -> unit
    val print_banner : string -> unit
    val print_exceptions : bool ref
    val print_term : term -> unit
    val print_theory : string -> unit
    val print_theory_to_file : {file:string, theory:string} -> unit
    val print_theory_to_outstream : {outstream:Portable.outstream,
                                     theory:string}
                                    -> Portable.outstream
    val print_thm : thm -> unit
    val print_type : hol_type -> unit
    val prove : term * tactic -> thm
    val prove_abs_fn_one_one : thm -> thm
    val prove_abs_fn_onto : thm -> thm
    val prove_rec_fn_exists : thm -> term -> thm
    val prove_rep_fn_one_one : thm -> thm
    val prove_rep_fn_onto : thm -> thm
    val quote : string -> string
    val rand : term -> term
    val rator : term -> term
    val record_proof : bool -> unit
    val record_step : (step -> thm) ref
    val reserved_identifiers : {alphanumeric:string list, symbolic:string list}
    val reset : ('a,'b) istream -> ('a,'b) istream
    val reset_thm_count : unit -> unit
    val resume_recording : unit -> unit
    val rev_itlist : ('a -> 'b -> 'b) -> 'a list -> 'b -> 'b
    val rev_itlist2 : ('a -> 'b -> 'c -> 'c) -> 'a list -> 'b list -> 'c -> 'c
    val rhs : term -> term
    val save_hol : string -> unit
    val save_thm : string * thm -> thm
    val say : string -> unit
    val set_autoloads : autoload_info -> unit
    val set_diff : ''a list -> ''a list -> ''a list
    val set_eq : ''a list -> ''a list -> bool
    val set_implicit_rewrites : rewrites -> unit
    val show_assums : bool ref
    val show_dB : bool ref
    val show_restrict : bool ref
    val show_types : bool ref
    val snd : 'a * 'b -> 'b
    val sort : ('a -> 'a -> bool) -> 'a list -> 'a list
    val split : ('a * 'b) list -> 'a list * 'b list
    val split_after : int -> 'a list -> 'a list * 'a list
    val stack_infixes : bool ref
    val state : ('a,'b) istream -> 'b
    val store_definition : string * term -> thm
    val store_thm : string * term * tactic -> thm
    val string_to_int : string -> int
    val string_to_preterm : (int,hol_type) istream -> string -> Preterm.preterm
    val string_to_term : string -> term
    val string_to_type : string -> hol_type
    val string_to_type_spec : string
                              -> {clauses:{args:Parse_support.arg list,
                                           constructor:string} list,
                                  ty_name:string}
    val strings_defined : unit -> bool
    val strip_abs : term -> term list * term
    val strip_comb : term -> term * term list
    val strip_conj : term -> term list
    val strip_disj : term -> term list
    val strip_exists : term -> term list * term
    val strip_forall : term -> term list * term
    val strip_imp : term -> term list * term
    val strip_pair : term -> term list
    val subst : term subst -> term -> term
    val subst_assoc : ('a -> bool) -> 'a subst -> 'a option
    val subst_occs : int list list -> term subst -> term -> term
    val subtract : ''a list -> ''a list -> ''a list
    val suspend_recording : unit -> unit
    val term_lt : term -> term -> bool
    val term_parser : term frag list -> term
    val term_pp_prefix : string ref
    val term_pp_suffix : string ref
    val term_to_string : term -> string
    val theorem : string -> string -> thm
    val theorems : string -> (string * thm) list
    val theories_in_cache : unit -> string list
    val theory_path : string list ref
    val thm_count : unit
                    -> {ABS:int, ASSUME:int, BETA_CONV:int, DISCH:int,
                        INST_TYPE:int, MP:int, REFL:int, SUBST:int, axiom:int,
                        definition:int, drule:int, from_disk:int, other:int,
                        valid_tac:int}
    val thm_free_vars : thm -> term list
    val thm_to_string : thm -> string
    val tilde_symbols : string list ref
    val time : ('a -> 'b) -> 'a -> 'b
    val time_eq : time -> time -> bool
    val time_lt : time -> time -> bool
    val timestamp : unit -> time
    val try : ('a -> 'b) -> 'a -> 'b
    val tryfind : ('a -> 'b) -> 'a list -> 'b
    val ty_antiq : hol_type -> term
    val type_decl : string -> {arity:int, theory:string, tyc:hol_type}
    val type_lt : hol_type -> hol_type -> bool
    val type_of : term -> hol_type
    val type_parser : term frag list -> hol_type
    val type_pp_prefix : string ref
    val type_pp_suffix : string ref
    val type_spec_parser : term frag list
                           -> {clauses:{args:Parse_support.arg list,
                                        constructor:string} list,
                               ty_name:string}
    val type_subst : hol_type subst -> hol_type -> hol_type
    val type_to_string : hol_type -> string
    val type_vars : hol_type -> hol_type list
    val type_vars_in_term : term -> hol_type list
    val type_varsl : hol_type list -> hol_type list
    val types : string -> {Arity:int, Name:string} list
    val uncurry : ('a -> 'b -> 'c) -> 'a * 'b -> 'c
    val union : ''a list -> ''a list -> ''a list
    val unzip : ('a * 'b) list -> 'a list * 'b list
    val use_init_file : bool ref
    val use_string : string -> unit
    val variant : term list -> term -> term
    val version_number : string
    val with_flag : 'a ref -> 'a -> ('c -> 'b) -> 'c -> unit
    val words2 : string -> string -> string list
    val zip : 'a list -> 'b list -> ('a * 'b) list
    val |-> : 'a * 'a -> {redex:'a, residue:'a}
  end
val it = () : unit
[opening 3/rsyntax.sig]
signature Rsyntax_sig =
  sig
    type hol_type
    type term
    type thm
    type fixity
    val INST : term subst -> thm -> thm
    val INST_TYPE : hol_type subst -> thm -> thm
    val INST_TY_TERM : term subst * hol_type subst -> thm -> thm
    val SUBST : {thm:thm, var:term} list -> term -> thm -> thm
    val SUBST_CONV : {thm:thm, var:term} list -> term -> term -> thm
    val define_new_type_bijections : {ABS:string, REP:string, name:string,
                                      tyax:thm}
                                     -> thm
    val dest_abs : term -> {Body:term, Bvar:term}
    val dest_comb : term -> {Rand:term, Rator:term}
    val dest_cond : term -> {cond:term, larm:term, rarm:term}
    val dest_conj : term -> {conj1:term, conj2:term}
    val dest_cons : term -> {hd:term, tl:term}
    val dest_const : term -> {Name:string, Ty:hol_type}
    val dest_disj : term -> {disj1:term, disj2:term}
    val dest_eq : term -> {lhs:term, rhs:term}
    val dest_exists : term -> {Body:term, Bvar:term}
    val dest_forall : term -> {Body:term, Bvar:term}
    val dest_imp : term -> {ant:term, conseq:term}
    val dest_let : term -> {arg:term, func:term}
    val dest_list : term -> {els:term list, ty:hol_type}
    val dest_pabs : term -> {body:term, varstruct:term}
    val dest_pair : term -> {fst:term, snd:term}
    val dest_select : term -> {Body:term, Bvar:term}
    val dest_type : hol_type -> {Args:hol_type list, Tyop:string}
    val dest_var : term -> {Name:string, Ty:hol_type}
    val inst : hol_type subst -> term -> term
    val match_term : term -> term -> term subst * hol_type subst
    val match_type : hol_type -> hol_type -> hol_type subst
    val mk_abs : {Body:term, Bvar:term} -> term
    val mk_comb : {Rand:term, Rator:term} -> term
    val mk_cond : {cond:term, larm:term, rarm:term} -> term
    val mk_conj : {conj1:term, conj2:term} -> term
    val mk_cons : {hd:term, tl:term} -> term
    val mk_const : {Name:string, Ty:hol_type} -> term
    val mk_disj : {disj1:term, disj2:term} -> term
    val mk_eq : {lhs:term, rhs:term} -> term
    val mk_exists : {Body:term, Bvar:term} -> term
    val mk_forall : {Body:term, Bvar:term} -> term
    val mk_imp : {ant:term, conseq:term} -> term
    val mk_let : {arg:term, func:term} -> term
    val mk_list : {els:term list, ty:hol_type} -> term
    val mk_pabs : {body:term, varstruct:term} -> term
    val mk_pair : {fst:term, snd:term} -> term
    val mk_primed_var : {Name:string, Ty:hol_type} -> term
    val mk_select : {Body:term, Bvar:term} -> term
    val mk_type : {Args:hol_type list, Tyop:string} -> hol_type
    val mk_var : {Name:string, Ty:hol_type} -> term
    val new_binder : {Name:string, Ty:hol_type} -> unit
    val new_constant : {Name:string, Ty:hol_type} -> unit
    val new_infix : {Name:string, Prec:int, Ty:hol_type} -> unit
    val new_recursive_definition : {def:term, fixity:fixity, name:string,
                                    rec_axiom:thm}
                                   -> thm
    val new_specification : {consts:{const_name:string, fixity:fixity} list,
                             name:string, sat_thm:thm}
                            -> thm
    val new_type : {Arity:int, Name:string} -> unit
    val new_type_definition : {inhab_thm:thm, name:string, pred:term} -> thm
    val subst : term subst -> term -> term
    val subst_occs : int list list -> term subst -> term -> term
    val type_subst : hol_type subst -> hol_type -> hol_type
  end
val it = () : unit
GC #0.0.2.3.12.497:   (10 ms)
[opening 3/rsyntax.sml]
structure Rsyntax : Rsyntax_sig
val it = () : unit
[opening 3/psyntax.sig]
signature Psyntax_sig =
  sig
    type term
    type thm
    type hol_type
    type fixity
    val INST : (term * term) list -> thm -> thm
    val INST_TYPE : (hol_type * hol_type) list -> thm -> thm
    val INST_TY_TERM : (term * term) list * (hol_type * hol_type) list
                       -> thm -> thm
    val SUBST : (thm * term) list -> term -> thm -> thm
    val SUBST_CONV : (thm * term) list -> term -> term -> thm
    val define_new_type_bijections : string -> string -> string -> thm -> thm
    val dest_abs : term -> term * term
    val dest_comb : term -> term * term
    val dest_cond : term -> term * term * term
    val dest_conj : term -> term * term
    val dest_cons : term -> term * term
    val dest_const : term -> string * hol_type
    val dest_disj : term -> term * term
    val dest_eq : term -> term * term
    val dest_exists : term -> term * term
    val dest_forall : term -> term * term
    val dest_imp : term -> term * term
    val dest_let : term -> term * term
    val dest_list : term -> term list * hol_type
    val dest_pabs : term -> term * term
    val dest_pair : term -> term * term
    val dest_select : term -> term * term
    val dest_type : hol_type -> string * hol_type list
    val dest_var : term -> string * hol_type
    val inst : (hol_type * hol_type) list -> term -> term
    val match_term : term
                     -> term -> (term * term) list * (hol_type * hol_type) list
    val match_type : hol_type -> hol_type -> (hol_type * hol_type) list
    val mk_abs : term * term -> term
    val mk_comb : term * term -> term
    val mk_cond : term * term * term -> term
    val mk_conj : term * term -> term
    val mk_cons : term * term -> term
    val mk_const : string * hol_type -> term
    val mk_disj : term * term -> term
    val mk_eq : term * term -> term
    val mk_exists : term * term -> term
    val mk_forall : term * term -> term
    val mk_imp : term * term -> term
    val mk_let : term * term -> term
    val mk_list : term list * hol_type -> term
    val mk_pabs : term * term -> term
    val mk_pair : term * term -> term
    val mk_primed_var : string * hol_type -> term
    val mk_select : term * term -> term
    val mk_type : string * hol_type list -> hol_type
    val mk_var : string * hol_type -> term
    val new_binder : string * hol_type -> unit
    val new_constant : string * hol_type -> unit
    val new_infix : string * hol_type * int -> unit
    val new_recursive_definition : fixity -> thm -> string -> term -> thm
    val new_specification : string
                            -> (string * string * int) list -> thm -> thm
    val new_type : int -> string -> unit
    val new_type_definition : string * term * thm -> thm
    val subst : (term * term) list -> term -> term
    val subst_occs : int list list -> (term * term) list -> term -> term
    val type_subst : (hol_type * hol_type) list -> hol_type -> hol_type
  end
val it = () : unit
GC #0.0.2.3.13.569:   (20 ms)
GC #0.0.2.3.14.612:   (20 ms)
GC #0.1.3.4.15.629:   (50 ms)
[opening 3/psyntax.sml]
structure Psyntax : Psyntax_sig
val it = () : unit
GC #0.1.3.4.16.698:   (0 ms)
[opening 3/gstack.sig]
signature Goalstack_sig =
  sig
    type term
    type thm
    type tactic
    type goal
    type goalstack
    type proofs
    structure Functional :
      sig
        val set_goal : goal -> goalstack
        val add : goalstack -> proofs -> proofs
        val backup : goalstack -> goalstack
        val set_backup : int -> goalstack -> goalstack
        val restart : goalstack -> goalstack
        val drop : proofs -> proofs
        val expandf : Abbrev.tactic -> goalstack -> goalstack
        val current_goalstack : proofs -> goalstack
        val top_thm : goalstack -> thm
        val initial_goal : goalstack -> goal
        val top_goal : goalstack -> goal
        val top_goals : goalstack -> goal list
        val rotate : int -> goalstack -> goalstack
        val rotate_proofs : int -> proofs -> proofs
      end
    structure Implicit :
      sig
        val set_goal : goal -> proofs
        val g : term SMLofNJ.frag list -> proofs
        val add : goalstack -> proofs
        val backup : unit -> goalstack
        val b : unit -> goalstack
        val set_backup : int -> unit
        val restart : unit -> goalstack
        val drop : unit -> proofs
        val expandf : Abbrev.tactic -> goalstack
        val expand : Abbrev.tactic -> goalstack
        val e : Abbrev.tactic -> goalstack
        val top_thm : unit -> thm
        val initial_goal : unit -> goal
        val top_goal : unit -> goal
        val top_goals : unit -> goal list
        val p : unit -> goalstack
        val status : unit -> proofs
        val rotate : int -> goalstack
        val rotate_proofs : int -> proofs
        val r : int -> goalstack
        val R : int -> proofs
      end
    val set_goal_pp : (?.PrettyPrint.ppstream -> goal -> unit)
                      -> ?.PrettyPrint.ppstream -> goal -> unit
    val std_goal_pp : ?.PrettyPrint.ppstream -> goal -> unit
    val pp_goalstack : ?.PrettyPrint.ppstream -> goalstack -> unit
    val pp_proofs : ?.PrettyPrint.ppstream -> proofs -> unit
  end
val it = () : unit
GC #0.1.3.4.17.766:   (20 ms)
GC #0.1.3.4.18.829:   (30 ms)
GC #0.1.3.4.19.864:   (30 ms)
GC #0.1.3.4.20.879:   (30 ms)
GC #0.1.4.5.21.913:   (50 ms)
GC #0.1.4.5.22.968:   (10 ms)
GC #0.1.4.5.23.1078:   (10 ms)
GC #0.1.4.5.24.1081:   (10 ms)
[opening 3/gstack.sml]
structure Goalstack : Goalstack_sig
GC #0.1.5.6.25.1082:   (10 ms)
val it = () : unit
[opening 3/define_type.sig]
signature Define_type_sig =
  sig
    val dtype : {clauses:{args:Parse_support.arg list, constructor:string,
                          fixity:fixity} list, save_name:string,
                 ty_name:string}
                -> thm
    val define_type : {fixities:fixity list, name:string,
                       type_spec:term SMLofNJ.frag list}
                      -> thm
    val string_define_type : string -> string -> fixity list -> thm
  end
val it = () : unit
GC #0.1.5.6.26.1116:   (0 ms)
GC #0.1.5.6.27.1152:   (20 ms)
GC #0.1.5.7.28.1198:   (50 ms)
GC #0.1.5.7.29.1247:   (30 ms)
GC #0.1.5.8.30.1288:   (100 ms)
GC #0.1.5.8.31.1290:   (30 ms)
GC #0.1.5.8.32.1291:   (20 ms)
GC #0.1.5.8.33.1293:   (0 ms)
GC #0.1.5.8.34.1316:   (10 ms)
GC #0.1.5.8.35.1345:   (20 ms)
GC #0.1.6.9.36.1391:   (40 ms)
GC #0.1.6.9.37.1450:   (10 ms)
GC #0.1.6.9.38.1506:   (30 ms)
GC #0.1.6.9.39.1528:   (20 ms)
[opening 3/define_type.sml]
3/define_type.sml:1203.8-1203.46 Warning: binding not exhaustive
          l1 :: lab :: l2 :: nil = ...
3/define_type.sml:1178.8-1178.50 Warning: binding not exhaustive
          (_,f :: s :: nil) = ...
3/define_type.sml:1128.8-1128.52 Warning: binding not exhaustive
          {Args=lty :: rty :: nil,Tyop=_} = ...
3/define_type.sml:1096.8-1096.45 Warning: binding not exhaustive
          {Args=ty :: nil,Tyop=_} = ...
3/define_type.sml:1087.8-1087.50 Warning: binding not exhaustive
          (_,h :: t :: nil) = ...
3/define_type.sml:1063.8-1063.44 Warning: binding not exhaustive
          (C,test :: a :: b :: nil) = ...
3/define_type.sml:1000.8-1000.56 Warning: binding not exhaustive
          {Args=resty :: nil,Tyop=_} = ...
3/define_type.sml:999.8-999.75 Warning: binding not exhaustive
          (f,rl :: value :: ts :: nil) = ...
3/define_type.sml:979.34-981.70 Warning: match nonexhaustive
          (nil,h :: _) => ...
          (h1 :: t1,h2 :: t2) => ...
  
3/define_type.sml:958.4-966.7 Warning: match nonexhaustive
          (ty,rv,tv,(fl,(pv,(name,rl :: value :: tl :: nil)))) => ...
  
GC #0.1.6.9.40.1593:   (30 ms)
3/define_type.sml:893.8-893.49 Warning: binding not exhaustive
          {Args=ty1 :: ty2 :: nil,Tyop=_} = ...
3/define_type.sml:892.8-892.39 Warning: binding not exhaustive
          (_,c1 :: c2 :: nil) = ...
3/define_type.sml:852.15-852.44 Warning: binding not exhaustive
          (_,h :: t :: nil) = ...
3/define_type.sml:848.8-848.43 Warning: binding not exhaustive
          {Args=ety :: nil,Tyop=_} = ...
3/define_type.sml:825.11-825.52 Warning: binding not exhaustive
          {Args=ty1 :: ty2 :: nil,Tyop=_} = ...
3/define_type.sml:823.23-832.10 Warning: match nonexhaustive
          (v,c :: nil,_) => ...
          (v,c :: cs,ty) => ...
  
3/define_type.sml:794.9-794.50 Warning: binding not exhaustive
          {Args=_ :: outty :: nil,Tyop=_} = ...
3/define_type.sml:792.24-801.8 Warning: match nonexhaustive
          (c :: nil,_,_) => ...
          (c :: cs,v,ty) => ...
  
3/define_type.sml:757.28-759.54 Warning: match nonexhaustive
          (f,(nil,nil,nil,nil)) => ...
          (f,(a :: rst1,b :: rst2,c :: rst3,d :: rst4)) => ...
  
3/define_type.sml:723.8-723.65 Warning: binding not exhaustive
          (vs,(EQ,l :: r :: nil)) = ...
3/define_type.sml:689.25-690.46 Warning: match nonexhaustive
          (0,prefix,suffix) => ...
          (n,prefix,h :: t) => ...
  
3/define_type.sml:655.8-655.44 Warning: binding not exhaustive
          (v :: tl :: nil,imp) = ...
3/define_type.sml:603.8-603.41 Warning: binding not exhaustive
          (f,a1 :: a2 :: a3 :: nil) = ...
3/define_type.sml:598.8-598.65 Warning: binding not exhaustive
          (vs,(EQ,l :: r :: nil)) = ...
3/define_type.sml:588.8-588.37 Warning: binding not exhaustive
          (_,f :: l :: nil) = ...
3/define_type.sml:580.8-580.36 Warning: binding not exhaustive
          (_,h :: t :: nil) = ...
3/define_type.sml:556.8-556.41 Warning: binding not exhaustive
          ty :: nil = ...
3/define_type.sml:539.13-539.28 Warning: binding not exhaustive
          h :: t = ...
3/define_type.sml:438.8-438.69 Warning: binding not exhaustive
          (v :: tl :: nil,{ant=ant,conseq=conseq}) = ...
3/define_type.sml:380.8-380.60 Warning: binding not exhaustive
          (x :: y :: nil,cs) = ...
3/define_type.sml:274.8-274.59 Warning: binding not exhaustive
          (v :: tl :: nil,cs) = ...
3/define_type.sml:234.4-236.35 Warning: match nonexhaustive
          (p,prefix,x :: suffix) => ...
  
GC #0.1.6.10.41.1660:   (90 ms)
3/define_type.sml:125.10-125.51 Warning: binding not exhaustive
          {Args=lty :: rty :: nil,Tyop=_} = ...
3/define_type.sml:123.21-130.9 Warning: match nonexhaustive
          (ty,v :: nil) => ...
          (ty,v :: vs) => ...
  
GC #0.1.6.10.42.1671:   (30 ms)
GC #0.1.6.10.43.1682:   (30 ms)
GC #1.2.7.11.44.1708:   (440 ms)
GC #1.2.7.11.45.1763:   (30 ms)
GC #1.2.7.11.46.1791:   (30 ms)
GC #1.2.7.11.47.1808:   (30 ms)
GC #1.2.7.11.48.1828:   (20 ms)
GC #1.2.7.12.49.1854:   (80 ms)
GC #1.2.7.12.50.1860:   (30 ms)
GC #1.2.7.12.51.1863:   (30 ms)
GC #1.3.8.13.52.1865:   (160 ms)
GC #1.4.9.14.53.1875:   (130 ms)
GC #1.5.10.15.54.1883:   (90 ms)
GC #1.6.11.16.55.1893:   (90 ms)
GC #1.7.12.17.56.1906:   (100 ms)
GC #1.8.13.18.57.1935:   (70 ms)
GC #1.9.14.19.58.1945:   (20 ms)
GC #1.9.14.20.59.1959:   (20 ms)
GC #1.9.14.21.60.1968:   (50 ms)
GC #1.9.15.22.61.1984:   (60 ms)
GC #1.9.15.23.62.2008:   (60 ms)
GC #1.9.15.24.63.2032:   (50 ms)
GC #1.9.15.25.64.2053:   (30 ms)
GC #1.9.15.25.65.2095:   (30 ms)
GC #1.9.15.26.66.2135:   (30 ms)
GC #1.9.15.26.67.2174:   (10 ms)
GC #1.9.15.27.68.2216:   (60 ms)
GC #1.10.16.28.69.2254:   (100 ms)
GC #1.11.17.29.70.2263:   (90 ms)
GC #1.12.18.30.71.2264:   (80 ms)
GC #1.13.19.31.72.2295:   (80 ms)
GC #1.13.19.32.73.2335:   (10 ms)
GC #1.14.20.33.74.2340:   (70 ms)
GC #1.14.20.33.75.2363:   (10 ms)
GC #1.15.21.34.76.2413:   (40 ms)
GC #1.15.21.34.77.2423:   (20 ms)
GC #1.16.22.35.78.2448:   (50 ms)
GC #1.17.23.36.79.2472:   (40 ms)
GC #1.18.24.37.80.2524:   (50 ms)
GC #1.19.25.38.81.2591:   (40 ms)
GC #1.20.26.39.82.2618:   (30 ms)
GC #1.21.27.40.83.2657:   (40 ms)
GC #1.22.28.41.84.2705:   (40 ms)
GC #1.23.29.42.85.2779:   (40 ms)
GC #1.24.30.43.86.2866:   (40 ms)
GC #1.25.31.44.87.2951:   (30 ms)
GC #1.26.32.45.88.3021:   (60 ms)
GC #1.27.33.46.89.3053:   (50 ms)
GC #1.28.34.47.90.3082:   (60 ms)
GC #1.29.35.48.91.3088:   (80 ms)
GC #1.30.36.49.92.3098:   (80 ms)
GC #1.31.37.50.93.3102:   (70 ms)
GC #1.32.38.51.94.3168:   (70 ms)
GC #1.32.38.51.95.3175:   (10 ms)
GC #1.33.39.52.96.3246:   (70 ms)
GC #1.34.40.53.97.3307:   (70 ms)
GC #1.35.41.54.98.3344:   (60 ms)
GC #1.36.42.55.99.3391:   (40 ms)
GC #1.37.43.56.100.3424:   (60 ms)
GC #1.38.44.57.101.3445:   (60 ms)
GC #1.39.45.58.102.3446:   (40 ms)
GC #2.40.46.59.103.3448:   (450 ms)
GC #2.40.47.60.104.3451:   (30 ms)
GC #2.41.48.61.105.3461:   (30 ms)
GC #2.41.48.61.106.3462:   (0 ms)
GC #2.41.48.61.107.3475:   (0 ms)
GC #2.41.48.61.108.3515:   (10 ms)
GC #2.41.48.61.109.3548:   (0 ms)
structure Define_type : Define_type_sig
val it = () : unit
[opening 3/sys_lib.sig]
signature Sys_lib_sig =
  sig
    val hol_lib : Library.lib
    type lib
    val lite_lib : lib
    val ho_match_lib : lib
    val refute_lib : lib
    val fol_lib : lib
    val tab_lib : lib
    val meson_lib : lib
    val decision_lib : lib
    val reduce_lib : lib
    val arith_lib : lib
    val simp_lib : lib
    val ind_def_new_lib : lib
    val tfl_lib : lib
    val string_lib : lib
    val option_lib : lib
    val num_lib : lib
    val set_lib : lib
    val pred_set_lib : lib
    val unwind_lib : lib
    val hol88_lib : lib
    val ind_def_lib : lib
    val taut_lib : lib
    val utils_lib : lib
    val retrieve_lib : lib
    val group_lib : lib
    val integer_lib : lib
    val abs_theory_lib : lib
    val unity_lib : lib
    val prog_logic_lib : lib
    val pair_lib : lib
    val real_lib : lib
    val wellorder_lib : lib
    val window_lib : lib
    val list_lib : lib
    val res_quan_lib : lib
    val word_lib : lib
    val mutrec_lib : lib
    val nested_rec_lib : lib
  end
val it = () : unit
GC #2.41.48.61.110.3604:   (10 ms)
GC #2.41.48.62.111.3654:   (30 ms)
GC #2.41.48.62.112.3694:   (20 ms)
GC #2.42.49.63.113.3720:   (60 ms)
GC #2.42.49.63.114.3738:   (0 ms)
GC #2.43.50.64.115.3784:   (20 ms)
GC #2.43.50.65.116.3832:   (10 ms)
GC #2.43.50.65.117.3835:   (0 ms)
[opening 3/sys_lib.sml]

The library "HOL" has been declared and exported.

The library "lite" has been declared and exported.

The library "ho_match" has been declared and exported.

The library "refute" has been declared and exported.

The library "fol" has been declared and exported.

The library "tab" has been declared and exported.

The library "decision" has been declared and exported.

The library "reduce" has been declared and exported.

The library "arith" has been declared and exported.

The library "simp" has been declared and exported.

The library "ind_def_new" has been declared and exported.

The library "tfl" has been declared and exported.

The library "string" has been declared and exported.

The library "option" has been declared and exported.

The library "num" has been declared and exported.

The library "set" has been declared and exported.

The library "pred_set" has been declared and exported.

The library "unwind" has been declared and exported.

The library "hol88" has been declared and exported.

The library "ind_def" has been declared and exported.

The library "taut" has been declared and exported.

The library "meson" has been declared and exported.

The library "automate" has been declared and exported.

The library "utils" has been declared and exported.

The library "retrieve" has been declared and exported.

The library "group" has been declared and exported.

The library "integer" has been declared and exported.

The library "abs_theory" has been declared and exported.

The library "unity" has been declared and exported.

The library "prog_logic" has been declared and exported.

The library "pair" has been declared and exported.

The library "real" has been declared and exported.

The library "wellorder" has been declared and exported.

The library "window" has been declared and exported.

The library "list" has been declared and exported.

The library "res_quan" has been declared and exported.

The library "word" has been declared and exported.

The library "mutrec" has been declared and exported.

The library "nested_rec" has been declared and exported.
structure Sys_lib : Sys_lib_sig
val it = () : unit
val it = () : unit
[opening /usr/groups/hol/hol90.10/src/3/hol3.sml]
val it = () : unit
val it = () : unit
GC #2.43.50.65.118.3865:   (10 ms)
opening Goalstack
  type term = ?.CoreHol.PrivateTerm.term
  type thm = Thm.thm
  type tactic = Abbrev.tactic
  type goal = Abbrev.goal
  datatype goalstack = ...
  datatype proofs = ...
  structure Functional :
    sig
      val set_goal : goal -> goalstack
      val add : goalstack -> proofs -> proofs
      val backup : goalstack -> goalstack
      val set_backup : int -> goalstack -> goalstack
      val restart : goalstack -> goalstack
      val drop : proofs -> proofs
      val expandf : Abbrev.tactic -> goalstack -> goalstack
      val current_goalstack : proofs -> goalstack
      val top_thm : goalstack -> thm
      val initial_goal : goalstack -> goal
      val top_goal : goalstack -> goal
      val top_goals : goalstack -> goal list
      val rotate : int -> goalstack -> goalstack
      val rotate_proofs : int -> proofs -> proofs
    end
  structure Implicit :
    sig
      val set_goal : goal -> proofs
      val g : term SMLofNJ.frag list -> proofs
      val add : goalstack -> proofs
      val backup : unit -> goalstack
      val b : unit -> goalstack
      val set_backup : int -> unit
      val restart : unit -> goalstack
      val drop : unit -> proofs
      val expandf : Abbrev.tactic -> goalstack
      val expand : Abbrev.tactic -> goalstack
      val e : Abbrev.tactic -> goalstack
      val top_thm : unit -> thm
      val initial_goal : unit -> goal
      val top_goal : unit -> goal
      val top_goals : unit -> goal list
      val p : unit -> goalstack
      val status : unit -> proofs
      val rotate : int -> goalstack
      val rotate_proofs : int -> proofs
      val r : int -> goalstack
      val R : int -> proofs
    end
  val set_goal_pp : (?.PrettyPrint.ppstream -> goal -> unit)
                    -> ?.PrettyPrint.ppstream -> goal -> unit
  val std_goal_pp : ?.PrettyPrint.ppstream -> goal -> unit
  val pp_goalstack : ?.PrettyPrint.ppstream -> goalstack -> unit
  val pp_proofs : ?.PrettyPrint.ppstream -> proofs -> unit
opening Implicit
  val set_goal : goal -> proofs
  val g : term SMLofNJ.frag list -> proofs
  val add : goalstack -> proofs
  val backup : unit -> goalstack
  val b : unit -> goalstack
  val set_backup : int -> unit
  val restart : unit -> goalstack
  val drop : unit -> proofs
  val expandf : tactic -> goalstack
  val expand : tactic -> goalstack
  val e : tactic -> goalstack
  val top_thm : unit -> thm
  val initial_goal : unit -> goal
  val top_goal : unit -> goal
  val top_goals : unit -> goal list
  val p : unit -> goalstack
  val status : unit -> proofs
  val rotate : int -> goalstack
  val rotate_proofs : int -> proofs
  val r : int -> goalstack
  val R : int -> proofs
opening Define_type
  val dtype : {clauses:{args:Parse_support.arg list, constructor:string,
                        fixity:fixity} list, save_name:string, ty_name:string}
              -> thm
  val define_type : {fixities:fixity list, name:string,
                     type_spec:term SMLofNJ.frag list}
                    -> thm
  val string_define_type : string -> string -> fixity list -> thm
GC #2.43.50.65.119.3887:   (0 ms)
opening Sys_lib
  val hol_lib : Library.lib
  type lib
  val lite_lib : lib
  val ho_match_lib : lib
  val refute_lib : lib
  val fol_lib : lib
  val tab_lib : lib
  val meson_lib : lib
  val decision_lib : lib
  val reduce_lib : lib
  val arith_lib : lib
  val simp_lib : lib
  val ind_def_new_lib : lib
  val tfl_lib : lib
  val string_lib : lib
  val option_lib : lib
  val num_lib : lib
  val set_lib : lib
  val pred_set_lib : lib
  val unwind_lib : lib
  val hol88_lib : lib
  val ind_def_lib : lib
  val taut_lib : lib
  val utils_lib : lib
  val retrieve_lib : lib
  val group_lib : lib
  val integer_lib : lib
  val abs_theory_lib : lib
  val unity_lib : lib
  val prog_logic_lib : lib
  val pair_lib : lib
  val real_lib : lib
  val wellorder_lib : lib
  val window_lib : lib
  val list_lib : lib
  val res_quan_lib : lib
  val word_lib : lib
  val mutrec_lib : lib
  val nested_rec_lib : lib
opening Rsyntax
  type hol_type = Type.hol_type
  type term = ?.CoreHol.PrivateTerm.term
  type thm = Thm.thm
  type fixity = ?.CoreHol.PrivateTerm.fixity
  val INST : term subst -> thm -> thm
  val INST_TYPE : hol_type subst -> thm -> thm
  val INST_TY_TERM : term subst * hol_type subst -> thm -> thm
  val SUBST : {thm:thm, var:term} list -> term -> thm -> thm
  val SUBST_CONV : {thm:thm, var:term} list -> term -> term -> thm
  val define_new_type_bijections : {ABS:string, REP:string, name:string,
                                    tyax:thm}
                                   -> thm
  val dest_abs : term -> {Body:term, Bvar:term}
  val dest_comb : term -> {Rand:term, Rator:term}
  val dest_cond : term -> {cond:term, larm:term, rarm:term}
  val dest_conj : term -> {conj1:term, conj2:term}
  val dest_cons : term -> {hd:term, tl:term}
  val dest_const : term -> {Name:string, Ty:hol_type}
  val dest_disj : term -> {disj1:term, disj2:term}
  val dest_eq : term -> {lhs:term, rhs:term}
  val dest_exists : term -> {Body:term, Bvar:term}
  val dest_forall : term -> {Body:term, Bvar:term}
  val dest_imp : term -> {ant:term, conseq:term}
  val dest_let : term -> {arg:term, func:term}
  val dest_list : term -> {els:term list, ty:hol_type}
  val dest_pabs : term -> {body:term, varstruct:term}
  val dest_pair : term -> {fst:term, snd:term}
  val dest_select : term -> {Body:term, Bvar:term}
  val dest_type : hol_type -> {Args:hol_type list, Tyop:string}
  val dest_var : term -> {Name:string, Ty:hol_type}
  val inst : hol_type subst -> term -> term
  val match_term : term -> term -> term subst * hol_type subst
  val match_type : hol_type -> hol_type -> hol_type subst
  val mk_abs : {Body:term, Bvar:term} -> term
  val mk_comb : {Rand:term, Rator:term} -> term
  val mk_cond : {cond:term, larm:term, rarm:term} -> term
  val mk_conj : {conj1:term, conj2:term} -> term
  val mk_cons : {hd:term, tl:term} -> term
  val mk_const : {Name:string, Ty:hol_type} -> term
  val mk_disj : {disj1:term, disj2:term} -> term
  val mk_eq : {lhs:term, rhs:term} -> term
  val mk_exists : {Body:term, Bvar:term} -> term
  val mk_forall : {Body:term, Bvar:term} -> term
  val mk_imp : {ant:term, conseq:term} -> term
  val mk_let : {arg:term, func:term} -> term
  val mk_list : {els:term list, ty:hol_type} -> term
  val mk_pabs : {body:term, varstruct:term} -> term
  val mk_pair : {fst:term, snd:term} -> term
  val mk_primed_var : {Name:string, Ty:hol_type} -> term
  val mk_select : {Body:term, Bvar:term} -> term
  val mk_type : {Args:hol_type list, Tyop:string} -> hol_type
  val mk_var : {Name:string, Ty:hol_type} -> term
  val new_binder : {Name:string, Ty:hol_type} -> unit
  val new_constant : {Name:string, Ty:hol_type} -> unit
  val new_infix : {Name:string, Prec:int, Ty:hol_type} -> unit
  val new_recursive_definition : {def:term, fixity:fixity, name:string,
                                  rec_axiom:thm}
                                 -> thm
  val new_specification : {consts:{const_name:string, fixity:fixity} list,
                           name:string, sat_thm:thm}
                          -> thm
  val new_type : {Arity:int, Name:string} -> unit
  val new_type_definition : {inhab_thm:thm, name:string, pred:term} -> thm
  val subst : term subst -> term -> term
  val subst_occs : int list list -> term subst -> term -> term
  val type_subst : hol_type subst -> hol_type -> hol_type
hol90 root directory now regarded as "/Nfs/bescot/grp11/hol/hol90.10/".
val it = () : unit
datatype 'a frag = ANTIQUOTE of 'a | QUOTE of string
signature EMPTY = sig end
signature EMPTY = sig end
signature EMPTY = sig end
signature EMPTY = sig end
signature EMPTY = sig end
signature EMPTY = sig end
val it = () : unit
val it = [] : unit list
val it = () : unit
val it = () : unit
GC #2.43.50.65.120.3942:   (0 ms)
GC #3.44.51.66.121.3944:   (340 ms)
write 1,0: 56 bytes [0x403c0000..0x403c0038) @ 0x2000
write 1,1: 16 bytes [0x40410008..0x40410018) @ 0x3000
write 1,2: 36 bytes [0x40460000..0x40460024) @ 0x4000
write 1,3: 0 bytes [0x404b0000..0x404b0000) @ 0x5000
write 2,0: 36988 bytes [0x41990000..0x4199907c) @ 0x5000
write 2,1: 37696 bytes [0x419a0008..0x419a9348) @ 0xf000
write 2,2: 7104 bytes [0x419c0000..0x419c1bc0) @ 0x19000
write 2,3: 5780 bytes [0x419d0000..0x419d1694) @ 0x1b000
write 2,0: 2 big objects (40 pages) @ 0x1d000
write 3,0: 0 bytes [0x40200000..0x40200000) @ 0x27020
write 3,1: 560 bytes [0x40210008..0x40210238) @ 0x27020
write 3,2: 0 bytes [0x40220000..0x40220000) @ 0x28020
write 3,3: 288 bytes [0x40230000..0x40230120) @ 0x28020
write 4,0: 80 bytes [0x40250000..0x40250050) @ 0x29020
write 4,1: 1192 bytes [0x40260008..0x402604b0) @ 0x2a020
write 4,2: 24 bytes [0x40280000..0x40280018) @ 0x2b020
write 4,3: 504 bytes [0x40290000..0x402901f8) @ 0x2c020
write 5,0: 900756 bytes [0x41f20000..0x41ffbe94) @ 0x2d020
write 5,1: 2078352 bytes [0x421d0008..0x423cb698) @ 0x109020
write 5,2: 434532 bytes [0x42750000..0x427ba164) @ 0x305020
write 5,3: 192884 bytes [0x42880000..0x428af174) @ 0x370020
write 5,0: 416 big objects (8927 pages) @ 0x3a0020


          HHH                 LL
          HHH                  LL
          HHH                   LL
          HHH                    LL
          HHH          OOOO       LL
          HHHHHHH     OO  OO       LL
          HHHHHHH     OO  OO       LLL
          HHH          OOOO        LLLL
          HHH                     LL  LL
          HHH                    LL    LL
          HHH                   LL      LL
          HHH                  LL        LL90.10

Created on Tue Nov 16 11:25:09 GMT 1999
using: Standard ML of New Jersey, Version 110.0.3, January 30, 1998


val it = () : unit
- 