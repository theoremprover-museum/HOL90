Standard ML of New Jersey, Version 0.93, February 15, 1993
val it = () : unit
- val length = fn : 'a list -> int
val it = () : unit
val it = () : unit
val it = () : unit
val it = () : unit
val it = () : unit
[opening 0/sys_params.sig]
signature Sys_params_sig =
  sig
    datatype thy_opt
      con make_binary : thy_opt
      con make_new_ascii : thy_opt
      con use_old_ascii : thy_opt
    val theory_file_option : thy_opt
    val HOL_base_directory : string
  end
val it = () : unit
[opening 0/sys_params.sml]
functor SYS_PARAMS : <sig>
val it = () : unit
structure Sys_params : Sys_params_sig
[opening 0/globals.sig]
signature Globals_sig =
  sig
    val version_number : int
    val neg_defined : unit -> bool
    val nums_defined : unit -> bool
    val strings_defined : unit -> bool
    val assert_neg_defined : unit -> unit
    val assert_nums_defined : unit -> unit
    val assert_strings_defined : unit -> unit
    val in_type_spec : string option ref
    val print_exceptions : bool ref
    val show_assums : bool ref
    val allow_theorems_with_assumptions : bool ref
    val use_init_file : bool ref
    val max_print_depth : int ref
    val type_pp_prefix : string ref
    val type_pp_suffix : string ref
    val term_pp_prefix : string ref
    val term_pp_suffix : string ref
    val linewidth : int ref
    val interp : bool ref
    val arch : string
    val theory_file_type : string
    val remake_theory_files : bool
    val paths : {HOLdir:string ref, help_path:string list ref,
                 library_path:string list ref, theory_path:string list ref}
    val HOLdir : string ref
    val theory_path : string list ref
    val library_path : string list ref
    val help_path : string list ref
    val output_HOL_ERR : ({message:string, origin_function:string,
                           origin_structure:string}
                          -> unit) ref
    val output_help : string ref
    val tilde_symbols : string list ref
    val pp_flags : {infix_at_front:bool ref, show_dB:bool ref,
                    show_restrict:bool ref, show_types:bool ref,
                    stack_infixes:bool ref}
    val show_restrict : bool ref
    val show_types : bool ref
    val show_dB : bool ref
    val reserved_identifiers : {alphanumeric:string list, symbolic:string list}
    val goal_line : string ref
  end
val it = () : unit

[Major collection...
[Increasing heap to 2760k]

[Increasing heap to 2880k]
 28% used (654768/2268584), 140 msec]

[Increasing heap to 3372k]
[opening 0/globals.sml]
functor GLOBALS : <sig>
val it = () : unit
structure Globals : Globals_sig
[opening 0/exception.sig]
signature Exception_sig =
  sig
    exception HOL_ERR of {message:string, origin_function:string,
                          origin_structure:string}
    val print_HOL_ERR : exn -> unit
    val Raise : exn -> 'a
  end
val it = () : unit
[opening 0/exception.sml]
functor EXCEPTION : <sig>
val it = () : unit
structure Exception : Exception_sig
open Exception
exception HOL_ERR = HOL_ERR
val print_HOL_ERR = fn : exn -> unit
val Raise = fn : exn -> 'a
val use = fn : string -> unit
[opening 0/lib.sig]
signature Lib_sig =
  sig
    val curry : ('a * 'b -> 'c) -> 'a -> 'b -> 'c
    val uncurry : ('a -> 'b -> 'c) -> 'a * 'b -> 'c
    val append : 'a list -> 'a list -> 'a list
    val concat : string -> string -> string
    val equal : ''a -> ''a -> bool
    val ## : ('a -> 'c) * ('b -> 'd) -> 'a * 'b -> 'c * 'd
    val A : ('a -> 'b) -> 'a -> 'b
    val B : ('a -> 'c) -> ('b -> 'a) -> 'b -> 'c
    val C : ('b -> 'a -> 'c) -> 'a -> 'b -> 'c
    val I : 'a -> 'a
    val K : 'b -> 'a -> 'b
    val S : ('b -> 'a -> 'c) -> ('b -> 'a) -> 'b -> 'c
    val fst : 'b * 'a -> 'b
    val snd : 'a * 'b -> 'b
    val can : ('b -> 'a) -> 'b -> bool
    val assert : ('a -> bool) -> 'a -> 'a
    val tryfind : ('a -> 'b) -> 'a list -> 'b
    val el : int -> 'a list -> 'a
    val map2 : ('a -> 'b -> 'c) -> 'a list -> 'b list -> 'c list
    val all : ('a -> bool) -> 'a list -> bool
    val all2 : ('a -> 'b -> bool) -> 'a list -> 'b list -> bool
    val first : ('a -> bool) -> 'a list -> 'a
    val split_after : int -> 'a list -> 'a list * 'a list
    val partition : ('a -> bool) -> 'a list -> 'a list * 'a list
    val gather : ('a -> bool) -> 'a list -> 'a list
    val filter : ('a -> bool) -> 'a list -> 'a list
    val itlist : ('a -> 'b -> 'b) -> 'a list -> 'b -> 'b
    val itlist2 : ('a -> 'b -> 'c -> 'c) -> 'a list -> 'b list -> 'c -> 'c
    val rev_itlist : ('a -> 'b -> 'b) -> 'a list -> 'b -> 'b
    val rev_itlist2 : ('a -> 'b -> 'c -> 'c) -> 'a list -> 'b list -> 'c -> 'c
    val end_itlist : ('a -> 'a -> 'a) -> 'a list -> 'a
    val zip : 'a list -> 'b list -> ('a * 'b) list
    val combine : 'a list * 'b list -> ('a * 'b) list
    val unzip : ('a * 'b) list -> 'a list * 'b list
    val split : ('a * 'b) list -> 'a list * 'b list
    val mapfilter : ('a -> 'b) -> 'a list -> 'b list
    val flatten : 'a list list -> 'a list
    exception NOT_FOUND
    exception NO_CHANGE
    val assoc : ''a -> (''a * 'b) list -> 'b
    val assoc1 : ''a -> (''a * 'b) list -> (''a * 'b) option
    val assoc2 : ''b -> ('a * ''b) list -> ('a * ''b) option
    type 'a subst
    val subst_assoc : ('a -> bool) -> 'a subst -> 'a option
    val |-> : 'a * 'a -> {redex:'a, residue:'a}
    val mem : ''a -> ''a list -> bool
    val mk_set : ''a list -> ''a list
    val union : ''a list -> ''a list -> ''a list
    val U : ''a list list -> ''a list
    val set_diff : ''a list -> ''a list -> ''a list
    val subtract : ''a list -> ''a list -> ''a list
    val intersect : ''a list -> ''a list -> ''a list
    val null_intersection : ''a list -> ''a list -> bool
    val set_eq : ''a list -> ''a list -> bool
    val op_mem : ('a -> 'b -> bool) -> 'a -> 'b list -> bool
    val op_union : ('a -> 'a -> bool) -> 'a list -> 'a list -> 'a list
    val op_U : ('a -> 'a -> bool) -> 'a list list -> 'a list
    val op_intersect : ('a -> 'a -> bool) -> 'a list -> 'a list -> 'a list
    val for : int -> int -> (int -> 'a) -> 'a list
    val for_se : int -> int -> (int -> 'a) -> unit
    val list_of_array : 'a array -> 'a list
    val int_to_string : int -> string
    val string_to_int : string -> int
    val sort : ('a -> 'a -> bool) -> 'a list -> 'a list
    val int_sort : int list -> int list
    val clean_directory : string -> unit
    val file_exists_for_reading : string -> bool
    val find_path : string list -> string -> string
    val cons_path : string -> string list ref -> unit
    val append_path : string -> string list ref -> unit
    type time
    val timestamp : unit -> time
    val time_eq : time -> time -> bool
    val time_lt : time -> time -> bool
    val exit : unit -> 'a
    val compile : string -> unit
    val interpret : string -> unit
    val fresh_name : string -> unit -> string
    val use_string : string -> unit
    val say : string -> unit
    val quote : string -> string
    val eval_string : string -> unit
    val cd : string -> unit
    val pwd : unit -> string
    val ls : unit -> int
    val words2 : string -> string -> string list
    val front_n_back : 'a list -> 'a list * 'a
    val funpow : int -> ('a -> 'a) -> 'a -> 'a
  end
val it = () : unit

[Major collection...
[Increasing heap to 3436k]

[Increasing heap to 3756k]

[Increasing heap to 5356k]
 39% used (1088668/2771548), 280 msec]

[Increasing heap to 5440k]
[opening 0/lib.sml]
0/lib.sml:577.12-577.37 Warning: binding not exhaustive
          last :: rfront = ...
0/lib.sml:139.17-139.46 Warning: binding not exhaustive
          base :: ralist = ...
0/lib.sml:77.27-80.76 Warning: match nonexhaustive
          (nil,nil) => ...
          (a1 :: rst1,a2 :: rst2) => ...
          (_,nil) => ...
  

[Major collection...
[Increasing heap to 5736k]
 29% used (1312384/4479364), 340 msec]

[Increasing heap to 6836k]

[Major collection...
[Increasing heap to 7048k]

[Increasing heap to 8108k]
 30% used (1702780/5597836), 420 msec]

[Increasing heap to 8672k]
functor LIB : <sig>
val it = () : unit
structure Lib : Lib_sig
open Lib
val curry = fn : ('a * 'b -> 'c) -> 'a -> 'b -> 'c
val uncurry = fn : ('a -> 'b -> 'c) -> 'a * 'b -> 'c
val append = fn : 'a list -> 'a list -> 'a list
val concat = fn : string -> string -> string
val equal = fn : ''a -> ''a -> bool
val ## = fn : ('a -> 'b) * ('c -> 'd) -> 'a * 'c -> 'b * 'd
val A = fn : ('a -> 'b) -> 'a -> 'b
val B = fn : ('a -> 'b) -> ('c -> 'a) -> 'c -> 'b
val C = fn : ('a -> 'b -> 'c) -> 'b -> 'a -> 'c
val I = fn : 'a -> 'a
val K = fn : 'a -> 'b -> 'a
val S = fn : ('a -> 'b -> 'c) -> ('a -> 'b) -> 'a -> 'c
val fst = fn : 'a * 'b -> 'a
val snd = fn : 'a * 'b -> 'b
val can = fn : ('a -> 'b) -> 'a -> bool
val assert = fn : ('a -> bool) -> 'a -> 'a
val tryfind = fn : ('a -> 'b) -> 'a list -> 'b
val el = fn : int -> 'a list -> 'a
val map2 = fn : ('a -> 'b -> 'c) -> 'a list -> 'b list -> 'c list
val all = fn : ('a -> bool) -> 'a list -> bool
val all2 = fn : ('a -> 'b -> bool) -> 'a list -> 'b list -> bool
val first = fn : ('a -> bool) -> 'a list -> 'a
val split_after = fn : int -> 'a list -> 'a list * 'a list
val partition = fn : ('a -> bool) -> 'a list -> 'a list * 'a list
val gather = fn : ('a -> bool) -> 'a list -> 'a list
val filter = fn : ('a -> bool) -> 'a list -> 'a list
val itlist = fn : ('a -> 'b -> 'b) -> 'a list -> 'b -> 'b
val itlist2 = fn : ('a -> 'b -> 'c -> 'c) -> 'a list -> 'b list -> 'c -> 'c
val rev_itlist = fn : ('a -> 'b -> 'b) -> 'a list -> 'b -> 'b
val rev_itlist2 = fn : ('a -> 'b -> 'c -> 'c) -> 'a list -> 'b list -> 'c -> 'c
val end_itlist = fn : ('a -> 'a -> 'a) -> 'a list -> 'a
val zip = fn : 'a list -> 'b list -> ('a * 'b) list
val combine = fn : 'a list * 'b list -> ('a * 'b) list
val unzip = fn : ('a * 'b) list -> 'a list * 'b list
val split = fn : ('a * 'b) list -> 'a list * 'b list
val mapfilter = fn : ('a -> 'b) -> 'a list -> 'b list
val flatten = fn : 'a list list -> 'a list
exception NOT_FOUND = NOT_FOUND
exception NO_CHANGE = NO_CHANGE
val assoc = fn : ''a -> (''a * 'b) list -> 'b
val assoc1 = fn : ''a -> (''a * 'b) list -> (''a * 'b) option
val assoc2 = fn : ''a -> ('b * ''a) list -> ('b * ''a) option
val subst_assoc = fn : ('a -> bool) -> 'a subst -> 'a option
val |-> = fn : 'a * 'a -> {redex:'a, residue:'a}
val mem = fn : ''a -> ''a list -> bool
val mk_set = fn : ''a list -> ''a list
val union = fn : ''a list -> ''a list -> ''a list
val U = fn : ''a list list -> ''a list
val set_diff = fn : ''a list -> ''a list -> ''a list
val subtract = fn : ''a list -> ''a list -> ''a list
val intersect = fn : ''a list -> ''a list -> ''a list
val null_intersection = fn : ''a list -> ''a list -> bool
val set_eq = fn : ''a list -> ''a list -> bool
val op_mem = fn : ('a -> 'b -> bool) -> 'a -> 'b list -> bool
val op_union = fn : ('a -> 'a -> bool) -> 'a list -> 'a list -> 'a list
val op_U = fn : ('a -> 'a -> bool) -> 'a list list -> 'a list
val op_intersect = fn : ('a -> 'a -> bool) -> 'a list -> 'a list -> 'a list
val for = fn : int -> int -> (int -> 'a) -> 'a list
val for_se = fn : int -> int -> (int -> 'a) -> unit
val list_of_array = fn : 'a array -> 'a list
val int_to_string = fn : int -> string
val string_to_int = fn : string -> int
val sort = fn : ('a -> 'a -> bool) -> 'a list -> 'a list
val int_sort = fn : int list -> int list
val clean_directory = fn : string -> unit
val file_exists_for_reading = fn : string -> bool
val find_path = fn : string list -> string -> string
val cons_path = fn : string -> string list ref -> unit
val append_path = fn : string -> string list ref -> unit
val timestamp = fn : unit -> time
val time_eq = fn : time -> time -> bool
val time_lt = fn : time -> time -> bool
val exit = fn : unit -> 'a
val compile = fn : string -> unit
val interpret = fn : string -> unit
val fresh_name = fn : string -> unit -> string
val use_string = fn : string -> unit
val say = fn : string -> unit
val quote = fn : string -> string
val eval_string = fn : string -> unit
val cd = fn : string -> unit
val pwd = fn : unit -> string
val ls = fn : unit -> int
val words2 = fn : string -> string -> string list
val front_n_back = fn : 'a list -> 'a list * 'a
val funpow = fn : int -> ('a -> 'a) -> 'a -> 'a
infix 3 ##
infix 5 |->
[opening 0/uid.sig]
signature Uid_sig =
  sig
    type uid
    val mk_uid : string -> uid
    val re_mk_uid : {name:string, timestamp:time} -> uid
    val dest_uid : uid -> {name:string, timestamp:time}
    val name : uid -> string
    val timestamp : uid -> time
    val eq : uid * uid -> bool
  end
val it = () : unit
[opening 0/uid.sml]
functor UID : <sig>
val it = () : unit
[opening 0/file.sig]
signature File_sig =
  sig
    val get_file_by_name : {reader:instream -> 'a, suffix:string}
                           -> string list -> string -> {data:'a, path:string}
    val get_file_by_key : {eq:'a * 'a -> bool, key_of:'b -> 'a,
                           name_of:'a -> string, reader:instream -> 'b,
                           suffix:string}
                          -> string list -> 'a -> {data:'b, path:string}
  end
val it = () : unit
[opening 0/file.sml]
functor FILE : <sig>
val it = () : unit
structure File : File_sig
[opening 0/help.sig]
signature Help_sig =
  sig
    val helper : string list -> string -> unit
    val help : string -> unit
    val help1 : string -> unit
  end
val it = () : unit
[opening 0/help.sml]
functor HELP : <sig>
val it = () : unit
structure Help : Help_sig
open Help
val helper = fn : string list -> string -> unit
val help = fn : string -> unit
val help1 = fn : string -> unit
[opening 0/save_hol.sig]
signature Save_hol_sig =
  sig
    val print_banner : string -> unit
    val save_hol : string -> unit
  end
val it = () : unit
[opening 0/save_hol.sml]
functor SAVE_HOL : <sig>
val it = () : unit
[opening 0/pp.sig]
signature PP_sig =
  sig
    type ppstream
    type ppconsumer
    datatype break_style
      con CONSISTENT : break_style
      con INCONSISTENT : break_style
    val mk_consumer : {consumer:string -> unit, flush:unit -> unit,
                       linewidth:int}
                      -> ppconsumer
    val defaultConsumer : unit
                          -> {consumer:string -> unit, flush:unit -> unit,
                              linewidth:int}
    val mk_ppstream : ppconsumer -> ppstream
    val dest_ppstream : ppstream -> ppconsumer
    val add_break : ppstream -> int * int -> unit
    val add_newline : ppstream -> unit
    val add_string : ppstream -> string -> unit
    val begin_block : ppstream -> break_style -> int -> unit
    val end_block : ppstream -> unit
    val clear_ppstream : ppstream -> unit
    val flush_ppstream : ppstream -> unit
    val with_pp : ppconsumer -> (ppstream -> unit) -> unit
    val install_pp : string list -> (ppstream -> 'a -> unit) -> unit
    val pp_to_string : int -> (ppstream -> 'a -> unit) -> 'a -> string
    val with_ppstream : ppstream
                        -> {add_break:int * int -> unit,
                            add_newline:unit -> unit,
                            add_string:string -> unit,
                            begin_block:break_style -> int -> unit,
                            clear_ppstream:unit -> unit,
                            end_block:unit -> unit,
                            flush_ppstream:unit -> unit}
    val pr_list : ('c -> unit)
                  -> (unit -> 'a) -> (unit -> 'b) -> 'c list -> unit
  end
val it = () : unit
[opening 0/pp.sml]
structure PP : PP_sig
val it = () : unit
[opening 0/lexis.sig]
signature Lexis_sig =
  sig
    val allowed_user_type_var : string -> bool
    val allowed_type_constant : string -> bool
    val allowed_term_constant : string -> bool
    val ok_identifier : string -> bool
    val ok_symbolic : string -> bool
    val ok_sml_identifier : string -> bool
    val is_num_literal : string -> bool
    val is_string_literal : string -> bool
  end
val it = () : unit
[opening 0/lexis.sml]
functor LEXIS : <sig>
val it = () : unit
[opening 0/type.sig]
signature Type_sig =
  sig
    datatype hol_type
      con Link : hol_type ref -> hol_type
      con Stv : int -> hol_type
      con Tyapp : {Args:hol_type list, Tyop:string} -> hol_type
      con Tyc : string -> hol_type
      con Utv : string -> hol_type
    datatype 'a delta
      con CHANGED : 'a -> 'a delta
      con NO_CHANGE : 'a delta
    val new_type_var : unit -> hol_type
    val reset_type_num : unit -> unit
    val unify : hol_type -> hol_type -> unit
    val ty_eq : hol_type * hol_type -> bool
    val shrink_type : hol_type -> hol_type delta
    val rename_tv : hol_type -> hol_type delta
    val ty_sub : hol_type subst -> hol_type -> hol_type delta
    val type_subst : hol_type subst -> hol_type -> hol_type
    val type_vars : hol_type -> hol_type list
    val type_varsl : hol_type list -> hol_type list
    val mk_type : {Args:hol_type list, Tyop:string} -> hol_type
    val dest_type : hol_type -> {Args:hol_type list, Tyop:string}
    val mk_vartype : string -> hol_type
    val dest_vartype : hol_type -> string
    val is_vartype : hol_type -> bool
    val polymorphic : hol_type -> bool
    val type_lt : hol_type -> hol_type -> bool
    val lookup_type : string -> {arity:int, theory:string, tyc:hol_type}
    val type_decl : string -> {arity:int, theory:string, tyc:hol_type}
    val add_type_const : {arity:int, theory:string, tyc:hol_type} -> unit
    val add_entry : {arity:int, theory:string, tyc:hol_type} -> unit
    type symtab
    val symtab_copy : unit -> symtab
    val replace_symtab : symtab -> unit
    exception TYPE_SYMTAB_CLASH of {common_name:string, theory1:string,
                                    theory2:string}
    val is_st_type_const : string -> bool
    val arity_of_type : string -> int
  end
signature Public_type_sig =
  sig
    eqtype hol_type
    val new_type_var : unit -> hol_type
    val reset_type_num : unit -> unit
    val type_subst : hol_type subst -> hol_type -> hol_type
    val type_vars : hol_type -> hol_type list
    val type_varsl : hol_type list -> hol_type list
    val mk_type : {Args:hol_type list, Tyop:string} -> hol_type
    val dest_type : hol_type -> {Args:hol_type list, Tyop:string}
    val mk_vartype : string -> hol_type
    val dest_vartype : hol_type -> string
    val is_vartype : hol_type -> bool
    val type_lt : hol_type -> hol_type -> bool
    val type_decl : string -> {arity:int, theory:string, tyc:hol_type}
  end
val it = () : unit
[opening 0/type.sml]
0/type.sml:248.41-249.28 Warning: match nonexhaustive
          (a1 :: rst1,a2 :: rst2) => ...
          (nil,nil) => ...
  

[Major collection... 17% used (1094444/6297984), 290 msec]

[Decreasing heap to 5684k]
0/type.sml:107.1-112.38 Warning: match nonexhaustive
          entry as {theory=thry1,tyc=Tyc name,...} => ...
  
0/type.sml:52.1-57.6 Warning: match nonexhaustive
          entry as {tyc=Tyc name,...} => ...
  
functor TYPE : <sig>
val it = () : unit
[opening 0/term.sig]
signature Term_sig =
  sig
    structure Type : ...
    datatype fixity
      con Binder : fixity
      con Infix : int -> fixity
      con Prefix : fixity
    datatype term
      con Abs : {Body:term, Bvar:term} -> term
      con Bv : int -> term
      con Comb : {Rand:term, Rator:term} -> term
      con Const : {Name:string, Ty:Type.hol_type} -> term
      con Fv : {Name:string, Ty:Type.hol_type} -> term
      con ty_antiq : Type.hol_type -> term
    datatype lambda
      con COMB : {Rand:term, Rator:term} -> lambda
      con CONST : {Name:string, Ty:Type.hol_type} -> lambda
      con LAMB : {Body:term, Bvar:term} -> lambda
      con VAR : {Name:string, Ty:Type.hol_type} -> lambda
    type symtab
    val symtab_copy : unit -> symtab
    val replace_symtab : symtab -> unit
    exception TERM_SYMTAB_CLASH of {common_name:string, theory1:string,
                                    theory2:string}
    val lookup_const : string -> term
    val const_decl : string -> {const:term, place:fixity, theory:string}
    datatype add_style
      con Defining : add_style
      con Loading : add_style
    val add_term_const : add_style
                         -> {const:term, place:fixity, theory:string} -> unit
    val is_st_term_const : string -> bool
    val fixity_of_term : string -> fixity
    val prec_of_term : string -> int
    val is_binder : string -> bool
    val is_infix : string -> bool
    val is_polymorphic : string -> bool
    val free_vars : term -> term list
    val free_in : term -> term -> bool
    val all_vars : term -> term list
    val free_varsl : term list -> term list
    val all_varsl : term list -> term list
    val term_lt : term -> term -> bool
    val genvar : Type.hol_type -> term
    val genvars : Type.hol_type -> int -> term list
    val variant : term list -> term -> term
    val type_of : term -> Type.hol_type
    val type_vars_in_term : term -> Type.hol_type list
    val mk_var : {Name:string, Ty:Type.hol_type} -> term
    val mk_primed_var : {Name:string, Ty:Type.hol_type} -> term
    val list_mk_comb : term * term list -> term
    val mk_comb : {Rand:term, Rator:term} -> term
    val mk_abs : {Body:term, Bvar:term} -> term
    val dest_var : term -> {Name:string, Ty:Type.hol_type}
    val dest_const : term -> {Name:string, Ty:Type.hol_type}
    val dest_comb : term -> {Rand:term, Rator:term}
    val dest_abs : term -> {Body:term, Bvar:term}
    val is_var : term -> bool
    val is_const : term -> bool
    val is_comb : term -> bool
    val is_abs : term -> bool
    val dest_term : term -> lambda
    val rator : term -> term
    val rand : term -> term
    val bvar : term -> term
    val body : term -> term
    val break_abs : term -> {Body:term, Bvar:term}
    val is_bvar : term -> bool
    val aconv : term -> term -> bool
    val subst : term subst -> term -> term
    val inst : Type.hol_type subst -> term -> term
    val beta_conv : term -> term
  end

[Major collection... 20% used (948624/4665464), 210 msec]
signature Public_term_sig =
  sig
    structure Type : ...
    datatype fixity
      con Binder : fixity
      con Infix : int -> fixity
      con Prefix : fixity
    eqtype term
    val const_decl : string -> {const:term, place:fixity, theory:string}
    val fixity_of_term : string -> fixity
    val prec_of_term : string -> int
    val is_binder : string -> bool
    val is_infix : string -> bool
    val is_polymorphic : string -> bool
    datatype lambda
      con COMB : {Rand:term, Rator:term} -> lambda
      con CONST : {Name:string, Ty:Type.hol_type} -> lambda
      con LAMB : {Body:term, Bvar:term} -> lambda
      con VAR : {Name:string, Ty:Type.hol_type} -> lambda
    val ty_antiq : Type.hol_type -> term
    val free_vars : term -> term list
    val free_in : term -> term -> bool
    val all_vars : term -> term list
    val free_varsl : term list -> term list
    val all_varsl : term list -> term list
    val term_lt : term -> term -> bool
    val genvar : Type.hol_type -> term
    val genvars : Type.hol_type -> int -> term list
    val variant : term list -> term -> term
    val type_of : term -> Type.hol_type
    val type_vars_in_term : term -> Type.hol_type list
    val mk_var : {Name:string, Ty:Type.hol_type} -> term
    val mk_primed_var : {Name:string, Ty:Type.hol_type} -> term
    val list_mk_comb : term * term list -> term
    val mk_comb : {Rand:term, Rator:term} -> term
    val mk_abs : {Body:term, Bvar:term} -> term
    val dest_var : term -> {Name:string, Ty:Type.hol_type}
    val dest_const : term -> {Name:string, Ty:Type.hol_type}
    val dest_comb : term -> {Rand:term, Rator:term}
    val dest_abs : term -> {Body:term, Bvar:term}
    val is_var : term -> bool
    val is_const : term -> bool
    val is_comb : term -> bool
    val is_abs : term -> bool
    val dest_term : term -> lambda
    val rator : term -> term
    val rand : term -> term
    val bvar : term -> term
    val body : term -> term
    val aconv : term -> term -> bool
    val subst : term subst -> term -> term
    val inst : Type.hol_type subst -> term -> term
    val beta_conv : term -> term
  end
val it = () : unit
[opening 0/term.sml]
0/term.sml:148.4-163.45 Warning: match nonexhaustive
          (DorL,
           entry as {const=Const {Name=Name,Ty=Ty},place=place,
                     theory=thry1}) => ...
  
0/term.sml:120.8-124.35 Warning: match nonexhaustive
          (tr
             as {const=Const {Name=Name,...},...} :
                  ?.term_record) :: nil => ...
          (tr  as {const=Const {Name=Name,...},...}) :: rst => ...
          nil => ...
  
0/term.sml:86.1-91.6 Warning: match nonexhaustive
          entry as {const=Const {Name=Name,...},...} => ...
  

[Major collection...
[Increasing heap to 6032k]

[Increasing heap to 7772k]
 34% used (1594464/4667088), 420 msec]

[Increasing heap to 8204k]

[Major collection... 23% used (1482476/6351528), 390 msec]
functor TERM : <sig>
val it = () : unit
[opening 0/match.sig]
signature Match_sig =
  sig
    structure Term : ...
    val match_type : Term.Type.hol_type
                     -> Term.Type.hol_type -> Term.Type.hol_type subst
    val match_term : Term.term
                     -> Term.term -> Term.term subst * Term.Type.hol_type subst
  end
val it = () : unit
[opening 0/match.sml]
functor MATCH : <sig>
val it = () : unit
[opening 0/dsyntax.sig]
signature Dsyntax_sig =
  sig
    structure Term : ...
    val mk_const : {Name:string, Ty:Term.Type.hol_type} -> Term.term
    val mk_eq : {lhs:Term.term, rhs:Term.term} -> Term.term
    val mk_imp : {ant:Term.term, conseq:Term.term} -> Term.term
    val mk_select : {Body:Term.term, Bvar:Term.term} -> Term.term
    val mk_forall : {Body:Term.term, Bvar:Term.term} -> Term.term
    val mk_exists : {Body:Term.term, Bvar:Term.term} -> Term.term
    val mk_neg : Term.term -> Term.term
    val mk_conj : {conj1:Term.term, conj2:Term.term} -> Term.term
    val mk_disj : {disj1:Term.term, disj2:Term.term} -> Term.term
    val mk_cond : {cond:Term.term, larm:Term.term, rarm:Term.term} -> Term.term
    val mk_pair : {fst:Term.term, snd:Term.term} -> Term.term
    val mk_let : {arg:Term.term, func:Term.term} -> Term.term
    val mk_cons : {hd:Term.term, tl:Term.term} -> Term.term
    val mk_list : {els:Term.term list, ty:Term.Type.hol_type} -> Term.term
    val mk_pabs : {body:Term.term, varstruct:Term.term} -> Term.term
    val dest_eq : Term.term -> {lhs:Term.term, rhs:Term.term}
    val lhs : Term.term -> Term.term
    val rhs : Term.term -> Term.term
    val dest_imp : Term.term -> {ant:Term.term, conseq:Term.term}
    val dest_select : Term.term -> {Body:Term.term, Bvar:Term.term}
    val dest_forall : Term.term -> {Body:Term.term, Bvar:Term.term}
    val dest_exists : Term.term -> {Body:Term.term, Bvar:Term.term}
    val dest_neg : Term.term -> Term.term
    val dest_conj : Term.term -> {conj1:Term.term, conj2:Term.term}
    val dest_disj : Term.term -> {disj1:Term.term, disj2:Term.term}
    val dest_cond : Term.term
                    -> {cond:Term.term, larm:Term.term, rarm:Term.term}
    val dest_pair : Term.term -> {fst:Term.term, snd:Term.term}
    val dest_let : Term.term -> {arg:Term.term, func:Term.term}
    val dest_cons : Term.term -> {hd:Term.term, tl:Term.term}
    val dest_list : Term.term -> {els:Term.term list, ty:Term.Type.hol_type}
    val dest_pabs : Term.term -> {body:Term.term, varstruct:Term.term}
    val is_eq : Term.term -> bool
    val is_imp : Term.term -> bool
    val is_select : Term.term -> bool
    val is_forall : Term.term -> bool
    val is_exists : Term.term -> bool
    val is_neg : Term.term -> bool
    val is_conj : Term.term -> bool
    val is_disj : Term.term -> bool
    val is_cond : Term.term -> bool
    val is_pair : Term.term -> bool
    val is_let : Term.term -> bool
    val is_cons : Term.term -> bool
    val is_list : Term.term -> bool
    val is_pabs : Term.term -> bool
    val list_mk_abs : Term.term list * Term.term -> Term.term
    val list_mk_imp : Term.term list * Term.term -> Term.term
    val list_mk_forall : Term.term list * Term.term -> Term.term
    val gen_all : Term.term -> Term.term
    val list_mk_exists : Term.term list * Term.term -> Term.term
    val list_mk_conj : Term.term list -> Term.term
    val list_mk_disj : Term.term list -> Term.term
    val list_mk_pair : Term.term list -> Term.term
    val strip_comb : Term.term -> Term.term * Term.term list
    val strip_abs : Term.term -> Term.term list * Term.term
    val strip_imp : Term.term -> Term.term list * Term.term
    val strip_forall : Term.term -> Term.term list * Term.term
    val strip_exists : Term.term -> Term.term list * Term.term
    val strip_conj : Term.term -> Term.term list
    val strip_disj : Term.term -> Term.term list
    val strip_pair : Term.term -> Term.term list
    val infix_ty : Term.Type.hol_type
                   -> Term.Type.hol_type -> Term.Type.hol_type
    val bool : Term.Type.hol_type
    val de_abs : Term.term -> Term.term list * Term.term
    val find_term : (Term.term -> bool) -> Term.term -> Term.term
    val find_terms : (Term.term -> bool) -> Term.term -> Term.term list
    val subst_occs : int list list -> Term.term subst -> Term.term -> Term.term
    val binder_restrictions : unit -> (string * string) list
    val associate_restriction : string * string -> unit
    val delete_restriction : string -> unit
  end
val it = () : unit

[Major collection... 18% used (1192504/6298424), 290 msec]
[opening 0/dsyntax.sml]
0/dsyntax.sml:261.13-262.29 Warning: binding not exhaustive
          {Name="NIL",Ty=Tyapp {Args=ty :: nil,Tyop="list"}} = ...
0/dsyntax.sml:24.8-24.59 Warning: binding not exhaustive
          c as Const {Ty=ty,...} = ...

[Major collection... 27% used (1715380/6337196), 470 msec]

[Increasing heap to 9224k]
functor DSYNTAX : <sig>
val it = () : unit
[opening 0/hol_pp.extensible.sig]
signature Hol_pp_sig =
  sig
    structure Term : ...
    val pp_type : System.PrettyPrint.ppstream
                  -> Term.Type.hol_type -> int -> unit
    val pp_term : System.PrettyPrint.ppstream -> Term.term -> unit
    val pp_self_parsing_type : System.PrettyPrint.ppstream
                               -> Term.Type.hol_type -> unit
    val pp_self_parsing_term : System.PrettyPrint.ppstream -> Term.term -> unit
    val type_to_string : Term.Type.hol_type -> string
    val term_to_string : Term.term -> string
    val print_type : Term.Type.hol_type -> unit
    val print_term : Term.term -> unit
    structure Extend_hol_pp : ...
  end
val it = () : unit

[Major collection... 24% used (1520704/6293196), 350 msec]

[Major collection... 32% used (2053608/6416992), 540 msec]

[Increasing heap to 10740k]

[Major collection... 35% used (2276456/6330576), 630 msec]

[Increasing heap to 12288k]

[Major collection... 34% used (2226824/6432048), 600 msec]

[Major collection... 31% used (2019972/6421496), 540 msec]

[Major collection... 31% used (1972588/6324160), 530 msec]
[opening 0/hol_pp.extensible.sml]

[Major collection... 48% used (3085252/6305360), 730 msec]
functor HOL_PP : <sig>
val it = () : unit
[opening 0/preterm.sig]
signature Preterm_sig =
  sig
    structure Term : ...
    datatype preterm
      con Abs : {Body:preterm, Bvar:preterm} -> preterm
      con Antiq : Term.term -> preterm
      con Comb : {Rand:preterm, Rator:preterm} -> preterm
      con Const : {Name:string, Ty:Term.Type.hol_type} -> preterm
      con Constrained : preterm * Term.Type.hol_type -> preterm
      con Var : {Name:string, Ty:Term.Type.hol_type} -> preterm
    val typecheck : preterm -> preterm
    val typecheck_cleanup : preterm -> Term.term
    val preterm_to_term : preterm -> Term.term
  end
signature Public_preterm_sig =
  sig
    structure Term : ...
    type preterm
    val typecheck : preterm -> preterm
    val typecheck_cleanup : preterm -> Term.term
    val preterm_to_term : preterm -> Term.term
  end
val it = () : unit
[opening 0/preterm.sml]
functor PRETERM : <sig>
val it = () : unit
[opening 0/parse_support.sig]
signature Parse_support_sig =
  sig
    type preterm_in_env
    type binder_in_env
    structure Preterm : ...
    datatype arg
      con Hty : Preterm.Term.Type.hol_type -> arg
      con Rec_occ : arg
    datatype parse
      con PTM : Preterm.preterm -> parse
      con TY : Preterm.Term.Type.hol_type -> parse
      con TY_SPEC : {clauses:{args:arg list, constructor:string} list,
                     ty_name:string}
                    -> parse
    val make_preterm : preterm_in_env -> parse
    val make_aq : Preterm.Term.term -> preterm_in_env
    val make_binding_occ : string -> binder_in_env
    val make_aq_binding_occ : Preterm.Term.term -> binder_in_env
    val make_atom : string -> preterm_in_env
    val make_string : string -> preterm_in_env
    val list_make_comb : preterm_in_env list -> preterm_in_env
    val make_constrained : preterm_in_env
                           -> Preterm.Term.Type.hol_type -> preterm_in_env
    val bind_term : string
                    -> binder_in_env list -> preterm_in_env -> preterm_in_env
    val bind_restr_term : string
                          -> binder_in_env list
                             -> preterm_in_env
                                -> preterm_in_env -> preterm_in_env
    val make_vstruct : binder_in_env list -> binder_in_env
    val make_constrained_vstruct : binder_in_env
                                   -> Preterm.Term.Type.hol_type
                                      -> binder_in_env
    val make_let : (binder_in_env list * preterm_in_env) list
                   -> preterm_in_env -> preterm_in_env
    val make_list : preterm_in_env list -> preterm_in_env
    val make_set : preterm_in_env list -> preterm_in_env
    val make_set_abs : preterm_in_env * preterm_in_env -> preterm_in_env
    val make_atomic_type : string -> Preterm.Term.Type.hol_type
    val make_type_app : string * Preterm.Term.Type.hol_type list
                        -> Preterm.Term.Type.hol_type
    val make_type_clause : {args:Preterm.Term.Type.hol_type list,
                            constructor:string}
                           -> {args:arg list, constructor:string}
    val rec_occ : Preterm.Term.Type.hol_type
    val prec_parse : preterm_in_env list -> preterm_in_env
    val is_binder : string -> bool
    val extract_type_antiq : Preterm.Term.term -> Preterm.Term.Type.hol_type
  end
val it = () : unit
[opening 0/parse_support.sml]
0/parse_support.sml:466.8-466.59 Warning: binding not exhaustive
          (_,tm) :: nil = ...
0/parse_support.sml:414.1-418.46 Warning: match nonexhaustive
          tm as Const {Name=Name,...} => ...
          Constrained (tm,_) => ...
  
0/parse_support.sml:269.25-269.42 Warning: binding not exhaustive
          b :: rst = ...
0/parse_support.sml:241.1-241.45 Warning: match nonexhaustive
          Tyapp {Args=_ :: ty :: nil,Tyop="fun"} => ...
  
0/parse_support.sml:240.1-240.45 Warning: match nonexhaustive
          Tyapp {Args=ty :: _ :: nil,Tyop="fun"} => ...
  
0/parse_support.sml:160.4-164.25 Warning: match nonexhaustive
          (tm1 :: (rst  as _ :: _),E) => ...
  
0/parse_support.sml:65.1-68.59 Warning: match nonexhaustive
          Const (c  as {Name=Name,Ty=Ty}) => ...
  

[Major collection... 27% used (1742200/6358036), 460 msec]
functor PARSE_SUPPORT : <sig>
val it = () : unit

[Major collection... 22% used (1419788/6297492), 320 msec]

[Decreasing heap to 7280k]
[opening 0/base.qaq.sml]
signature STREAM =
  sig
    type 'a stream
    val streamify : (unit -> '1a) -> '1a stream
    val cons : '1a * '1a stream -> '1a stream
    val get : '1a stream -> '1a * '1a stream
  end
signature LR_TABLE =
  sig
    datatype ('a,'b) pairlist
      con EMPTY : ('a,'b) pairlist
      con PAIR : 'a * 'b * ('a,'b) pairlist -> ('a,'b) pairlist
    datatype state
      con STATE : int -> state
    datatype term
      con T : int -> term
    datatype nonterm
      con NT : int -> nonterm
    datatype action
      con ACCEPT : action
      con ERROR : action
      con REDUCE : int -> action
      con SHIFT : state -> action
    type table
    val numStates : table -> int
    val numRules : table -> int
    val describeActions : table -> state -> (term,action) pairlist * action
    val describeGoto : table -> state -> (nonterm,state) pairlist
    val action : table -> state * term -> action
    val goto : table -> state * nonterm -> state
    val initialState : table -> state
    exception Goto of state * nonterm
    val mkLrTable : {actions:((term,action) pairlist * action) array,
                     gotos:(nonterm,state) pairlist array, initialState:state,
                     numRules:int, numStates:int}
                    -> table
  end
signature TOKEN =
  sig
    structure LrTable : ...
    datatype ('a,'b) token
      con TOKEN : LrTable.term * ('a * 'b * 'b) -> ('a,'b) token
    val sameToken : ('a,'b) token * ('a,'b) token -> bool
  end
signature LR_PARSER =
  sig
    structure Stream : ...
    structure LrTable : ...
    structure Token : ...
    exception ParseError
    val parse : {arg:'a,
                 ec:{error:string * '1c * '1c -> unit,
                     errtermvalue:LrTable.term -> '1b,
                     is_keyword:LrTable.term -> bool,
                     noShift:LrTable.term -> bool,
                     preferred_insert:LrTable.term -> bool,
                     preferred_subst:LrTable.term -> LrTable.term list,
                     showTerminal:LrTable.term -> string,
                     terms:LrTable.term list},
                 lexer:('1b,'1c) Token.token Stream.stream, lookahead:int,
                 saction:int * '1c * (LrTable.state * ('1b * '1c * '1c)) list
                         * 'a
                         -> LrTable.nonterm * ('1b * '1c * '1c)
                            * (LrTable.state * ('1b * '1c * '1c)) list,
                 table:LrTable.table, void:'1b}
                -> '1b * ('1b,'1c) Token.token Stream.stream
    sharing Token.LrTable = LrTable 
  end
signature LEXER =
  sig
    structure UserDeclarations : ...
    val makeLexer : (int -> string)
                    -> unit
                       -> (UserDeclarations.svalue,UserDeclarations.pos) 
                            UserDeclarations.token
  end
signature ARG_LEXER =
  sig
    structure UserDeclarations : ...
    val makeLexer : (int -> string)
                    -> UserDeclarations.Parse_support.Preterm.Term.term list 
                         ref
                       -> unit
                          -> (UserDeclarations.svalue,UserDeclarations.pos) 
                               UserDeclarations.token
  end
signature PARSER_DATA =
  sig
    type pos
    type svalue
    type arg
    type result
    structure LrTable : ...
    structure Token : ...
    structure Actions : ...
    structure EC : ...
    val table : LrTable.table
    sharing LrTable = Token.LrTable 
  end
signature PARSER =
  sig
    structure Token : ...
    structure Stream : ...
    exception ParseError
    type pos
    type result
    type arg
    type svalue
    val makeLexer : (int -> string) -> (svalue,pos) Token.token Stream.stream
    val parse : int * (svalue,pos) Token.token Stream.stream
                * (string * pos * pos -> unit) * arg
                -> result * (svalue,pos) Token.token Stream.stream
    val sameToken : (svalue,pos) Token.token * (svalue,pos) Token.token -> bool
  end
signature ARG_PARSER =
  sig
    structure Token : ...
    structure Stream : ...
    structure Parse_support : ...
    exception ParseError
    type arg
    type pos
    type result
    type svalue
    val makeLexer : (int -> string)
                    -> Parse_support.Preterm.Term.term list ref
                       -> (svalue,pos) Token.token Stream.stream
    val parse : int * (svalue,pos) Token.token Stream.stream
                * (string * pos * pos -> unit) * arg
                -> result * (svalue,pos) Token.token Stream.stream
    val sameToken : (svalue,pos) Token.token * (svalue,pos) Token.token -> bool
  end
structure Stream : STREAM
structure LrTable : LR_TABLE
functor Join : <sig>
functor JoinWithArg : <sig>
0/base.qaq.sml:557.11-558.34 Warning: binding not exhaustive
          (nonterm,value,stack as (state,_) :: _) = ...
0/base.qaq.sml:565.27-565.61 Warning: binding not exhaustive
          (_,(topvalue,_,_)) :: _ = ...
0/base.qaq.sml:550.7-568.9 Warning: match nonexhaustive
          (next as (TOKEN (terminal,value as (_,leftPos,_)),lexer) :
                     ('1bU,'1cU) ?.LrParser.Token.token
                     * ('1bU,'1cU) ?.LrParser.Token.token Stream.stream,
           stack as (state,_) :: _ : ('1bU,'1cU) ?.LrParser.stack) => ...
  
structure LrParser : LR_PARSER
val it = () : unit
[opening 0/hol_yak.sig]
signature hol_TOKENS =
  sig
    type ('a,'b) token
    type svalue
    structure Parse_support : ...
    val EOF : 'a * 'a -> (svalue,'a) token
    val EOLEX : 'a * 'a -> (svalue,'a) token
    val string_ : string * 'a * 'a -> (svalue,'a) token
    val of_ : 'a * 'a -> (svalue,'a) token
    val in_ : 'a * 'a -> (svalue,'a) token
    val and_ : 'a * 'a -> (svalue,'a) token
    val let_ : 'a * 'a -> (svalue,'a) token
    val bar : 'a * 'a -> (svalue,'a) token
    val type_plus : 'a * 'a -> (svalue,'a) token
    val type_hash : 'a * 'a -> (svalue,'a) token
    val eq : 'a * 'a -> (svalue,'a) token
    val eq_gt : 'a * 'a -> (svalue,'a) token
    val type_right_arrow : 'a * 'a -> (svalue,'a) token
    val semi_colon : 'a * 'a -> (svalue,'a) token
    val dot : 'a * 'a -> (svalue,'a) token
    val dcolon : 'a * 'a -> (svalue,'a) token
    val colon : 'a * 'a -> (svalue,'a) token
    val type_comma : 'a * 'a -> (svalue,'a) token
    val rbrace : 'a * 'a -> (svalue,'a) token
    val lbrace : 'a * 'a -> (svalue,'a) token
    val rbracket : 'a * 'a -> (svalue,'a) token
    val lbracket : 'a * 'a -> (svalue,'a) token
    val type_rparen : 'a * 'a -> (svalue,'a) token
    val type_lparen : 'a * 'a -> (svalue,'a) token
    val rparen : 'a * 'a -> (svalue,'a) token
    val lparen : 'a * 'a -> (svalue,'a) token
    val aq : Parse_support.Preterm.Term.term * 'a * 'a -> (svalue,'a) token
    val qualified_binder : (string * string) * 'a * 'a -> (svalue,'a) token
    val binder : string * 'a * 'a -> (svalue,'a) token
    val type_var_ident : string * 'a * 'a -> (svalue,'a) token
    val qualified_type_ident : (string * string) * 'a * 'a -> (svalue,'a) token
    val type_ident : string * 'a * 'a -> (svalue,'a) token
    val qualified_ident : (string * string) * 'a * 'a -> (svalue,'a) token
    val symbolic_ident : string * 'a * 'a -> (svalue,'a) token
    val ident : string * 'a * 'a -> (svalue,'a) token
  end
signature hol_LRVALS =
  sig
    structure Tokens : ...
    structure ParserData : ...
    sharing type Tokens.svalue = ParserData.svalue 
    sharing type Tokens.token = ParserData.Token.token 
  end
val it = () : unit

[Major collection...
[Increasing heap to 7484k]

[Increasing heap to 8504k]
 42% used (2538124/6006320), 650 msec]

[Increasing heap to 12288k]
[opening 0/hol_yak.sml]

[Major collection... 38% used (2441972/6345640), 620 msec]
functor holLrValsFun : <sig>
val it = () : unit
[opening 0/hol_lex.sml]
0/hol_lex.sml:495.14-495.41 Warning: binding not exhaustive
          L as ref (x :: t) = ...
0/hol_lex.sml:545.19-545.33 Warning: binding contains no variables
          () = ...
0/hol_lex.sml:544.14-544.41 Warning: binding not exhaustive
          L as ref (x :: t) = ...

[Major collection... 34% used (2184468/6330280), 510 msec]
functor HOL_LEX : <sig>
val it = () : unit
[opening 0/thy_yak.sig]
signature thy_TOKENS =
  sig
    type ('a,'b) token
    type svalue
    val EOF : 'a * 'a -> (svalue,'a) token
    val EOLEX : 'a * 'a -> (svalue,'a) token
    val string_ : string * 'a * 'a -> (svalue,'a) token
    val type_plus : 'a * 'a -> (svalue,'a) token
    val type_hash : 'a * 'a -> (svalue,'a) token
    val type_right_arrow : 'a * 'a -> (svalue,'a) token
    val dot : 'a * 'a -> (svalue,'a) token
    val colon : 'a * 'a -> (svalue,'a) token
    val type_comma : 'a * 'a -> (svalue,'a) token
    val type_rparen : 'a * 'a -> (svalue,'a) token
    val type_lparen : 'a * 'a -> (svalue,'a) token
    val rparen : 'a * 'a -> (svalue,'a) token
    val lparen : 'a * 'a -> (svalue,'a) token
    val num : string * 'a * 'a -> (svalue,'a) token
    val db_index : int * 'a * 'a -> (svalue,'a) token
    val lambda : 'a * 'a -> (svalue,'a) token
    val type_var_ident : string * 'a * 'a -> (svalue,'a) token
    val type_ident : string * 'a * 'a -> (svalue,'a) token
    val ident : string * 'a * 'a -> (svalue,'a) token
  end
signature thy_LRVALS =
  sig
    structure Tokens : ...
    structure ParserData : ...
    sharing type Tokens.svalue = ParserData.svalue 
    sharing type Tokens.token = ParserData.Token.token 
  end
val it = () : unit
[opening 0/thy_yak.sml]
functor thyLrValsFun : <sig>
val it = () : unit
[opening 0/thy_lex.sml]

[Major collection... 32% used (2032172/6304004), 470 msec]
functor THY_LEX : <sig>
val it = () : unit
[opening 0/parse.sig]
signature Parse_sig =
  sig
    structure Parse_support : ...
    val type_parser : Parse_support.Preterm.Term.term frag list
                      -> Parse_support.Preterm.Term.Type.hol_type
    val preterm_parser : Parse_support.Preterm.Term.term frag list
                         -> Parse_support.Preterm.preterm
    val term_parser : Parse_support.Preterm.Term.term frag list
                      -> Parse_support.Preterm.Term.term
    val type_spec_parser : Parse_support.Preterm.Term.term frag list
                           -> {clauses:{args:Parse_support.arg list,
                                        constructor:string} list,
                               ty_name:string}
    val -- : Parse_support.Preterm.Term.term frag list
             -> 'a -> Parse_support.Preterm.Term.term
    val == : Parse_support.Preterm.Term.term frag list
             -> 'a -> Parse_support.Preterm.Term.Type.hol_type
    val string_to_type : string -> Parse_support.Preterm.Term.Type.hol_type
    val string_to_preterm : string -> Parse_support.Preterm.preterm
    val string_to_term : string -> Parse_support.Preterm.Term.term
    val string_to_type_spec : string
                              -> {clauses:{args:Parse_support.arg list,
                                           constructor:string} list,
                                  ty_name:string}
  end
val it = () : unit
[opening 0/parse.sml]
functor PARSE : <sig>
val it = () : unit
[opening 0/thm.sig]
signature Thm_sig =
  sig
    structure Term : ...
    type thm
    val reset_thm_count : unit -> unit
    val counting_thms : bool -> unit
    val thm_count : unit
                    -> {ABS:int, ASSUME:int, BETA_CONV:int, DISCH:int,
                        INST_TYPE:int, MP:int, REFL:int, SUBST:int, axiom:int,
                        definition:int, drule:int, from_disk:int, other:int,
                        valid_tac:int}
    val hyp : thm -> Term.term list
    val concl : thm -> Term.term
    val dest_thm : thm -> Term.term list * Term.term
    val thm_free_vars : thm -> Term.term list
    val hyp_union : thm list -> Term.term list
    val pp_thm : System.PrettyPrint.ppstream -> thm -> unit
    val thm_to_string : thm -> string
    val print_thm : thm -> unit
    val ASSUME : Term.term -> thm
    val REFL : Term.term -> thm
    val BETA_CONV : Term.term -> thm
    val SUBST : {thm:thm, var:Term.term} list -> Term.term -> thm -> thm
    val ABS : Term.term -> thm -> thm
    val INST_TYPE : Term.Type.hol_type subst -> thm -> thm
    val DISCH : Term.term -> thm -> thm
    val MP : thm -> thm -> thm
    val mk_axiom_thm : Term.term list * Term.term -> thm
    val mk_definition_thm : Term.term list * Term.term -> thm
    val mk_drule_thm : Term.term list * Term.term -> thm
    val mk_disk_thm : Term.term list * Term.term -> thm
    val mk_tac_thm : Term.term list * Term.term -> thm
    val mk_thm : Term.term list * Term.term -> thm
  end
val it = () : unit
[opening 0/thm.sml]
0/thm.sml:160.18-166.25 Warning: match nonexhaustive
          {thm=THM (h,c),var=var as Fv _} => ...
  
functor THM : <sig>
val it = () : unit
[opening 0/net.sig]
signature Net_sig =
  sig
    structure Term : ...
    type 'a net
    val empty_net : 'a net
    val enter : Term.term * 'a -> 'a net -> 'a net
    val lookup : Term.term -> 'a net -> 'a list
  end
val it = () : unit
[opening 0/net.sml]
functor NET : <sig>
val it = () : unit
[opening 0/theory/data.sig]
signature Theory_data_sig =
  sig
    structure Thm : ...
    type theory
    type theory_id
    val mk_theory_id : {name:string, timestamp:time} -> theory_id
    val theory_id : theory -> theory_id
    val theory_id_name : theory_id -> string
    val theory_id_timestamp : theory_id -> time
    val theory_id_eq : theory_id * theory_id -> bool
    val theory_draft_mode : theory -> bool
    val theory_consistent_with_disk : theory -> bool
    val theory_parents : theory -> theory_id list
    val theory_type_constants : theory
                                -> {arity:int, theory:string,
                                    tyc:Thm.Term.Type.hol_type} list
    val theory_term_constants : theory
                                -> {const:Thm.Term.term, place:Thm.Term.fixity,
                                    theory:string} list
    val theory_axioms : theory -> (string * Thm.thm) list
    val theory_definitions : theory -> (string * Thm.thm) list
    val theory_theorems : theory -> (string * Thm.thm) list
    val mk_theory : theory_id -> theory
    val fresh_theory : string -> theory
    val the_current_theory : unit -> theory
    val make_current : theory -> unit
    val set_draft_mode : bool -> theory -> theory
    val set_consistency_with_disk : bool -> theory -> theory
    val add_parent : theory_id -> theory -> theory
    val add_type : {arity:int, theory:string, tyc:Thm.Term.Type.hol_type}
                   -> theory -> theory
    val add_term : {const:Thm.Term.term, place:Thm.Term.fixity, theory:string}
                   -> theory -> theory
    val add_axiom : string * Thm.thm -> theory -> theory
    val add_definition : string * Thm.thm -> theory -> theory
    val add_theorem : string * Thm.thm -> theory -> theory
    val pp_theory : System.PrettyPrint.ppstream -> theory -> unit
  end
val it = () : unit
[opening 0/theory/data.sml]

[Major collection... 35% used (2262548/6325348), 520 msec]
functor THEORY_DATA : <sig>
val it = () : unit
[opening 0/theory/regime.sig]
signature Regime_sig =
  sig
    structure Theory_data : ...
    type hol_sig
    type hol_thms
    val dest_hol_sig : hol_sig
                       -> {parents:Theory_data.theory_id list,
                           term_constants:{const:Theory_data.Thm.Term.term,
                                           place:Theory_data.Thm.Term.fixity,
                                           theory:string} list,
                           thid:Theory_data.theory_id,
                           type_constants:{arity:int, theory:string,
                                           tyc:
                                                 Theory_data.Thm.Term.Type.hol_type}
                                            list}
    val mk_hol_sig : {parents:Theory_data.theory_id list,
                      term_constants:{const:Theory_data.Thm.Term.term,
                                      place:Theory_data.Thm.Term.fixity,
                                      theory:string} list,
                      thid:Theory_data.theory_id,
                      type_constants:{arity:int, theory:string,
                                      tyc:Theory_data.Thm.Term.Type.hol_type} 
                                       list}
                     -> hol_sig
    val dest_hol_thms : hol_thms
                        -> {axioms:(string * Theory_data.Thm.thm) list,
                            definitions:(string * Theory_data.Thm.thm) list,
                            theorems:(string * Theory_data.Thm.thm) list,
                            thid:Theory_data.theory_id}
    val mk_hol_thms : {axioms:(string * Theory_data.Thm.thm) list,
                       definitions:(string * Theory_data.Thm.thm) list,
                       theorems:(string * Theory_data.Thm.thm) list,
                       thid:Theory_data.theory_id}
                      -> hol_thms
    val split_theory : Theory_data.theory -> hol_sig * hol_thms
    val mk_theory_from_parts : hol_sig -> hol_thms -> Theory_data.theory
    val theory_to_hol_sig : Theory_data.theory -> hol_sig
  end
val it = () : unit
[opening 0/theory/regime.sml]
functor REGIME : <sig>
val it = () : unit
[opening 0/theory/disk_io.sig]
signature Disk_io_sig =
  sig
    structure Regime : ...
    val read_hol_sig : instream -> Regime.hol_sig
    val write_hol_sig : outstream * Regime.hol_sig -> unit
    val read_hol_thms : instream -> Regime.hol_thms
    val write_hol_thms : outstream * Regime.hol_thms -> unit
  end
val it = () : unit
[opening 0/thy_parse.sig]
signature Thy_parse_sig =
  sig
    structure Term : ...
    val theory_term_parser : string -> Term.term
  end
val it = () : unit
[opening 0/thy_parse.sml]
functor THY_PARSE : <sig>
val it = () : unit
[opening 0/thy_pp.sig]
signature Thy_pp_sig =
  sig
    structure Term : ...
    val pp_type_rep : System.PrettyPrint.ppstream -> Term.Type.hol_type -> unit
    val pp_term : System.PrettyPrint.ppstream -> Term.term -> unit
  end
val it = () : unit
[opening 0/thy_pp.sml]
functor THY_PP : <sig>
val it = () : unit
[opening 0/theory/disk_io.ascii.sml]
0/theory/disk_io.ascii.sml:92.15-92.62 Warning: binding not exhaustive
          {Args=nil,Tyop=Tyop} = ...
functor DISK_IO_ASCII : <sig>
val it = () : unit
[opening 0/theory/thms.yak.sig]
signature thms_TOKENS =
  sig
    type ('a,'b) token
    type svalue
    val EOF : 'a * 'a -> (svalue,'a) token
    val EOLEX : 'a * 'a -> (svalue,'a) token
    val num : string * 'a * 'a -> (svalue,'a) token
    val id : string * 'a * 'a -> (svalue,'a) token
    val quote : string * 'a * 'a -> (svalue,'a) token
    val theorems : 'a * 'a -> (svalue,'a) token
    val definitions : 'a * 'a -> (svalue,'a) token
    val axioms : 'a * 'a -> (svalue,'a) token
    val thid : 'a * 'a -> (svalue,'a) token
    val eq : 'a * 'a -> (svalue,'a) token
    val comma : 'a * 'a -> (svalue,'a) token
    val rbracket : 'a * 'a -> (svalue,'a) token
    val lbracket : 'a * 'a -> (svalue,'a) token
    val rparen : 'a * 'a -> (svalue,'a) token
    val lparen : 'a * 'a -> (svalue,'a) token
  end
signature thms_LRVALS =
  sig
    structure Tokens : ...
    structure ParserData : ...
    sharing type Tokens.svalue = ParserData.svalue 
    sharing type Tokens.token = ParserData.Token.token 
  end
val it = () : unit

[Major collection... 36% used (2328236/6416200), 560 msec]
[opening 0/theory/thms.yak.sml]
functor thmsLrValsFun : <sig>
val it = () : unit
[opening 0/theory/thms.lex.sml]
functor THMS_LEX : <sig>
val it = () : unit
[opening 0/theory/holsig.yak.sig]
signature holsig_TOKENS =
  sig
    type ('a,'b) token
    type svalue
    val EOF : 'a * 'a -> (svalue,'a) token
    val EOLEX : 'a * 'a -> (svalue,'a) token
    val num : string * 'a * 'a -> (svalue,'a) token
    val id : string * 'a * 'a -> (svalue,'a) token
    val string_constant : string * 'a * 'a -> (svalue,'a) token
    val symbolic : string * 'a * 'a -> (svalue,'a) token
    val type_var : string * 'a * 'a -> (svalue,'a) token
    val constants : 'a * 'a -> (svalue,'a) token
    val types : 'a * 'a -> (svalue,'a) token
    val parents : 'a * 'a -> (svalue,'a) token
    val Infix : 'a * 'a -> (svalue,'a) token
    val Prefix : 'a * 'a -> (svalue,'a) token
    val Binder : 'a * 'a -> (svalue,'a) token
    val fixity : 'a * 'a -> (svalue,'a) token
    val ty : 'a * 'a -> (svalue,'a) token
    val name : 'a * 'a -> (svalue,'a) token
    val thid : 'a * 'a -> (svalue,'a) token
    val eq : 'a * 'a -> (svalue,'a) token
    val comma : 'a * 'a -> (svalue,'a) token
    val rparen : 'a * 'a -> (svalue,'a) token
    val lparen : 'a * 'a -> (svalue,'a) token
    val rbracket : 'a * 'a -> (svalue,'a) token
    val lbracket : 'a * 'a -> (svalue,'a) token
    val rbrace : 'a * 'a -> (svalue,'a) token
    val lbrace : 'a * 'a -> (svalue,'a) token
  end
signature holsig_LRVALS =
  sig
    structure Tokens : ...
    structure ParserData : ...
    sharing type Tokens.svalue = ParserData.svalue 
    sharing type Tokens.token = ParserData.Token.token 
  end
val it = () : unit

[Major collection... 41% used (2612404/6303000), 670 msec]
[opening 0/theory/holsig.yak.sml]
functor holsigLrValsFun : <sig>
val it = () : unit
[opening 0/theory/holsig.lex.sml]

[Major collection... 41% used (2622516/6314912), 650 msec]
functor HOLSIG_LEX : <sig>
val it = () : unit
[opening 0/theory/io.sig]
signature Theory_io_sig =
  sig
    structure Theory_data : ...
    type hol_sig
    type hol_thms
    val dest_hol_sig : hol_sig
                       -> {parents:Theory_data.theory_id list,
                           term_constants:{const:Theory_data.Thm.Term.term,
                                           place:Theory_data.Thm.Term.fixity,
                                           theory:string} list,
                           thid:Theory_data.theory_id,
                           type_constants:{arity:int, theory:string,
                                           tyc:
                                                 Theory_data.Thm.Term.Type.hol_type}
                                            list}
    val theory_to_hol_sig : Theory_data.theory -> hol_sig
    val get_hol_sig_by_name : string list
                              -> string -> {data:hol_sig, path:string}
    val get_hol_sig_by_uid : string list
                             -> Theory_data.theory_id
                                -> {data:hol_sig, path:string}
    val get_thms : string list
                   -> Theory_data.theory_id -> {data:hol_thms, path:string}
    val mk_theory : hol_sig -> hol_thms -> Theory_data.theory
    val put_theory_to_disk : Theory_data.theory -> unit
  end
val it = () : unit
[opening 0/theory/io.sml]
functor THEORY_IO : <sig>
val it = () : unit
[opening 0/cache.sml]
functor CACHE : <sig>
val it = () : unit
[opening 0/theory/cache.sig]
signature Theory_cache_sig =
  sig
    type object
    eqtype key
    val add_object_to_cache : object -> unit
    val get_object_from_cache : key -> object
    val delete_object_from_cache : key -> unit
    val delete_cache : unit -> unit
    val objects_in_cache : unit -> key list
    val is_object_in_cache : key -> bool
  end
val it = () : unit
[opening 0/theory/graph.sig]
signature Theory_graph_sig =
  sig
    type node_id
    type graph
    val add_node : node_id -> node_id list -> unit
    val node_in_graph : node_id -> bool
    val is_ancestor : string -> bool
    val add_parent : node_id -> node_id -> unit
    val graph_copy : unit -> graph
    val replace_graph : graph -> unit
    val parents : string -> node_id list
    val ancestry : string -> node_id list
  end
val it = () : unit
[opening 0/theory/graph.sml]
functor DAG : <sig>
val it = () : unit
[opening 0/theory/ops.sig]
signature Theory_ops_sig =
  sig
    structure Theory_data : ...
    structure Theory_io : ...
    structure Theory_cache : ...
    structure Theory_graph : ...
    val grab_ances_theory : string -> Theory_data.theory
    val perform_atomic_theory_op : (unit -> 'a) -> 'a
    val install_new_parent : string * Theory_io.hol_sig -> unit
    val goto_theory : string -> Theory_data.theory_id -> Theory_data.theory
    val export_theory : unit -> unit
    val close : unit -> unit
    sharing Theory_data = Theory_io.Theory_data 
  end
val it = () : unit
[opening 0/theory/ops.sml]
functor THEORY_OPS : <sig>
val it = () : unit
[opening 0/theory/theory.sig]
signature Theory_sig =
  sig
    structure Thm : ...
    val new_parent : string -> unit
    val new_type : {Arity:int, Name:string} -> unit
    val new_constant : {Name:string, Ty:Thm.Term.Type.hol_type} -> unit
    val new_infix : {Name:string, Prec:int, Ty:Thm.Term.Type.hol_type} -> unit
    val new_binder : {Name:string, Ty:Thm.Term.Type.hol_type} -> unit
    val new_open_axiom : string * Thm.Term.term -> Thm.thm
    val store_definition : string * Thm.Term.term -> Thm.thm
    val save_thm : string * Thm.thm -> Thm.thm
    val arity : string -> int
    val fixity : string -> Thm.Term.fixity
    val precedence : string -> int
    val const_decl : string
                     -> {const:Thm.Term.term, place:Thm.Term.fixity,
                         theory:string}
    val is_constant : string -> bool
    val is_type : string -> bool
    val is_binder : string -> bool
    val is_infix : string -> bool
    val draft_mode : unit -> bool
    val current_theory : unit -> string
    val parents : string -> string list
    val ancestry : string -> string list
    val types : string -> {Arity:int, Name:string} list
    val constants : string -> Thm.Term.term list
    val infixes : string -> Thm.Term.term list
    val binders : string -> Thm.Term.term list
    val axioms : string -> (string * Thm.thm) list
    val axiom : string -> string -> Thm.thm
    val definitions : string -> (string * Thm.thm) list
    val definition : string -> string -> Thm.thm
    val theorems : string -> (string * Thm.thm) list
    val theorem : string -> string -> Thm.thm
    val print_theory : string -> unit
    val html_theory : string -> unit
    val new_theory : string -> unit
    val close_theory : unit -> unit
    val load_theory : string -> unit
    val extend_theory : string -> unit
    val export_theory : unit -> unit
    val close : unit -> unit
    val delete_cache : unit -> unit
    val delete_theory_from_cache : string -> unit
    val theories_in_cache : unit -> string list
    val perform_atomic_theory_op : (unit -> 'a) -> 'a
  end
val it = () : unit

[Major collection... 40% used (2591688/6347960), 600 msec]
[opening 0/theory/theory.sml]
0/theory/theory.sml:205.1-206.39 Warning: match nonexhaustive
          {arity=arity,theory=theory,tyc=Tyc name} => ...
  
0/theory/theory.sml:91.8-91.60 Warning: binding not exhaustive
          {Args=_ :: _ :: nil,Tyop="fun"} = ...
0/theory/theory.sml:90.8-90.61 Warning: binding not exhaustive
          {Args=ty1 :: _ :: nil,Tyop="fun"} = ...
0/theory/theory.sml:85.8-85.59 Warning: binding not exhaustive
          {Args=_ :: _ :: nil,Tyop="fun"} = ...
0/theory/theory.sml:84.8-84.60 Warning: binding not exhaustive
          {Args=_ :: ty2 :: nil,Tyop="fun"} = ...

[Major collection... 43% used (2813064/6433032), 690 msec]
functor THEORY : <sig>
val it = () : unit
[opening 0/theory/add_to_sml.sig]
signature Add_to_sml_sig =
  sig
    type thm
    val L : (string * thm) list ref
    val parser : thm frag list -> thm
    val add_to_sml : (string * thm) list -> unit
    val add_axioms_to_sml : string -> unit
    val add_definitions_to_sml : string -> unit
    val add_theorems_to_sml : string -> unit
    val add_theory_to_sml : string -> unit
    val add_theory_structure_to_sml : {structure_name:string,
                                       theory_name:string}
                                      -> unit
    type autoload_info
    val set_autoloads : autoload_info -> unit
  end
val it = () : unit

[Major collection... 42% used (2702836/6433968), 590 msec]
[opening 0/theory/add_to_sml.sml]
functor ADD_TO_SML : <sig>
val it = () : unit
[opening 0/library/lib_data.sig]
signature Lib_data_sig =
  sig
    type lib_id
    val new_lib_id : string -> lib_id
    val mk_lib_id : {name:string, timestamp:time} -> lib_id
    val lib_id_name : lib_id -> string
    val lib_id_timestamp : lib_id -> time
    val lib_id_eq : lib_id * lib_id -> bool
    type lib_data
    val dest_lib_data : lib_data
                        -> {code:string list, doc:string, help:string list,
                            lib_id:lib_id, loaded:string, parents:lib_id list,
                            path:string, theories:string list}
    val mk_lib_data : {code:string list, doc:string, help:string list,
                       lib_id:lib_id, loaded:string, parents:lib_id list,
                       path:string, theories:string list}
                      -> lib_data
  end
val it = () : unit
[opening 0/library/lib_data.sml]
structure Lib_data : Lib_data_sig
val it = () : unit
[opening 0/library/lib.yak.sig]
signature lib_TOKENS =
  sig
    type ('a,'b) token
    type svalue
    val EOF : 'a * 'a -> (svalue,'a) token
    val EOLEX : 'a * 'a -> (svalue,'a) token
    val string_constant : string * 'a * 'a -> (svalue,'a) token
    val num : string * 'a * 'a -> (svalue,'a) token
    val id : string * 'a * 'a -> (svalue,'a) token
    val loaded : 'a * 'a -> (svalue,'a) token
    val help : 'a * 'a -> (svalue,'a) token
    val code : 'a * 'a -> (svalue,'a) token
    val theories : 'a * 'a -> (svalue,'a) token
    val parents : 'a * 'a -> (svalue,'a) token
    val path : 'a * 'a -> (svalue,'a) token
    val doc : 'a * 'a -> (svalue,'a) token
    val lib_id : 'a * 'a -> (svalue,'a) token
    val comma : 'a * 'a -> (svalue,'a) token
    val eq : 'a * 'a -> (svalue,'a) token
    val rparen : 'a * 'a -> (svalue,'a) token
    val lparen : 'a * 'a -> (svalue,'a) token
    val rbracket : 'a * 'a -> (svalue,'a) token
    val lbracket : 'a * 'a -> (svalue,'a) token
    val rbrace : 'a * 'a -> (svalue,'a) token
    val lbrace : 'a * 'a -> (svalue,'a) token
  end
signature lib_LRVALS =
  sig
    structure Tokens : ...
    structure ParserData : ...
    sharing type Tokens.svalue = ParserData.svalue 
    sharing type Tokens.token = ParserData.Token.token 
  end
val it = () : unit
[opening 0/library/lib.yak.sml]
functor libLrValsFun : <sig>
val it = () : unit

[Major collection... 41% used (2603148/6298692), 560 msec]
[opening 0/library/lib.lex.sml]
functor LIB_LEX : <sig>
val it = () : unit
[opening 0/library/lib_io.sig]
signature Lib_io_sig =
  sig
    structure Lib_data : ...
    val get_lib_by_name : string list -> string -> Lib_data.lib_data
    val get_lib_by_uid : string list -> Lib_data.lib_id -> Lib_data.lib_data
    val write_lib_to_disk : string * Lib_data.lib_data -> unit
  end
val it = () : unit
[opening 0/library/lib_io.sml]
functor LIB_IO : <sig>
val it = () : unit
[opening 0/library/lib.sig]
signature Library_sig =
  sig
    type lib
    val loaded_cell : (unit -> unit) ref
    val lib_eq : lib -> lib -> bool
    val new_library : {code:string list, doc:string, help:string list,
                       loaded:string, name:string, parents:lib list,
                       path:string, theories:string list}
                      -> lib
    val dest_library : lib
                       -> {code:string list, doc:string, help:string list,
                           name:string, parents:lib list, path:string,
                           theories:string list}
    val prim_load_library : (string -> unit)
                            -> {lib:lib, theory:string} -> unit
    val load_library : {lib:lib, theory:string} -> unit
    val load_library_in_place : lib -> unit
    val find_library : string -> lib
    val get_library_from_disk : string -> lib
    val move_library : lib * string -> unit
    val delete_library : lib -> unit
    val known_libraries : unit -> lib list
    val loaded_libraries : unit -> lib list
    val pp_library : System.PrettyPrint.ppstream -> lib -> unit
    val lib_help : {lib:lib, topic:string} -> unit
  end
val it = () : unit
[opening 0/library/lib.sml]

[Major collection... 44% used (2837108/6357040), 660 msec]
functor LIBRARY : <sig>
val it = () : unit
[opening 0/install.sig]
signature Install_sig =
  sig
    val install_system_theory : string -> unit
    val install : string -> unit
  end
val it = () : unit
[opening 0/install.sml]
functor INSTALL : <sig>
val it = () : unit
[opening 0/exists_def.sig]
signature Exists_def_sig =
  sig
    structure Theory : ...
    val new_binder_definition : string * Theory.Thm.Term.term -> Theory.Thm.thm
  end
val it = () : unit
[opening 0/exists_def.sml]
functor EXISTS_DEF : <sig>
val it = () : unit
[opening 0/const_spec.sig]
signature Const_spec_sig =
  sig
    structure Theory : ...
    val new_specification : {consts:{const_name:string,
                                     fixity:Theory.Thm.Term.fixity} list,
                             name:string, sat_thm:Theory.Thm.thm}
                            -> Theory.Thm.thm
  end
val it = () : unit
[opening 0/const_spec.sml]
0/const_spec.sml:76.8-76.60 Warning: binding not exhaustive
          {Args=_ :: _ :: nil,Tyop="fun"} = ...
0/const_spec.sml:75.8-75.61 Warning: binding not exhaustive
          {Args=ty1 :: _ :: nil,Tyop="fun"} = ...
0/const_spec.sml:68.8-68.60 Warning: binding not exhaustive
          {Args=_ :: _ :: nil,Tyop="fun"} = ...
0/const_spec.sml:67.8-67.60 Warning: binding not exhaustive
          {Args=_ :: ty2 :: nil,Tyop="fun"} = ...
functor CONST_SPEC : <sig>
val it = () : unit
[opening 0/type_def.sig]
signature Type_def_sig =
  sig
    structure Theory : ...
    val new_type_definition : {inhab_thm:Theory.Thm.thm, name:string,
                               pred:Theory.Thm.Term.term}
                              -> Theory.Thm.thm
  end
val it = () : unit
[opening 0/type_def.sml]
0/type_def.sml:124.22-125.67 Warning: binding not exhaustive
          {Args=ty :: _ :: nil,...} = ...

[Major collection... 42% used (2729784/6407924), 580 msec]
functor TYPE_DEF : <sig>
val it = () : unit
[opening 0/const_def.sig]
signature Const_def_sig =
  sig
    structure Theory : ...
    val new_definition : string * Theory.Thm.Term.term -> Theory.Thm.thm
    val new_infix_definition : string * Theory.Thm.Term.term * int
                               -> Theory.Thm.thm
    val new_binder_definition : string * Theory.Thm.Term.term -> Theory.Thm.thm
  end
val it = () : unit
[opening 0/const_def.sml]
functor CONST_DEF : <sig>
val it = () : unit
[opening /usr/groups/hol/hol90.7/solaris/theories/src/mk_min.sig]
signature Mk_min_sig = sig  end
[opening /usr/groups/hol/hol90.7/solaris/theories/src/mk_min.sml]
functor MK_MIN : <sig>
[opening /usr/groups/hol/hol90.7/solaris/theories/src/mk_exists.sig]
signature Mk_exists_sig =
  sig
    type thm
    val EXISTS_DEF : thm
  end
[opening /usr/groups/hol/hol90.7/solaris/theories/src/mk_exists.sml]
functor MK_EXISTS : <sig>
[opening /usr/groups/hol/hol90.7/solaris/theories/src/mk_bool.sig]
signature Mk_bool_sig =
  sig
    type thm
    val T_DEF : thm
    val FORALL_DEF : thm
    val AND_DEF : thm
    val OR_DEF : thm
    val F_DEF : thm
    val NOT_DEF : thm
    val EXISTS_UNIQUE_DEF : thm
    val LET_DEF : thm
    val COND_DEF : thm
    val ONE_ONE_DEF : thm
    val ONTO_DEF : thm
    val TYPE_DEFINITION : thm
    val BOOL_CASES_AX : thm
    val IMP_ANTISYM_AX : thm
    val ETA_AX : thm
    val SELECT_AX : thm
    val INFINITY_AX : thm
  end
[opening 0/base_logic.sig]
signature Base_logic_sig =
  sig
    structure Save_hol : ...
    structure Lexis : ...
    structure Type : ...
    structure Term : ...
    structure Match : ...
    structure Dsyntax : ...
    structure Net : ...
    structure Thm : ...
    structure Theory : ...
    structure Add_to_sml : ...
    structure Library : ...
    structure Install : ...
    structure Const_spec : ...
    structure Type_def : ...
    structure Const_def : ...
    structure Min : ...
    structure Exists : ...
    sharing Const_def.Theory = Type_def.Theory = Const_spec.Theory = Theory 
    sharing Theory.Thm = Thm 
    sharing Thm.Term = Net.Term = Dsyntax.Term = Match.Term = Term 
    sharing Term.Type = Type 
    sharing type Theory.Thm.thm = Exists.thm 
  end
val it = () : unit
[opening 0/term_io.sig]
signature Term_io_sig =
  sig
    structure Parse : ...
    structure Parse_support : ...
    structure Hol_pp : ...
  end
val it = () : unit

Loading theory "min"

Loading theory "bool"

Theory "min" already consistent with disk, hence not exported.
structure Base_logic : Base_logic_sig
structure Term_io : Term_io_sig
open Base_logic
structure Save_hol : Save_hol_sig
structure Lexis : Lexis_sig
structure Type : Public_type_sig
structure Term : Public_term_sig
structure Match : Match_sig
structure Dsyntax : Dsyntax_sig
structure Net : Net_sig
structure Thm : Thm_sig
structure Theory : Theory_sig
structure Add_to_sml : Add_to_sml_sig
structure Library : Library_sig
structure Install : Install_sig
structure Const_spec : Const_spec_sig
structure Type_def : Type_def_sig
structure Const_def : Const_def_sig
structure Min : Mk_min_sig
structure Exists : Mk_exists_sig
structure Bool :
  sig
    val AND_DEF : Thm.thm
    val BOOL_CASES_AX : Thm.thm
    val COND_DEF : Thm.thm
    val ETA_AX : Thm.thm
    val EXISTS_DEF : Thm.thm
    val EXISTS_UNIQUE_DEF : Thm.thm
    val FORALL_DEF : Thm.thm
    val F_DEF : Thm.thm
    val IMP_ANTISYM_AX : Thm.thm
    val INFINITY_AX : Thm.thm
    val LET_DEF : Thm.thm
    val NOT_DEF : Thm.thm
    val ONE_ONE_DEF : Thm.thm
    val ONTO_DEF : Thm.thm
    val OR_DEF : Thm.thm
    val SELECT_AX : Thm.thm
    val TRUTH : Thm.thm
    val TYPE_DEFINITION : Thm.thm
  end
val it = () : unit
structure Bool : Mk_bool_sig
type  conv = Term.term -> Thm.thm
type  goal = Term.term list * Term.term
type  validation = Thm.thm list -> Thm.thm
type  tactic = goal -> goal list * validation
type  thm_tactic = Thm.thm -> tactic
type  thm_tactical = thm_tactic -> thm_tactic
structure EMPTY : sig  end
functor GLOBALS : <sig>
functor EXCEPTION : <sig>
functor LIB : <sig>
functor FILE : <sig>
functor HELP : <sig>
functor SAVE_HOL : <sig>
functor LEXIS : <sig>
functor TYPE : <sig>
functor TERM : <sig>
functor MATCH : <sig>
functor SYMTAB : <sig>
functor DSYNTAX : <sig>
functor HOL_PP : <sig>
functor PRETERM : <sig>
functor PARSE_SUPPORT : <sig>
functor HOL_LEX : <sig>
functor THM : <sig>
functor THEORY_DATA : <sig>
functor THY_PP : <sig>
functor THY_PARSE : <sig>
functor DISK_IO_ASCII : <sig>
functor CACHE : <sig>
functor DAG : <sig>
functor THEORY_IO : <sig>
functor THEORY_OPS : <sig>
functor THEORY : <sig>
functor ADD_TO_SML : <sig>
functor LIB_IO : <sig>
functor LIBRARY : <sig>
functor EXISTS_DEF : <sig>
signature EMPTY = sig  end
signature Type_sig = sig  end
signature Term_sig = sig  end
signature Symtab_sig = sig  end
signature Dsyntax_sig = sig  end
val prim_hol_lib =
  library name: PRIM_HOL
  description: Derived rules and such. Preloaded
  parents: []
   : Library.lib

Loading the library "PRIM_HOL".
[opening /usr/groups/hol/hol90.7/solaris/src/1/drule.sig]
signature Drule1_sig =
  sig
    structure Thm : ...
    val ADD_ASSUM : Thm.Term.term -> Thm.thm -> Thm.thm
    val UNDISCH : Thm.thm -> Thm.thm
    val SYM : Thm.thm -> Thm.thm
    val TRANS : Thm.thm -> Thm.thm -> Thm.thm
    val IMP_TRANS : Thm.thm -> Thm.thm -> Thm.thm
    val AP_TERM : Thm.Term.term -> Thm.thm -> Thm.thm
    val AP_THM : Thm.thm -> Thm.Term.term -> Thm.thm
    val EQ_MP : Thm.thm -> Thm.thm -> Thm.thm
    val EQ_IMP_RULE : Thm.thm -> Thm.thm * Thm.thm
    val TRUTH : Thm.thm
    val EQT_ELIM : Thm.thm -> Thm.thm
    val SPEC : Thm.Term.term -> Thm.thm -> Thm.thm
    val SPECL : Thm.Term.term list -> Thm.thm -> Thm.thm
    val EQT_INTRO : Thm.thm -> Thm.thm
    val GEN : Thm.Term.term -> Thm.thm -> Thm.thm
    val GENL : Thm.Term.term list -> Thm.thm -> Thm.thm
    val ETA_CONV : Thm.Term.term -> Thm.thm
    val EXT : Thm.thm -> Thm.thm
    val SELECT_INTRO : Thm.thm -> Thm.thm
    val SELECT_ELIM : Thm.thm -> Thm.Term.term * Thm.thm -> Thm.thm
    val EXISTS : Thm.Term.term * Thm.Term.term -> Thm.thm -> Thm.thm
    val disch : Thm.Term.term * Thm.Term.term list -> Thm.Term.term list
    val CHOOSE : Thm.Term.term * Thm.thm -> Thm.thm -> Thm.thm
    val SELECT_RULE : Thm.thm -> Thm.thm
    val IMP_ANTISYM_RULE : Thm.thm -> Thm.thm -> Thm.thm
    val SPEC_VAR : Thm.thm -> Thm.Term.term * Thm.thm
    val MK_EXISTS : Thm.thm -> Thm.thm
    val LIST_MK_EXISTS : Thm.Term.term list -> Thm.thm -> Thm.thm
    val FORALL_EQ : Thm.Term.term -> Thm.thm -> Thm.thm
    val EXISTS_EQ : Thm.Term.term -> Thm.thm -> Thm.thm
    val SELECT_EQ : Thm.Term.term -> Thm.thm -> Thm.thm
    val SUBS : Thm.thm list -> Thm.thm -> Thm.thm
    val SUBS_OCCS : (int list * Thm.thm) list -> Thm.thm -> Thm.thm
    val SUBST_CONV : {thm:Thm.thm, var:Thm.Term.term} list
                     -> Thm.Term.term -> Thm.Term.term -> Thm.thm
    val RIGHT_BETA : Thm.thm -> Thm.thm
    val LIST_BETA_CONV : Thm.Term.term -> Thm.thm
    val RIGHT_LIST_BETA : Thm.thm -> Thm.thm
  end

[Major collection... 45% used (2885088/6316124), 690 msec]
signature Drule2_sig =
  sig
    structure Thm : ...
    val ADD_ASSUM : Thm.Term.term -> Thm.thm -> Thm.thm
    val UNDISCH : Thm.thm -> Thm.thm
    val SYM : Thm.thm -> Thm.thm
    val TRANS : Thm.thm -> Thm.thm -> Thm.thm
    val IMP_TRANS : Thm.thm -> Thm.thm -> Thm.thm
    val AP_TERM : Thm.Term.term -> Thm.thm -> Thm.thm
    val AP_THM : Thm.thm -> Thm.Term.term -> Thm.thm
    val EQ_MP : Thm.thm -> Thm.thm -> Thm.thm
    val EQ_IMP_RULE : Thm.thm -> Thm.thm * Thm.thm
    val TRUTH : Thm.thm
    val EQT_ELIM : Thm.thm -> Thm.thm
    val SPEC : Thm.Term.term -> Thm.thm -> Thm.thm
    val SPECL : Thm.Term.term list -> Thm.thm -> Thm.thm
    val EQT_INTRO : Thm.thm -> Thm.thm
    val GEN : Thm.Term.term -> Thm.thm -> Thm.thm
    val GENL : Thm.Term.term list -> Thm.thm -> Thm.thm
    val ETA_CONV : Thm.Term.term -> Thm.thm
    val EXT : Thm.thm -> Thm.thm
    val SELECT_INTRO : Thm.thm -> Thm.thm
    val SELECT_ELIM : Thm.thm -> Thm.Term.term * Thm.thm -> Thm.thm
    val EXISTS : Thm.Term.term * Thm.Term.term -> Thm.thm -> Thm.thm
    val disch : Thm.Term.term * Thm.Term.term list -> Thm.Term.term list
    val CHOOSE : Thm.Term.term * Thm.thm -> Thm.thm -> Thm.thm
    val SELECT_RULE : Thm.thm -> Thm.thm
    val IMP_ANTISYM_RULE : Thm.thm -> Thm.thm -> Thm.thm
    val SPEC_VAR : Thm.thm -> Thm.Term.term * Thm.thm
    val MK_EXISTS : Thm.thm -> Thm.thm
    val LIST_MK_EXISTS : Thm.Term.term list -> Thm.thm -> Thm.thm
    val FORALL_EQ : Thm.Term.term -> Thm.thm -> Thm.thm
    val EXISTS_EQ : Thm.Term.term -> Thm.thm -> Thm.thm
    val SELECT_EQ : Thm.Term.term -> Thm.thm -> Thm.thm
    val SUBS : Thm.thm list -> Thm.thm -> Thm.thm
    val SUBS_OCCS : (int list * Thm.thm) list -> Thm.thm -> Thm.thm
    val SUBST_CONV : {thm:Thm.thm, var:Thm.Term.term} list
                     -> Thm.Term.term -> Thm.Term.term -> Thm.thm
    val RIGHT_BETA : Thm.thm -> Thm.thm
    val LIST_BETA_CONV : Thm.Term.term -> Thm.thm
    val RIGHT_LIST_BETA : Thm.thm -> Thm.thm
    val AND_INTRO_THM : Thm.thm
    val CONJ : Thm.thm -> Thm.thm -> Thm.thm
    val AND1_THM : Thm.thm
    val CONJUNCT1 : Thm.thm -> Thm.thm
    val AND2_THM : Thm.thm
    val CONJUNCT2 : Thm.thm -> Thm.thm
    val CONJ_SYM : Thm.thm
    val CONJ_ASSOC : Thm.thm
    val CONJUNCTS_CONV : Thm.Term.term * Thm.Term.term -> Thm.thm
    val CONJ_SET_CONV : Thm.Term.term list -> Thm.Term.term list -> Thm.thm
    val FRONT_CONJ_CONV : Thm.Term.term list -> Thm.Term.term -> Thm.thm
    val CONJ_DISCH : Thm.Term.term -> Thm.thm -> Thm.thm
    val CONJ_DISCHL : Thm.Term.term list -> Thm.thm -> Thm.thm
    val OR_INTRO_THM1 : Thm.thm
    val DISJ1 : Thm.thm -> Thm.Term.term -> Thm.thm
    val OR_INTRO_THM2 : Thm.thm
    val DISJ2 : Thm.Term.term -> Thm.thm -> Thm.thm
    val OR_ELIM_THM : Thm.thm
    val DISJ_CASES : Thm.thm -> Thm.thm -> Thm.thm -> Thm.thm
    val FALSITY : Thm.thm
    val IMP_F : Thm.thm
    val NOT_INTRO : Thm.thm -> Thm.thm
    val NEG_DISCH : Thm.Term.term -> Thm.thm -> Thm.thm
    val F_IMP : Thm.thm
    val NOT_ELIM : Thm.thm -> Thm.thm
    val NOT_EQ_SYM : Thm.thm -> Thm.thm
    val AND_CLAUSES : Thm.thm
    val OR_CLAUSES : Thm.thm
    val IMP_CLAUSES : Thm.thm
    val CONTR : Thm.Term.term -> Thm.thm -> Thm.thm
    val EQF_INTRO : Thm.thm -> Thm.thm
    val EQF_ELIM : Thm.thm -> Thm.thm
    val EXCLUDED_MIDDLE : Thm.thm
    val CCONTR : Thm.Term.term -> Thm.thm -> Thm.thm
    val INST : Thm.Term.term subst -> Thm.thm -> Thm.thm
    val NOT_F : Thm.thm
    val NOT_AND : Thm.thm
  end
signature Drule3_sig =
  sig
    structure Thm : ...
    val ADD_ASSUM : Thm.Term.term -> Thm.thm -> Thm.thm
    val UNDISCH : Thm.thm -> Thm.thm
    val SYM : Thm.thm -> Thm.thm
    val TRANS : Thm.thm -> Thm.thm -> Thm.thm
    val IMP_TRANS : Thm.thm -> Thm.thm -> Thm.thm
    val AP_TERM : Thm.Term.term -> Thm.thm -> Thm.thm
    val AP_THM : Thm.thm -> Thm.Term.term -> Thm.thm
    val EQ_MP : Thm.thm -> Thm.thm -> Thm.thm
    val EQ_IMP_RULE : Thm.thm -> Thm.thm * Thm.thm
    val TRUTH : Thm.thm
    val EQT_ELIM : Thm.thm -> Thm.thm
    val SPEC : Thm.Term.term -> Thm.thm -> Thm.thm
    val SPECL : Thm.Term.term list -> Thm.thm -> Thm.thm
    val EQT_INTRO : Thm.thm -> Thm.thm
    val GEN : Thm.Term.term -> Thm.thm -> Thm.thm
    val GENL : Thm.Term.term list -> Thm.thm -> Thm.thm
    val ETA_CONV : Thm.Term.term -> Thm.thm
    val EXT : Thm.thm -> Thm.thm
    val SELECT_INTRO : Thm.thm -> Thm.thm
    val SELECT_ELIM : Thm.thm -> Thm.Term.term * Thm.thm -> Thm.thm
    val EXISTS : Thm.Term.term * Thm.Term.term -> Thm.thm -> Thm.thm
    val disch : Thm.Term.term * Thm.Term.term list -> Thm.Term.term list
    val CHOOSE : Thm.Term.term * Thm.thm -> Thm.thm -> Thm.thm
    val SELECT_RULE : Thm.thm -> Thm.thm
    val IMP_ANTISYM_RULE : Thm.thm -> Thm.thm -> Thm.thm
    val SPEC_VAR : Thm.thm -> Thm.Term.term * Thm.thm
    val MK_EXISTS : Thm.thm -> Thm.thm
    val LIST_MK_EXISTS : Thm.Term.term list -> Thm.thm -> Thm.thm
    val FORALL_EQ : Thm.Term.term -> Thm.thm -> Thm.thm
    val EXISTS_EQ : Thm.Term.term -> Thm.thm -> Thm.thm
    val SELECT_EQ : Thm.Term.term -> Thm.thm -> Thm.thm
    val SUBS : Thm.thm list -> Thm.thm -> Thm.thm
    val SUBS_OCCS : (int list * Thm.thm) list -> Thm.thm -> Thm.thm
    val SUBST_CONV : {thm:Thm.thm, var:Thm.Term.term} list
                     -> Thm.Term.term -> Thm.Term.term -> Thm.thm
    val RIGHT_BETA : Thm.thm -> Thm.thm
    val LIST_BETA_CONV : Thm.Term.term -> Thm.thm
    val RIGHT_LIST_BETA : Thm.thm -> Thm.thm
    val AND_INTRO_THM : Thm.thm
    val CONJ : Thm.thm -> Thm.thm -> Thm.thm
    val AND1_THM : Thm.thm
    val CONJUNCT1 : Thm.thm -> Thm.thm
    val AND2_THM : Thm.thm
    val CONJUNCT2 : Thm.thm -> Thm.thm
    val CONJ_SYM : Thm.thm
    val CONJ_ASSOC : Thm.thm
    val CONJUNCTS_CONV : Thm.Term.term * Thm.Term.term -> Thm.thm
    val CONJ_SET_CONV : Thm.Term.term list -> Thm.Term.term list -> Thm.thm
    val FRONT_CONJ_CONV : Thm.Term.term list -> Thm.Term.term -> Thm.thm
    val CONJ_DISCH : Thm.Term.term -> Thm.thm -> Thm.thm
    val CONJ_DISCHL : Thm.Term.term list -> Thm.thm -> Thm.thm
    val OR_INTRO_THM1 : Thm.thm
    val DISJ1 : Thm.thm -> Thm.Term.term -> Thm.thm
    val OR_INTRO_THM2 : Thm.thm
    val DISJ2 : Thm.Term.term -> Thm.thm -> Thm.thm
    val OR_ELIM_THM : Thm.thm
    val DISJ_CASES : Thm.thm -> Thm.thm -> Thm.thm -> Thm.thm
    val FALSITY : Thm.thm
    val IMP_F : Thm.thm
    val NOT_INTRO : Thm.thm -> Thm.thm
    val NEG_DISCH : Thm.Term.term -> Thm.thm -> Thm.thm
    val F_IMP : Thm.thm
    val NOT_ELIM : Thm.thm -> Thm.thm
    val NOT_EQ_SYM : Thm.thm -> Thm.thm
    val AND_CLAUSES : Thm.thm
    val OR_CLAUSES : Thm.thm
    val IMP_CLAUSES : Thm.thm
    val CONTR : Thm.Term.term -> Thm.thm -> Thm.thm
    val EQF_INTRO : Thm.thm -> Thm.thm
    val EQF_ELIM : Thm.thm -> Thm.thm
    val EXCLUDED_MIDDLE : Thm.thm
    val CCONTR : Thm.Term.term -> Thm.thm -> Thm.thm
    val INST : Thm.Term.term subst -> Thm.thm -> Thm.thm
    val NOT_F : Thm.thm
    val NOT_AND : Thm.thm
    val ISPEC : Thm.Term.term -> Thm.thm -> Thm.thm
    val ISPECL : Thm.Term.term list -> Thm.thm -> Thm.thm
    val SELECT_REFL : Thm.thm
    val SELECT_UNIQUE : Thm.thm
    val GEN_ALL : Thm.thm -> Thm.thm
    val DISCH_ALL : Thm.thm -> Thm.thm
    val UNDISCH_ALL : Thm.thm -> Thm.thm
    val SPEC_ALL : Thm.thm -> Thm.thm
    val PROVE_HYP : Thm.thm -> Thm.thm -> Thm.thm
    val CONJ_PAIR : Thm.thm -> Thm.thm * Thm.thm
    val LIST_CONJ : Thm.thm list -> Thm.thm
    val CONJ_LIST : int -> Thm.thm -> Thm.thm list
    val CONJUNCTS : Thm.thm -> Thm.thm list
    val BODY_CONJUNCTS : Thm.thm -> Thm.thm list
    val IMP_CANON : Thm.thm -> Thm.thm list
    val LIST_MP : Thm.thm list -> Thm.thm -> Thm.thm
    val CONTRAPOS : Thm.thm -> Thm.thm
    val DISJ_IMP : Thm.thm -> Thm.thm
    val IMP_ELIM : Thm.thm -> Thm.thm
    val NOT_CLAUSES : Thm.thm
    val DISJ_CASES_UNION : Thm.thm -> Thm.thm -> Thm.thm -> Thm.thm
  end
signature Drule_sig =
  sig
    structure Thm : ...
    val ADD_ASSUM : Thm.Term.term -> Thm.thm -> Thm.thm
    val UNDISCH : Thm.thm -> Thm.thm
    val SYM : Thm.thm -> Thm.thm
    val TRANS : Thm.thm -> Thm.thm -> Thm.thm
    val IMP_TRANS : Thm.thm -> Thm.thm -> Thm.thm
    val AP_TERM : Thm.Term.term -> Thm.thm -> Thm.thm
    val AP_THM : Thm.thm -> Thm.Term.term -> Thm.thm
    val EQ_MP : Thm.thm -> Thm.thm -> Thm.thm
    val EQ_IMP_RULE : Thm.thm -> Thm.thm * Thm.thm
    val TRUTH : Thm.thm
    val EQT_ELIM : Thm.thm -> Thm.thm
    val SPEC : Thm.Term.term -> Thm.thm -> Thm.thm
    val SPECL : Thm.Term.term list -> Thm.thm -> Thm.thm
    val EQT_INTRO : Thm.thm -> Thm.thm
    val GEN : Thm.Term.term -> Thm.thm -> Thm.thm
    val GENL : Thm.Term.term list -> Thm.thm -> Thm.thm
    val ETA_CONV : Thm.Term.term -> Thm.thm
    val EXT : Thm.thm -> Thm.thm
    val SELECT_INTRO : Thm.thm -> Thm.thm
    val SELECT_ELIM : Thm.thm -> Thm.Term.term * Thm.thm -> Thm.thm
    val EXISTS : Thm.Term.term * Thm.Term.term -> Thm.thm -> Thm.thm
    val disch : Thm.Term.term * Thm.Term.term list -> Thm.Term.term list
    val CHOOSE : Thm.Term.term * Thm.thm -> Thm.thm -> Thm.thm
    val SELECT_RULE : Thm.thm -> Thm.thm
    val IMP_ANTISYM_RULE : Thm.thm -> Thm.thm -> Thm.thm
    val SPEC_VAR : Thm.thm -> Thm.Term.term * Thm.thm
    val MK_EXISTS : Thm.thm -> Thm.thm
    val LIST_MK_EXISTS : Thm.Term.term list -> Thm.thm -> Thm.thm
    val FORALL_EQ : Thm.Term.term -> Thm.thm -> Thm.thm
    val EXISTS_EQ : Thm.Term.term -> Thm.thm -> Thm.thm
    val SELECT_EQ : Thm.Term.term -> Thm.thm -> Thm.thm
    val SUBS : Thm.thm list -> Thm.thm -> Thm.thm
    val SUBS_OCCS : (int list * Thm.thm) list -> Thm.thm -> Thm.thm
    val SUBST_CONV : {thm:Thm.thm, var:Thm.Term.term} list
                     -> Thm.Term.term -> Thm.Term.term -> Thm.thm
    val RIGHT_BETA : Thm.thm -> Thm.thm
    val LIST_BETA_CONV : Thm.Term.term -> Thm.thm
    val RIGHT_LIST_BETA : Thm.thm -> Thm.thm
    val AND_INTRO_THM : Thm.thm
    val CONJ : Thm.thm -> Thm.thm -> Thm.thm
    val AND1_THM : Thm.thm
    val CONJUNCT1 : Thm.thm -> Thm.thm
    val AND2_THM : Thm.thm
    val CONJUNCT2 : Thm.thm -> Thm.thm
    val CONJ_SYM : Thm.thm
    val CONJ_ASSOC : Thm.thm
    val CONJUNCTS_CONV : Thm.Term.term * Thm.Term.term -> Thm.thm
    val CONJ_SET_CONV : Thm.Term.term list -> Thm.Term.term list -> Thm.thm
    val FRONT_CONJ_CONV : Thm.Term.term list -> Thm.Term.term -> Thm.thm
    val CONJ_DISCH : Thm.Term.term -> Thm.thm -> Thm.thm
    val CONJ_DISCHL : Thm.Term.term list -> Thm.thm -> Thm.thm
    val OR_INTRO_THM1 : Thm.thm
    val DISJ1 : Thm.thm -> Thm.Term.term -> Thm.thm
    val OR_INTRO_THM2 : Thm.thm
    val DISJ2 : Thm.Term.term -> Thm.thm -> Thm.thm
    val OR_ELIM_THM : Thm.thm
    val DISJ_CASES : Thm.thm -> Thm.thm -> Thm.thm -> Thm.thm
    val FALSITY : Thm.thm
    val IMP_F : Thm.thm
    val NOT_INTRO : Thm.thm -> Thm.thm
    val NEG_DISCH : Thm.Term.term -> Thm.thm -> Thm.thm
    val F_IMP : Thm.thm
    val NOT_ELIM : Thm.thm -> Thm.thm
    val NOT_EQ_SYM : Thm.thm -> Thm.thm
    val AND_CLAUSES : Thm.thm
    val OR_CLAUSES : Thm.thm
    val IMP_CLAUSES : Thm.thm
    val CONTR : Thm.Term.term -> Thm.thm -> Thm.thm
    val EQF_INTRO : Thm.thm -> Thm.thm
    val EQF_ELIM : Thm.thm -> Thm.thm
    val EXCLUDED_MIDDLE : Thm.thm
    val CCONTR : Thm.Term.term -> Thm.thm -> Thm.thm
    val INST : Thm.Term.term subst -> Thm.thm -> Thm.thm
    val NOT_F : Thm.thm
    val NOT_AND : Thm.thm
    val ISPEC : Thm.Term.term -> Thm.thm -> Thm.thm
    val ISPECL : Thm.Term.term list -> Thm.thm -> Thm.thm
    val SELECT_REFL : Thm.thm
    val SELECT_UNIQUE : Thm.thm
    val GEN_ALL : Thm.thm -> Thm.thm
    val DISCH_ALL : Thm.thm -> Thm.thm
    val UNDISCH_ALL : Thm.thm -> Thm.thm
    val SPEC_ALL : Thm.thm -> Thm.thm
    val PROVE_HYP : Thm.thm -> Thm.thm -> Thm.thm
    val CONJ_PAIR : Thm.thm -> Thm.thm * Thm.thm
    val LIST_CONJ : Thm.thm list -> Thm.thm
    val CONJ_LIST : int -> Thm.thm -> Thm.thm list
    val CONJUNCTS : Thm.thm -> Thm.thm list
    val BODY_CONJUNCTS : Thm.thm -> Thm.thm list
    val IMP_CANON : Thm.thm -> Thm.thm list
    val LIST_MP : Thm.thm list -> Thm.thm -> Thm.thm
    val CONTRAPOS : Thm.thm -> Thm.thm
    val DISJ_IMP : Thm.thm -> Thm.thm
    val IMP_ELIM : Thm.thm -> Thm.thm
    val NOT_CLAUSES : Thm.thm
    val DISJ_CASES_UNION : Thm.thm -> Thm.thm -> Thm.thm -> Thm.thm
    val EQ_REFL : Thm.thm
    val REFL_CLAUSE : Thm.thm
    val EQ_SYM : Thm.thm
    val EQ_SYM_EQ : Thm.thm
    val EQ_EXT : Thm.thm
    val EQ_TRANS : Thm.thm
    val BOOL_EQ_DISTINCT : Thm.thm
    val EQ_CLAUSES : Thm.thm
    val MK_COMB : Thm.thm * Thm.thm -> Thm.thm
    val MK_ABS : Thm.thm -> Thm.thm
    val ALPHA_CONV : Thm.Term.term -> Thm.Term.term -> Thm.thm
    val ALPHA : Thm.Term.term -> Thm.Term.term -> Thm.thm
    val GEN_ALPHA_CONV : Thm.Term.term -> Thm.Term.term -> Thm.thm
    val COND_CLAUSES : Thm.thm
    val COND_ID : Thm.thm
    val IMP_CONJ : Thm.thm -> Thm.thm -> Thm.thm
    val EXISTS_IMP : Thm.Term.term -> Thm.thm -> Thm.thm
    val FORALL_SIMP : Thm.thm
    val EXISTS_SIMP : Thm.thm
    val ABS_SIMP : Thm.thm
  end
[opening /usr/groups/hol/hol90.7/solaris/src/1/drule.sml]
.../src/1/drule.sml:289.8-289.44 Warning: binding not exhaustive
          {Name="!",...} = ...

[Major collection... 54% used (3425536/6288364), 850 msec]

[Major collection... 53% used (3407432/6420704), 810 msec]

[Major collection... 56% used (3583860/6334916), 790 msec]
structure Drule1 : Drule1_sig

[Major collection... 48% used (3066120/6303076), 640 msec]

[Major collection... 57% used (3771152/6572596), 900 msec]

[Increasing heap to 12364k]

[Major collection... 64% used (4192584/6502392), 1000 msec]

[Increasing heap to 13456k]

[Major collection... 57% used (3987700/6949372), 1000 msec]

[Major collection... 58% used (4216104/7246184), 1060 msec]

[Increasing heap to 13484k]

[Major collection... 53% used (3935412/7295724), 1000 msec]

[Major collection... 56% used (4007980/7076972), 970 msec]

[Major collection... 60% used (4310496/7157360), 1080 msec]

[Increasing heap to 13520k]

[Major collection... 76% used (5321868/6997232), 1280 msec]

[Increasing heap to 15888k]

[Major collection... 61% used (5002368/8181816), 1200 msec]
structure Drule2 : Drule2_sig

[Major collection... 40% used (3352540/8286344), 720 msec]
structure Drule3 : Drule3_sig

[Major collection... 40% used (3410184/8339840), 730 msec]

[Major collection... 49% used (4223228/8554676), 1050 msec]

[Major collection... 47% used (3917672/8323120), 930 msec]
structure Drule : Drule_sig
structure Drule1 : sig  end
structure Drule2 : sig  end
structure Drule3 : sig  end
signature Drule1_sig = sig  end
signature Drule2_sig = sig  end
signature Drule3_sig = sig  end
[opening /usr/groups/hol/hol90.7/solaris/src/1/conv.sig]
signature Conv_sig =
  sig
    structure Thm : ...
    val INST_TY_TERM : Thm.Term.term subst * Thm.Term.Type.hol_type subst
                       -> Thm.thm -> Thm.thm
    val GSPEC : Thm.thm -> Thm.thm
    val PART_MATCH : (Thm.Term.term -> Thm.Term.term) -> Thm.thm -> conv
    val REWR_CONV : Thm.thm -> conv
    val MATCH_MP : Thm.thm -> Thm.thm -> Thm.thm
    val NO_CONV : conv
    val ALL_CONV : conv
    val THENC : conv * conv -> conv
    val ORELSEC : conv * conv -> conv
    val FIRST_CONV : conv list -> conv
    val EVERY_CONV : conv list -> conv
    val REPEATC : conv -> conv
    val CHANGED_CONV : conv -> conv
    val TRY_CONV : conv -> conv
    val SUB_CONV : conv -> conv
    val DEPTH_CONV : conv -> conv
    val REDEPTH_CONV : conv -> conv
    val TOP_DEPTH_CONV : conv -> conv
    val ONCE_DEPTH_CONV : conv -> conv
    val CONV_RULE : conv -> Thm.thm -> Thm.thm
    val CONV_TAC : conv -> tactic
    val BETA_RULE : Thm.thm -> Thm.thm
    val BETA_TAC : tactic
    val NOT_FORALL_CONV : conv
    val NOT_EXISTS_CONV : conv
    val EXISTS_NOT_CONV : conv
    val FORALL_NOT_CONV : conv
    val FORALL_AND_CONV : conv
    val EXISTS_OR_CONV : conv
    val AND_FORALL_CONV : conv
    val LEFT_AND_FORALL_CONV : conv
    val RIGHT_AND_FORALL_CONV : conv
    val OR_EXISTS_CONV : conv
    val LEFT_OR_EXISTS_CONV : conv
    val RIGHT_OR_EXISTS_CONV : conv
    val EXISTS_AND_CONV : conv
    val AND_EXISTS_CONV : conv
    val LEFT_AND_EXISTS_CONV : conv
    val RIGHT_AND_EXISTS_CONV : conv
    val FORALL_OR_CONV : conv
    val OR_FORALL_CONV : conv
    val LEFT_OR_FORALL_CONV : conv
    val RIGHT_OR_FORALL_CONV : conv
    val FORALL_IMP_CONV : conv
    val LEFT_IMP_EXISTS_CONV : conv
    val RIGHT_IMP_FORALL_CONV : conv
    val EXISTS_IMP_CONV : conv
    val LEFT_IMP_FORALL_CONV : conv
    val RIGHT_IMP_EXISTS_CONV : conv
    val X_SKOLEM_CONV : Thm.Term.term -> conv
    val SKOLEM_CONV : conv
    val SYM_CONV : conv
    val RIGHT_CONV_RULE : conv -> Thm.thm -> Thm.thm
    val FUN_EQ_CONV : conv
    val X_FUN_EQ_CONV : Thm.Term.term -> conv
    val SELECT_CONV : conv
    val CONTRAPOS_CONV : conv
    val ANTE_CONJ_CONV : conv
    val SWAP_EXISTS_CONV : conv
    val RAND_CONV : conv -> conv
    val RATOR_CONV : conv -> conv
    val ABS_CONV : conv -> conv
    val bool_EQ_CONV : conv
    val EXISTS_UNIQUE_CONV : conv
    val COND_CONV : conv
    val EXISTENCE : Thm.thm -> Thm.thm
    val AC_CONV : Thm.thm * Thm.thm -> conv
    val GSYM : Thm.thm -> Thm.thm
  end

[Major collection... 46% used (3815624/8197096), 810 msec]
[opening /usr/groups/hol/hol90.7/solaris/src/1/conv.sml]
.../src/1/conv.sml:1829.8-1829.41 Warning: binding not exhaustive
          (ox :: oy :: nil,imp) = ...
.../src/1/conv.sml:1779.1-1780.65 Warning: binding not exhaustive
          Tb :: bT :: _ = ...
.../src/1/conv.sml:1587.8-1587.76 Warning: binding not exhaustive
          {Args=ty1 :: _ :: nil,Tyop="fun"} = ...
.../src/1/conv.sml:590.15-590.43 Warning: match nonexhaustive
          nil => ...
  
.../src/1/conv.sml:591.23-591.52 Warning: match nonexhaustive
          th' :: nil => ...
  

[Major collection... 64% used (5502848/8526560), 1360 msec]

[Increasing heap to 17784k]

[Major collection... 65% used (6099560/9337588), 1440 msec]

[Increasing heap to 19012k]

[Major collection... 55% used (5511196/9942368), 1350 msec]

[Major collection... 55% used (5652828/10228268), 1370 msec]

[Major collection... 55% used (5490660/9942348), 1480 msec]

[Major collection... 54% used (5359980/9757096), 1330 msec]

[Major collection... 54% used (5598368/10294656), 1410 msec]

[Major collection... 57% used (5743232/10023312), 1450 msec]

[Major collection... 59% used (5924032/9977004), 1500 msec]

[Major collection... 56% used (5637020/10012188), 1430 msec]

[Major collection... 59% used (5963640/10015576), 1530 msec]

[Increasing heap to 19176k]

[Major collection... 48% used (5004056/10326556), 1240 msec]

[Major collection... 55% used (5615112/10056476), 1410 msec]

[Major collection... 65% used (6529932/9930256), 1550 msec]

[Increasing heap to 19696k]

[Major collection... 54% used (5614532/10343428), 1410 msec]

[Major collection... 75% used (7649992/10093752), 1810 msec]

[Increasing heap to 22784k]

[Major collection... 77% used (9002220/11689828), 2050 msec]

[Increasing heap to 26540k]
structure Conv : Conv_sig
[opening /usr/groups/hol/hol90.7/solaris/src/1/tactical.sig]
signature Tactical_sig =
  sig
    structure Thm : ...
    val TAC_PROOF : goal * tactic -> Thm.thm
    val prove : Thm.Term.term * tactic -> Thm.thm
    val store_thm : string * Thm.Term.term * tactic -> Thm.thm
    val ASSUM_LIST : (Thm.thm list -> tactic) -> tactic
    val POP_ASSUM : thm_tactic -> tactic
    val POP_ASSUM_LIST : (Thm.thm list -> tactic) -> tactic
    val THEN : tactic * tactic -> tactic
    val THENL : tactic * tactic list -> tactic
    val ORELSE : tactic * tactic -> tactic
    val FAIL_TAC : string -> goal -> 'a
    val NO_TAC : goal -> 'a
    val ALL_TAC : tactic
    val TRY : tactic -> tactic
    val REPEAT : tactic -> tactic
    val VALID : tactic -> tactic
    val EVERY : tactic list -> tactic
    val FIRST : tactic list -> tactic
    val MAP_EVERY : ('a -> tactic) -> 'a list -> tactic
    val MAP_FIRST : ('a -> tactic) -> 'a list -> tactic
    val EVERY_ASSUM : thm_tactic -> tactic
    val FIRST_ASSUM : thm_tactic -> tactic
    val SUBGOAL_THEN : Thm.Term.term -> thm_tactic -> tactic
    val CHANGED_TAC : tactic -> tactic
  end
[opening /usr/groups/hol/hol90.7/solaris/src/1/tactical.sml]
.../src/1/tactical.sml:279.20-279.63 Warning: match nonexhaustive
          tha :: thl => ...
  
.../src/1/tactical.sml:142.20-142.30 Warning: match nonexhaustive
          nil => ...
  
.../src/1/tactical.sml:133.44-133.54 Warning: match nonexhaustive
          nil => ...
  
.../src/1/tactical.sml:98.44-98.54 Warning: match nonexhaustive
          nil => ...
  
.../src/1/tactical.sml:104.32-104.42 Warning: match nonexhaustive
          nil => ...
  
.../src/1/tactical.sml:49.24-54.10 Warning: match nonexhaustive
          (nil,_,_) => ...
          (n1 :: nums,f1 :: funcs,args) => ...
  
.../src/1/tactical.sml:43.16-43.47 Warning: match nonexhaustive
          (thfun : thm_tactic,(assum :: asl,w) : goal) => ...
  
structure Tactical : Tactical_sig
[opening /usr/groups/hol/hol90.7/solaris/src/1/rewrite.sig]
signature Rewrite_sig =
  sig
    structure Base_logic : ...
    type rewrites
    val empty_rewrites : rewrites
    val add_rewrites : rewrites -> Base_logic.Thm.thm list -> rewrites
    val set_base_rewrites : rewrites -> unit
    val base_rewrites : unit -> rewrites
    val add_base_rewrites : Base_logic.Thm.thm list -> unit
    val pp_rewrites : System.PrettyPrint.ppstream -> rewrites -> unit
    val REWRITES_CONV : rewrites -> conv
    val GEN_REWRITE_CONV : (conv -> conv)
                           -> rewrites -> Base_logic.Thm.thm list -> conv
    val GEN_REWRITE_RULE : (conv -> conv)
                           -> rewrites
                              -> Base_logic.Thm.thm list
                                 -> Base_logic.Thm.thm -> Base_logic.Thm.thm
    val GEN_REWRITE_TAC : (conv -> conv)
                          -> rewrites -> Base_logic.Thm.thm list -> tactic
    val PURE_REWRITE_CONV : Base_logic.Thm.thm list -> conv
    val REWRITE_CONV : Base_logic.Thm.thm list -> conv
    val PURE_ONCE_REWRITE_CONV : Base_logic.Thm.thm list -> conv
    val ONCE_REWRITE_CONV : Base_logic.Thm.thm list -> conv
    val PURE_REWRITE_RULE : Base_logic.Thm.thm list
                            -> Base_logic.Thm.thm -> Base_logic.Thm.thm
    val REWRITE_RULE : Base_logic.Thm.thm list
                       -> Base_logic.Thm.thm -> Base_logic.Thm.thm
    val PURE_ONCE_REWRITE_RULE : Base_logic.Thm.thm list
                                 -> Base_logic.Thm.thm -> Base_logic.Thm.thm
    val ONCE_REWRITE_RULE : Base_logic.Thm.thm list
                            -> Base_logic.Thm.thm -> Base_logic.Thm.thm
    val PURE_ASM_REWRITE_RULE : Base_logic.Thm.thm list
                                -> Base_logic.Thm.thm -> Base_logic.Thm.thm
    val ASM_REWRITE_RULE : Base_logic.Thm.thm list
                           -> Base_logic.Thm.thm -> Base_logic.Thm.thm
    val PURE_ONCE_ASM_REWRITE_RULE : Base_logic.Thm.thm list
                                     -> Base_logic.Thm.thm
                                        -> Base_logic.Thm.thm
    val ONCE_ASM_REWRITE_RULE : Base_logic.Thm.thm list
                                -> Base_logic.Thm.thm -> Base_logic.Thm.thm
    val PURE_REWRITE_TAC : Base_logic.Thm.thm list -> tactic
    val REWRITE_TAC : Base_logic.Thm.thm list -> tactic
    val PURE_ONCE_REWRITE_TAC : Base_logic.Thm.thm list -> tactic
    val ONCE_REWRITE_TAC : Base_logic.Thm.thm list -> tactic
    val PURE_ASM_REWRITE_TAC : Base_logic.Thm.thm list -> tactic
    val ASM_REWRITE_TAC : Base_logic.Thm.thm list -> tactic
    val PURE_ONCE_ASM_REWRITE_TAC : Base_logic.Thm.thm list -> tactic
    val ONCE_ASM_REWRITE_TAC : Base_logic.Thm.thm list -> tactic
    val FILTER_PURE_ASM_REWRITE_RULE : (Base_logic.Net.Term.term -> bool)
                                       -> Base_logic.Thm.thm list
                                          -> Base_logic.Thm.thm
                                             -> Base_logic.Thm.thm
    val FILTER_ASM_REWRITE_RULE : (Base_logic.Net.Term.term -> bool)
                                  -> Base_logic.Thm.thm list
                                     -> Base_logic.Thm.thm
                                        -> Base_logic.Thm.thm
    val FILTER_PURE_ONCE_ASM_REWRITE_RULE : (Base_logic.Net.Term.term -> bool)
                                            -> Base_logic.Thm.thm list
                                               -> Base_logic.Thm.thm
                                                  -> Base_logic.Thm.thm
    val FILTER_ONCE_ASM_REWRITE_RULE : (Base_logic.Net.Term.term -> bool)
                                       -> Base_logic.Thm.thm list
                                          -> Base_logic.Thm.thm
                                             -> Base_logic.Thm.thm
    val FILTER_PURE_ASM_REWRITE_TAC : (Base_logic.Net.Term.term -> bool)
                                      -> Base_logic.Thm.thm list -> tactic
    val FILTER_ASM_REWRITE_TAC : (Base_logic.Net.Term.term -> bool)
                                 -> Base_logic.Thm.thm list -> tactic
    val FILTER_PURE_ONCE_ASM_REWRITE_TAC : (Base_logic.Net.Term.term -> bool)
                                           -> Base_logic.Thm.thm list -> tactic
    val FILTER_ONCE_ASM_REWRITE_TAC : (Base_logic.Net.Term.term -> bool)
                                      -> Base_logic.Thm.thm list -> tactic
    val SUBST_MATCH : Base_logic.Thm.thm
                      -> Base_logic.Thm.thm -> Base_logic.Thm.thm
  end

[Major collection... 29% used (4042468/13628560), 830 msec]

[Decreasing heap to 12400k]
[opening /usr/groups/hol/hol90.7/solaris/src/1/rewrite.sml]
structure Rewrite : Rewrite_sig
[opening /usr/groups/hol/hol90.7/solaris/src/1/thm_cont.sig]
signature Thm_cont_sig =
  sig
    structure Thm : ...
    val THEN_TCL : thm_tactical * thm_tactical -> thm_tactical
    val ORELSE_TCL : thm_tactical * thm_tactical -> thm_tactical
    val REPEAT_TCL : thm_tactical -> thm_tactical
    val REPEAT_GTCL : thm_tactical -> (Thm.thm -> tactic) -> thm_tactic
    val ALL_THEN : thm_tactical
    val NO_THEN : thm_tactical
    val EVERY_TCL : thm_tactical list -> thm_tactical
    val FIRST_TCL : thm_tactical list -> thm_tactical
    val CONJUNCTS_THEN2 : thm_tactic -> thm_tactical
    val CONJUNCTS_THEN : thm_tactical
    val DISJ_CASES_THEN2 : thm_tactic -> thm_tactical
    val DISJ_CASES_THEN : thm_tactical
    val DISJ_CASES_THENL : thm_tactic list -> thm_tactic
    val DISCH_THEN : thm_tactic -> tactic
    val X_CHOOSE_THEN : Thm.Term.term -> thm_tactical
    val CHOOSE_THEN : thm_tactical
    val X_CASES_THENL : (('a list -> 'b list -> ('a * 'b) list)
                         -> thm_tactic list
                            -> (Thm.Term.term list * thm_tactic) list)
                        -> thm_tactic list -> thm_tactic
    val X_CASES_THEN : Thm.Term.term list list -> thm_tactical
    val CASES_THENL : thm_tactic list -> thm_tactic
    val STRIP_THM_THEN : thm_tactical
  end

[Major collection... 61% used (3909900/6366716), 780 msec]
[opening /usr/groups/hol/hol90.7/solaris/src/1/thm_cont.sml]
structure Thm_cont : Thm_cont_sig
[opening /usr/groups/hol/hol90.7/solaris/src/1/tactic.sig]
signature Tactic_sig =
  sig
    structure Thm : ...
    val ACCEPT_TAC : thm_tactic
    val DISCARD_TAC : Thm.thm -> tactic
    val CONTR_TAC : thm_tactic
    val CCONTR_TAC : tactic
    val ASSUME_TAC : thm_tactic
    val FREEZE_THEN : thm_tactical
    val CONJ_TAC : tactic
    val DISJ1_TAC : tactic
    val DISJ2_TAC : tactic
    val MP_TAC : thm_tactic
    val EQ_TAC : tactic
    val X_GEN_TAC : Thm.Term.term -> tactic
    val GEN_TAC : tactic
    val SPEC_TAC : Thm.Term.term * Thm.Term.term -> tactic
    val EXISTS_TAC : Thm.Term.term -> tactic
    val GSUBST_TAC : (Thm.Term.term subst -> Thm.Term.term -> Thm.Term.term)
                     -> Thm.thm list -> tactic
    val SUBST_TAC : Thm.thm list -> tactic
    val SUBST_OCCS_TAC : (int list * Thm.thm) list -> tactic
    val SUBST1_TAC : Thm.thm -> tactic
    val RULE_ASSUM_TAC : (Thm.thm -> Thm.thm) -> tactic
    val SUBST_ALL_TAC : Thm.thm -> tactic
    val CHECK_ASSUME_TAC : thm_tactic
    val STRIP_ASSUME_TAC : thm_tactic
    val STRUCT_CASES_TAC : thm_tactic
    val COND_CASES_TAC : tactic
    val BOOL_CASES_TAC : Thm.Term.term -> tactic
    val STRIP_GOAL_THEN : thm_tactic -> tactic
    val FILTER_GEN_TAC : Thm.Term.term -> tactic
    val FILTER_DISCH_THEN : thm_tactic -> Thm.Term.term -> tactic
    val FILTER_STRIP_THEN : thm_tactic -> Thm.Term.term -> tactic
    val DISCH_TAC : tactic
    val DISJ_CASES_TAC : thm_tactic
    val CHOOSE_TAC : thm_tactic
    val X_CHOOSE_TAC : Thm.Term.term -> thm_tactic
    val STRIP_TAC : tactic
    val FILTER_DISCH_TAC : Thm.Term.term -> tactic
    val FILTER_STRIP_TAC : Thm.Term.term -> tactic
    val ASM_CASES_TAC : Thm.Term.term -> tactic
    val REFL_TAC : tactic
    val UNDISCH_TAC : Thm.Term.term -> tactic
    val AP_TERM_TAC : tactic
    val AP_THM_TAC : tactic
  end
[opening /usr/groups/hol/hol90.7/solaris/src/1/tactic.sml]
.../src/1/tactic.sml:279.41-279.75 Warning: match nonexhaustive
          th :: nil => ...
  
.../src/1/tactic.sml:255.6-255.37 Warning: match nonexhaustive
          th :: nil => ...
  
.../src/1/tactic.sml:241.6-241.31 Warning: match nonexhaustive
          th :: nil => ...
  
.../src/1/tactic.sml:210.29-210.54 Warning: match nonexhaustive
          th :: nil => ...
  
.../src/1/tactic.sml:212.14-216.27 Warning: match nonexhaustive
          th :: nil => ...
  
.../src/1/tactic.sml:167.5-167.50 Warning: match nonexhaustive
          th1 :: th2 :: nil => ...
  
.../src/1/tactic.sml:159.5-159.34 Warning: match nonexhaustive
          thimp :: nil => ...
  
.../src/1/tactic.sml:145.20-145.52 Warning: match nonexhaustive
          thb :: nil => ...
  
.../src/1/tactic.sml:131.21-131.53 Warning: match nonexhaustive
          tha :: nil => ...
  
.../src/1/tactic.sml:115.33-115.66 Warning: match nonexhaustive
          th1 :: th2 :: nil => ...
  
.../src/1/tactic.sml:90.6-90.38 Warning: match nonexhaustive
          th :: nil => ...
  
.../src/1/tactic.sml:77.34-77.61 Warning: match nonexhaustive
          th :: nil => ...
  
.../src/1/tactic.sml:62.9-62.19 Warning: match nonexhaustive
          nil => ...
  
.../src/1/tactic.sml:35.14-35.24 Warning: match nonexhaustive
          nil => ...
  

[Major collection... 62% used (4151972/6619848), 840 msec]

[Increasing heap to 13012k]

[Major collection... 62% used (4219856/6709756), 860 msec]

[Increasing heap to 13180k]

[Major collection... 62% used (4367968/6985360), 920 msec]

[Increasing heap to 13876k]

[Major collection... 58% used (4170812/7086332), 870 msec]
structure Tactic : Tactic_sig
[opening /usr/groups/hol/hol90.7/solaris/src/1/taut_thms.sig]
signature Taut_thms_sig =
  sig
    structure Thm : ...
    val OR_IMP_THM : Thm.thm
    val NOT_IMP : Thm.thm
    val DISJ_ASSOC : Thm.thm
    val DISJ_SYM : Thm.thm
    val DE_MORGAN_THM : Thm.thm
    val LEFT_AND_OVER_OR : Thm.thm
    val RIGHT_AND_OVER_OR : Thm.thm
    val LEFT_OR_OVER_AND : Thm.thm
    val RIGHT_OR_OVER_AND : Thm.thm
    val IMP_DISJ_THM : Thm.thm
    val IMP_F_EQ_F : Thm.thm
    val AND_IMP_INTRO : Thm.thm
    val EQ_IMP_THM : Thm.thm
    val EQ_EXPAND : Thm.thm
    val COND_RATOR : Thm.thm
    val COND_RAND : Thm.thm
    val COND_ABS : Thm.thm
    val COND_EXPAND : Thm.thm
  end

[Major collection... 57% used (4399996/7602936), 1030 msec]

[Increasing heap to 15268k]
[opening /usr/groups/hol/hol90.7/solaris/src/1/taut_thms.sml]
structure Taut_thms : Taut_thms_sig
[opening /usr/groups/hol/hol90.7/solaris/src/1/resolve.sig]
signature Resolve_sig =
  sig
    structure Thm : ...
    val MATCH_ACCEPT_TAC : thm_tactic
    val ANTE_RES_THEN : thm_tactical
    val RES_CANON : Thm.thm -> Thm.thm list
    val IMP_RES_THEN : thm_tactic -> Thm.thm -> tactic
    val RES_THEN : thm_tactic -> tactic
    val IMP_RES_TAC : thm_tactic
    val RES_TAC : tactic
    val MATCH_MP_TAC : thm_tactic
  end

[Major collection... 50% used (3952040/7835208), 750 msec]
[opening /usr/groups/hol/hol90.7/solaris/src/1/resolve.sml]
structure Resolve : Resolve_sig
[opening /usr/groups/hol/hol90.7/solaris/src/1/type_def_support.sig]
signature Type_def_support_sig =
  sig
    structure Thm : ...
    val ABS_REP_THM : Thm.thm
    val define_new_type_bijections : {ABS:string, REP:string, name:string,
                                      tyax:Thm.thm}
                                     -> Thm.thm
    val prove_rep_fn_one_one : Thm.thm -> Thm.thm
    val prove_rep_fn_onto : Thm.thm -> Thm.thm
    val prove_abs_fn_onto : Thm.thm -> Thm.thm
    val prove_abs_fn_one_one : Thm.thm -> Thm.thm
  end

[Major collection... 50% used (4005720/7900636), 770 msec]
[opening /usr/groups/hol/hol90.7/solaris/src/1/type_def_support.sml]
.../src/1/type_def_support.sml:305.8-305.35 Warning: binding not exhaustive
          th1 :: th2 :: nil = ...
.../src/1/type_def_support.sml:263.8-263.35 Warning: binding not exhaustive
          th1 :: th2 :: nil = ...
.../src/1/type_def_support.sml:221.8-221.35 Warning: binding not exhaustive
          th1 :: th2 :: nil = ...
.../src/1/type_def_support.sml:185.8-185.62 Warning: binding not exhaustive
          {Args=aty :: rty :: nil,...} = ...
.../src/1/type_def_support.sml:141.33-142.76 Warning: binding not exhaustive
          {Args=a :: r :: nil,...} = ...
.../src/1/type_def_support.sml:138.33-140.75 Warning: binding not exhaustive
          (_,P :: rep :: nil) = ...

[Major collection... 54% used (4306216/7875152), 860 msec]
structure Type_def_support : Type_def_support_sig
[opening /usr/groups/hol/hol90.7/solaris/src/1/induct_then.sig]
signature Induct_then_sig =
  sig
    structure Thm : ...
    val INDUCT_THEN : Thm.thm -> thm_tactic -> tactic
  end
[opening /usr/groups/hol/hol90.7/solaris/src/1/induct_then.sml]
.../src/1/induct_then.sml:257.8-257.40 Warning: binding not exhaustive
          (asm :: nil,con) = ...
.../src/1/induct_then.sml:237.24-242.10 Warning: match nonexhaustive
          (nil,_,_) => ...
          (n1 :: nums,f1 :: funcs,args) => ...
  
.../src/1/induct_then.sml:77.5-77.64 Warning: match nonexhaustive
          th :: nil => ...
  

[Major collection... 56% used (4438232/7794464), 870 msec]
structure Induct_then : Induct_then_sig
[opening /usr/groups/hol/hol90.7/solaris/src/1/prim_rec.sig]
signature Prim_rec_sig =
  sig
    structure Thm : ...
    val prove_rec_fn_exists : Thm.thm -> Thm.Term.term -> Thm.thm
    val new_recursive_definition : {def:Thm.Term.term, fixity:Thm.Term.fixity,
                                    name:string, rec_axiom:Thm.thm}
                                   -> Thm.thm
  end
[opening /usr/groups/hol/hol90.7/solaris/src/1/prim_rec.sml]
.../src/1/prim_rec.sml:144.8-144.74 Warning: binding not exhaustive
          lcl :: lclvars = ...
.../src/1/prim_rec.sml:76.8-85.22 Warning: match nonexhaustive
          h :: t => ...
  

[Major collection... 57% used (4543496/7877856), 980 msec]

[Major collection... 59% used (4687004/7916080), 1020 msec]

[Major collection... 57% used (4505336/7786536), 950 msec]
structure Prim_rec : Prim_rec_sig
[opening /usr/groups/hol/hol90.7/solaris/src/1/hol1.sml]
structure Hol1 :
  sig
    structure Base_logic : Base_logic_sig
    structure Conv : Conv_sig
    structure Drule : Drule_sig
    structure Exception : Exception_sig
    structure Globals : Globals_sig
    structure Induct_then : Induct_then_sig
    structure Lib : Lib_sig
    structure Prim_rec : Prim_rec_sig
    structure Resolve : Resolve_sig
    structure Rewrite : Rewrite_sig
    structure Tactic : Tactic_sig
    structure Tactical : Tactical_sig
    structure Taut_thms : Taut_thms_sig
    structure Term_io : Term_io_sig
    structure Thm_cont : Thm_cont_sig
    structure Type_def_support : Type_def_support_sig
  end
open Hol1
structure Exception : Exception_sig
structure Term_io : Term_io_sig
structure Induct_then : Induct_then_sig
structure Globals : Globals_sig
structure Thm_cont : Thm_cont_sig
structure Rewrite : Rewrite_sig
structure Conv : Conv_sig
structure Type_def_support : Type_def_support_sig
structure Tactic : Tactic_sig
structure Resolve : Resolve_sig
structure Drule : Drule_sig
structure Base_logic : Base_logic_sig
structure Taut_thms : Taut_thms_sig
structure Tactical : Tactical_sig
structure Lib : Lib_sig
structure Prim_rec : Prim_rec_sig
open Save_hol
val print_banner = fn : string -> unit
val save_hol = fn : string -> unit
open Prim_rec
structure Thm : Thm_sig
val prove_rec_fn_exists = fn : thm -> term -> thm
val new_recursive_definition = fn
  : {def:term, fixity:fixity, name:string, rec_axiom:thm} -> thm
open Induct_then
structure Thm : Thm_sig
val INDUCT_THEN = fn : thm -> thm_tactic -> tactic
open Type_def_support
structure Thm : Thm_sig
val ABS_REP_THM =
  |- !P.
       (?rep. TYPE_DEFINITION P rep) ==>
       (?rep abs. (!a. abs (rep a) = a) /\ (!r. P r = rep (abs r) = r)) : thm
val define_new_type_bijections = fn
  : {ABS:string, REP:string, name:string, tyax:thm} -> thm
val prove_rep_fn_one_one = fn : thm -> thm
val prove_rep_fn_onto = fn : thm -> thm
val prove_abs_fn_onto = fn : thm -> thm
val prove_abs_fn_one_one = fn : thm -> thm
open Resolve
structure Thm : Thm_sig
val MATCH_ACCEPT_TAC = fn : thm_tactic
val ANTE_RES_THEN = fn : thm_tactical
val RES_CANON = fn : thm -> thm list
val IMP_RES_THEN = fn : thm_tactic -> thm -> tactic
val RES_THEN = fn : thm_tactic -> tactic
val IMP_RES_TAC = fn : thm_tactic
val RES_TAC = fn : tactic
val MATCH_MP_TAC = fn : thm_tactic
open Taut_thms
structure Thm : Thm_sig
val OR_IMP_THM = |- !A B. (A = B \/ A) = B ==> A : thm
val NOT_IMP = |- !A B. ~(A ==> B) = A /\ ~B : thm
val DISJ_ASSOC = |- !A B C. A \/ B \/ C = (A \/ B) \/ C : thm
val DISJ_SYM = |- !A B. A \/ B = B \/ A : thm
val DE_MORGAN_THM = |- !A B. (~(A /\ B) = ~A \/ ~B) /\ (~(A \/ B) = ~A /\ ~B)
  : thm
val LEFT_AND_OVER_OR = |- !A B C. A /\ (B \/ C) = A /\ B \/ A /\ C : thm
val RIGHT_AND_OVER_OR = |- !A B C. (B \/ C) /\ A = B /\ A \/ C /\ A : thm
val LEFT_OR_OVER_AND = |- !A B C. A \/ B /\ C = (A \/ B) /\ (A \/ C) : thm
val RIGHT_OR_OVER_AND = |- !A B C. B /\ C \/ A = (B \/ A) /\ (C \/ A) : thm
val IMP_DISJ_THM = |- !A B. A ==> B = ~A \/ B : thm
val IMP_F_EQ_F = |- !t. t ==> F = t = F : thm
val AND_IMP_INTRO = |- !t1 t2 t3. t1 ==> t2 ==> t3 = t1 /\ t2 ==> t3 : thm
val EQ_IMP_THM = |- !t1 t2. (t1 = t2) = (t1 ==> t2) /\ (t2 ==> t1) : thm
val EQ_EXPAND = |- !t1 t2. (t1 = t2) = t1 /\ t2 \/ ~t1 /\ ~t2 : thm
val COND_RATOR = |- !b f g x. (b => f | g) x = (b => (f x) | (g x)) : thm
val COND_RAND = |- !f b x y. f (b => x | y) = (b => (f x) | (f y)) : thm
val COND_ABS = |- !b f g. (\x. b => (f x) | (g x)) = (b => f | g) : thm
val COND_EXPAND = |- !b t1 t2. (b => t1 | t2) = (~b \/ t1) /\ (b \/ t2) : thm
open Tactic
structure Thm : Thm_sig
val ACCEPT_TAC = fn : thm_tactic
val DISCARD_TAC = fn : thm -> tactic
val CONTR_TAC = fn : thm_tactic
val CCONTR_TAC = fn : tactic
val ASSUME_TAC = fn : thm_tactic
val FREEZE_THEN = fn : thm_tactical
val CONJ_TAC = fn : tactic
val DISJ1_TAC = fn : tactic
val DISJ2_TAC = fn : tactic
val MP_TAC = fn : thm_tactic
val EQ_TAC = fn : tactic
val X_GEN_TAC = fn : term -> tactic
val GEN_TAC = fn : tactic
val SPEC_TAC = fn : term * term -> tactic
val EXISTS_TAC = fn : term -> tactic
val GSUBST_TAC = fn : (term subst -> term -> term) -> thm list -> tactic
val SUBST_TAC = fn : thm list -> tactic
val SUBST_OCCS_TAC = fn : (int list * thm) list -> tactic
val SUBST1_TAC = fn : thm -> tactic
val RULE_ASSUM_TAC = fn : (thm -> thm) -> tactic
val SUBST_ALL_TAC = fn : thm -> tactic
val CHECK_ASSUME_TAC = fn : thm_tactic
val STRIP_ASSUME_TAC = fn : thm_tactic
val STRUCT_CASES_TAC = fn : thm_tactic
val COND_CASES_TAC = fn : tactic
val BOOL_CASES_TAC = fn : term -> tactic
val STRIP_GOAL_THEN = fn : thm_tactic -> tactic
val FILTER_GEN_TAC = fn : term -> tactic
val FILTER_DISCH_THEN = fn : thm_tactic -> term -> tactic
val FILTER_STRIP_THEN = fn : thm_tactic -> term -> tactic
val DISCH_TAC = fn : tactic
val DISJ_CASES_TAC = fn : thm_tactic
val CHOOSE_TAC = fn : thm_tactic
val X_CHOOSE_TAC = fn : term -> thm_tactic
val STRIP_TAC = fn : tactic
val FILTER_DISCH_TAC = fn : term -> tactic
val FILTER_STRIP_TAC = fn : term -> tactic
val ASM_CASES_TAC = fn : term -> tactic
val REFL_TAC = fn : tactic
val UNDISCH_TAC = fn : term -> tactic
val AP_TERM_TAC = fn : tactic
val AP_THM_TAC = fn : tactic
open Thm_cont
structure Thm : Thm_sig
val THEN_TCL = fn : thm_tactical * thm_tactical -> thm_tactical
val ORELSE_TCL = fn : thm_tactical * thm_tactical -> thm_tactical
val REPEAT_TCL = fn : thm_tactical -> thm_tactical
val REPEAT_GTCL = fn : thm_tactical -> (thm -> tactic) -> thm_tactic
val ALL_THEN = fn : thm_tactical
val NO_THEN = fn : thm_tactical
val EVERY_TCL = fn : thm_tactical list -> thm_tactical
val FIRST_TCL = fn : thm_tactical list -> thm_tactical
val CONJUNCTS_THEN2 = fn : thm_tactic -> thm_tactical
val CONJUNCTS_THEN = fn : thm_tactical
val DISJ_CASES_THEN2 = fn : thm_tactic -> thm_tactical
val DISJ_CASES_THEN = fn : thm_tactical
val DISJ_CASES_THENL = fn : thm_tactic list -> thm_tactic
val DISCH_THEN = fn : thm_tactic -> tactic
val X_CHOOSE_THEN = fn : term -> thm_tactical
val CHOOSE_THEN = fn : thm_tactical
val X_CASES_THENL = fn
  : (('a list -> 'b list -> ('a * 'b) list)
     -> thm_tactic list -> (term list * thm_tactic) list)
    -> thm_tactic list -> thm_tactic
val X_CASES_THEN = fn : term list list -> thm_tactical
val CASES_THENL = fn : thm_tactic list -> thm_tactic
val STRIP_THM_THEN = fn : thm_tactical
infix THEN_TCL
infix ORELSE_TCL
open Rewrite
structure Base_logic : Base_logic_sig
val empty_rewrites = - : rewrites
val add_rewrites = fn : rewrites -> thm list -> rewrites
val set_base_rewrites = fn : rewrites -> unit
val base_rewrites = fn : unit -> rewrites
val add_base_rewrites = fn : thm list -> unit
val pp_rewrites = fn : System.PrettyPrint.ppstream -> rewrites -> unit
val REWRITES_CONV = fn : rewrites -> conv
val GEN_REWRITE_CONV = fn : (conv -> conv) -> rewrites -> thm list -> conv
val GEN_REWRITE_RULE = fn
  : (conv -> conv) -> rewrites -> thm list -> thm -> thm
val GEN_REWRITE_TAC = fn : (conv -> conv) -> rewrites -> thm list -> tactic
val PURE_REWRITE_CONV = fn : thm list -> conv
val REWRITE_CONV = fn : thm list -> conv
val PURE_ONCE_REWRITE_CONV = fn : thm list -> conv
val ONCE_REWRITE_CONV = fn : thm list -> conv
val PURE_REWRITE_RULE = fn : thm list -> thm -> thm
val REWRITE_RULE = fn : thm list -> thm -> thm
val PURE_ONCE_REWRITE_RULE = fn : thm list -> thm -> thm
val ONCE_REWRITE_RULE = fn : thm list -> thm -> thm
val PURE_ASM_REWRITE_RULE = fn : thm list -> thm -> thm
val ASM_REWRITE_RULE = fn : thm list -> thm -> thm
val PURE_ONCE_ASM_REWRITE_RULE = fn : thm list -> thm -> thm
val ONCE_ASM_REWRITE_RULE = fn : thm list -> thm -> thm
val PURE_REWRITE_TAC = fn : thm list -> tactic
val REWRITE_TAC = fn : thm list -> tactic
val PURE_ONCE_REWRITE_TAC = fn : thm list -> tactic
val ONCE_REWRITE_TAC = fn : thm list -> tactic
val PURE_ASM_REWRITE_TAC = fn : thm list -> tactic
val ASM_REWRITE_TAC = fn : thm list -> tactic
val PURE_ONCE_ASM_REWRITE_TAC = fn : thm list -> tactic
val ONCE_ASM_REWRITE_TAC = fn : thm list -> tactic
val FILTER_PURE_ASM_REWRITE_RULE = fn
  : (term -> bool) -> thm list -> thm -> thm
val FILTER_ASM_REWRITE_RULE = fn : (term -> bool) -> thm list -> thm -> thm
val FILTER_PURE_ONCE_ASM_REWRITE_RULE = fn
  : (term -> bool) -> thm list -> thm -> thm
val FILTER_ONCE_ASM_REWRITE_RULE = fn
  : (term -> bool) -> thm list -> thm -> thm
val FILTER_PURE_ASM_REWRITE_TAC = fn : (term -> bool) -> thm list -> tactic
val FILTER_ASM_REWRITE_TAC = fn : (term -> bool) -> thm list -> tactic
val FILTER_PURE_ONCE_ASM_REWRITE_TAC = fn
  : (term -> bool) -> thm list -> tactic
val FILTER_ONCE_ASM_REWRITE_TAC = fn : (term -> bool) -> thm list -> tactic
val SUBST_MATCH = fn : thm -> thm -> thm
open Tactical
structure Thm : Thm_sig
val TAC_PROOF = fn : goal * tactic -> thm
val prove = fn : term * tactic -> thm
val store_thm = fn : string * term * tactic -> thm
val ASSUM_LIST = fn : (thm list -> tactic) -> tactic
val POP_ASSUM = fn : thm_tactic -> tactic
val POP_ASSUM_LIST = fn : (thm list -> tactic) -> tactic
val THEN = fn : tactic * tactic -> tactic
val THENL = fn : tactic * tactic list -> tactic
val ORELSE = fn : tactic * tactic -> tactic
val FAIL_TAC = fn : string -> goal -> 'a
val NO_TAC = fn : goal -> 'a
val ALL_TAC = fn : tactic
val TRY = fn : tactic -> tactic
val REPEAT = fn : tactic -> tactic
val VALID = fn : tactic -> tactic
val EVERY = fn : tactic list -> tactic
val FIRST = fn : tactic list -> tactic
val MAP_EVERY = fn : ('a -> tactic) -> 'a list -> tactic
val MAP_FIRST = fn : ('a -> tactic) -> 'a list -> tactic
val EVERY_ASSUM = fn : thm_tactic -> tactic
val FIRST_ASSUM = fn : thm_tactic -> tactic
val SUBGOAL_THEN = fn : term -> thm_tactic -> tactic
val CHANGED_TAC = fn : tactic -> tactic
infix THEN
infix THENL
infix ORELSE
open Conv
structure Thm : Thm_sig
val INST_TY_TERM = fn : term subst * hol_type subst -> thm -> thm
val GSPEC = fn : thm -> thm
val PART_MATCH = fn : (term -> term) -> thm -> conv
val REWR_CONV = fn : thm -> conv
val MATCH_MP = fn : thm -> thm -> thm
val NO_CONV = fn : conv
val ALL_CONV = fn : conv
val THENC = fn : conv * conv -> conv
val ORELSEC = fn : conv * conv -> conv
val FIRST_CONV = fn : conv list -> conv
val EVERY_CONV = fn : conv list -> conv
val REPEATC = fn : conv -> conv
val CHANGED_CONV = fn : conv -> conv
val TRY_CONV = fn : conv -> conv
val SUB_CONV = fn : conv -> conv
val DEPTH_CONV = fn : conv -> conv
val REDEPTH_CONV = fn : conv -> conv
val TOP_DEPTH_CONV = fn : conv -> conv
val ONCE_DEPTH_CONV = fn : conv -> conv
val CONV_RULE = fn : conv -> thm -> thm
val CONV_TAC = fn : conv -> tactic
val BETA_RULE = fn : thm -> thm
val BETA_TAC = fn : tactic
val NOT_FORALL_CONV = fn : conv
val NOT_EXISTS_CONV = fn : conv
val EXISTS_NOT_CONV = fn : conv
val FORALL_NOT_CONV = fn : conv
val FORALL_AND_CONV = fn : conv
val EXISTS_OR_CONV = fn : conv
val AND_FORALL_CONV = fn : conv
val LEFT_AND_FORALL_CONV = fn : conv
val RIGHT_AND_FORALL_CONV = fn : conv
val OR_EXISTS_CONV = fn : conv
val LEFT_OR_EXISTS_CONV = fn : conv
val RIGHT_OR_EXISTS_CONV = fn : conv
val EXISTS_AND_CONV = fn : conv
val AND_EXISTS_CONV = fn : conv
val LEFT_AND_EXISTS_CONV = fn : conv
val RIGHT_AND_EXISTS_CONV = fn : conv
val FORALL_OR_CONV = fn : conv
val OR_FORALL_CONV = fn : conv
val LEFT_OR_FORALL_CONV = fn : conv
val RIGHT_OR_FORALL_CONV = fn : conv
val FORALL_IMP_CONV = fn : conv
val LEFT_IMP_EXISTS_CONV = fn : conv
val RIGHT_IMP_FORALL_CONV = fn : conv
val EXISTS_IMP_CONV = fn : conv
val LEFT_IMP_FORALL_CONV = fn : conv
val RIGHT_IMP_EXISTS_CONV = fn : conv
val X_SKOLEM_CONV = fn : term -> conv
val SKOLEM_CONV = fn : conv
val SYM_CONV = fn : conv
val RIGHT_CONV_RULE = fn : conv -> thm -> thm
val FUN_EQ_CONV = fn : conv
val X_FUN_EQ_CONV = fn : term -> conv
val SELECT_CONV = fn : conv
val CONTRAPOS_CONV = fn : conv
val ANTE_CONJ_CONV = fn : conv
val SWAP_EXISTS_CONV = fn : conv
val RAND_CONV = fn : conv -> conv
val RATOR_CONV = fn : conv -> conv
val ABS_CONV = fn : conv -> conv
val bool_EQ_CONV = fn : conv
val EXISTS_UNIQUE_CONV = fn : conv
val COND_CONV = fn : conv
val EXISTENCE = fn : thm -> thm
val AC_CONV = fn : thm * thm -> conv
val GSYM = fn : thm -> thm
infix THENC
infix ORELSEC
open Drule
structure Thm : Thm_sig
val ADD_ASSUM = fn : term -> thm -> thm
val UNDISCH = fn : thm -> thm
val SYM = fn : thm -> thm
val TRANS = fn : thm -> thm -> thm
val IMP_TRANS = fn : thm -> thm -> thm
val AP_TERM = fn : term -> thm -> thm
val AP_THM = fn : thm -> term -> thm
val EQ_MP = fn : thm -> thm -> thm
val EQ_IMP_RULE = fn : thm -> thm * thm
val TRUTH = |- T : thm
val EQT_ELIM = fn : thm -> thm
val SPEC = fn : term -> thm -> thm
val SPECL = fn : term list -> thm -> thm
val EQT_INTRO = fn : thm -> thm
val GEN = fn : term -> thm -> thm
val GENL = fn : term list -> thm -> thm
val ETA_CONV = fn : term -> thm
val EXT = fn : thm -> thm
val SELECT_INTRO = fn : thm -> thm
val SELECT_ELIM = fn : thm -> term * thm -> thm
val EXISTS = fn : term * term -> thm -> thm
val disch = fn : term * term list -> term list
val CHOOSE = fn : term * thm -> thm -> thm
val SELECT_RULE = fn : thm -> thm
val IMP_ANTISYM_RULE = fn : thm -> thm -> thm
val SPEC_VAR = fn : thm -> term * thm
val MK_EXISTS = fn : thm -> thm
val LIST_MK_EXISTS = fn : term list -> thm -> thm
val FORALL_EQ = fn : term -> thm -> thm
val EXISTS_EQ = fn : term -> thm -> thm
val SELECT_EQ = fn : term -> thm -> thm
val SUBS = fn : thm list -> thm -> thm
val SUBS_OCCS = fn : (int list * thm) list -> thm -> thm
val SUBST_CONV = fn : {thm:thm, var:term} list -> term -> term -> thm
val RIGHT_BETA = fn : thm -> thm
val LIST_BETA_CONV = fn : term -> thm
val RIGHT_LIST_BETA = fn : thm -> thm
val AND_INTRO_THM = |- !t1 t2. t1 ==> t2 ==> t1 /\ t2 : thm
val CONJ = fn : thm -> thm -> thm
val AND1_THM = |- !t1 t2. t1 /\ t2 ==> t1 : thm
val CONJUNCT1 = fn : thm -> thm
val AND2_THM = |- !t1 t2. t1 /\ t2 ==> t2 : thm
val CONJUNCT2 = fn : thm -> thm
val CONJ_SYM = |- !t1 t2. t1 /\ t2 = t2 /\ t1 : thm
val CONJ_ASSOC = |- !t1 t2 t3. t1 /\ t2 /\ t3 = (t1 /\ t2) /\ t3 : thm
val CONJUNCTS_CONV = fn : term * term -> thm
val CONJ_SET_CONV = fn : term list -> term list -> thm
val FRONT_CONJ_CONV = fn : term list -> term -> thm
val CONJ_DISCH = fn : term -> thm -> thm
val CONJ_DISCHL = fn : term list -> thm -> thm
val OR_INTRO_THM1 = |- !t1 t2. t1 ==> t1 \/ t2 : thm
val DISJ1 = fn : thm -> term -> thm
val OR_INTRO_THM2 = |- !t1 t2. t2 ==> t1 \/ t2 : thm
val DISJ2 = fn : term -> thm -> thm
val OR_ELIM_THM = |- !t t1 t2. t1 \/ t2 ==> (t1 ==> t) ==> (t2 ==> t) ==> t
  : thm
val DISJ_CASES = fn : thm -> thm -> thm -> thm
val FALSITY = |- !t. F ==> t : thm
val IMP_F = |- !t. (t ==> F) ==> ~t : thm
val NOT_INTRO = fn : thm -> thm
val NEG_DISCH = fn : term -> thm -> thm
val F_IMP = |- !t. ~t ==> t ==> F : thm
val NOT_ELIM = fn : thm -> thm
val NOT_EQ_SYM = fn : thm -> thm
val AND_CLAUSES =
  |- !t.
       (T /\ t = t) /\
       (t /\ T = t) /\
       (F /\ t = F) /\
       (t /\ F = F) /\
       (t /\ t = t) : thm
val OR_CLAUSES =
  |- !t.
       (T \/ t = T) /\
       (t \/ T = T) /\
       (F \/ t = t) /\
       (t \/ F = t) /\
       (t \/ t = t) : thm
val IMP_CLAUSES =
  |- !t.
       (T ==> t = t) /\
       (t ==> T = T) /\
       (F ==> t = T) /\
       (t ==> t = T) /\
       (t ==> F = ~t) : thm
val CONTR = fn : term -> thm -> thm
val EQF_INTRO = fn : thm -> thm
val EQF_ELIM = fn : thm -> thm
val EXCLUDED_MIDDLE = |- !t. t \/ ~t : thm
val CCONTR = fn : term -> thm -> thm
val INST = fn : term subst -> thm -> thm
val NOT_F = |- !t. ~t ==> (t = F) : thm
val NOT_AND = |- ~(t /\ ~t) : thm
val ISPEC = fn : term -> thm -> thm
val ISPECL = fn : term list -> thm -> thm
val SELECT_REFL = |- !x. (@y. y = x) = x : thm
val SELECT_UNIQUE = |- !P x. (!y. P y = y = x) ==> ($@ P = x) : thm
val GEN_ALL = fn : thm -> thm
val DISCH_ALL = fn : thm -> thm
val UNDISCH_ALL = fn : thm -> thm
val SPEC_ALL = fn : thm -> thm
val PROVE_HYP = fn : thm -> thm -> thm
val CONJ_PAIR = fn : thm -> thm * thm
val LIST_CONJ = fn : thm list -> thm
val CONJ_LIST = fn : int -> thm -> thm list
val CONJUNCTS = fn : thm -> thm list
val BODY_CONJUNCTS = fn : thm -> thm list
val IMP_CANON = fn : thm -> thm list
val LIST_MP = fn : thm list -> thm -> thm
val CONTRAPOS = fn : thm -> thm
val DISJ_IMP = fn : thm -> thm
val IMP_ELIM = fn : thm -> thm
val NOT_CLAUSES = |- (!t. ~~t = t) /\ (~T = F) /\ (~F = T) : thm
val DISJ_CASES_UNION = fn : thm -> thm -> thm -> thm
val EQ_REFL = |- !x. x = x : thm
val REFL_CLAUSE = |- !x. (x = x) = T : thm
val EQ_SYM = |- !x y. (x = y) ==> (y = x) : thm
val EQ_SYM_EQ = |- !x y. (x = y) = y = x : thm
val EQ_EXT = |- !f g. (!x. f x = g x) ==> (f = g) : thm
val EQ_TRANS = |- !x y z. (x = y) /\ (y = z) ==> (x = z) : thm
val BOOL_EQ_DISTINCT = |- ~(T = F) /\ ~(F = T) : thm
val EQ_CLAUSES =
  |- !t. ((T = t) = t) /\ ((t = T) = t) /\ ((F = t) = ~t) /\ ((t = F) = ~t)
  : thm
val MK_COMB = fn : thm * thm -> thm
val MK_ABS = fn : thm -> thm
val ALPHA_CONV = fn : term -> term -> thm
val ALPHA = fn : term -> term -> thm
val GEN_ALPHA_CONV = fn : term -> term -> thm
val COND_CLAUSES = |- !t1 t2. ((T => t1 | t2) = t1) /\ ((F => t1 | t2) = t2)
  : thm
val COND_ID = |- !b t. (b => t | t) = t : thm
val IMP_CONJ = fn : thm -> thm -> thm
val EXISTS_IMP = fn : term -> thm -> thm
val FORALL_SIMP = |- !t. (!x. t) = t : thm
val EXISTS_SIMP = |- !t. (?x. t) = t : thm
val ABS_SIMP = |- !t2 t1. (\x. t1) t2 = t1 : thm
open Term_io
structure Parse : Parse_sig
structure Parse_support : Parse_support_sig
structure Hol_pp : Hol_pp_sig
open Parse
structure Parse_support : Parse_support_sig
val type_parser = fn : term frag list -> hol_type
val preterm_parser = fn : term frag list -> ?.Preterm.preterm
val term_parser = fn : term frag list -> term
val type_spec_parser = fn
  : term frag list
    -> {clauses:{args:Parse_support.arg list, constructor:string} list,
        ty_name:string}
val -- = fn : term frag list -> 'a -> term
val == = fn : term frag list -> 'a -> hol_type
val string_to_type = fn : string -> hol_type
val string_to_preterm = fn : string -> ?.Preterm.preterm
val string_to_term = fn : string -> term
val string_to_type_spec = fn
  : string
    -> {clauses:{args:Parse_support.arg list, constructor:string} list,
        ty_name:string}
open Hol_pp
structure Term : Public_term_sig
val pp_type = fn : System.PrettyPrint.ppstream -> hol_type -> int -> unit
val pp_term = fn : System.PrettyPrint.ppstream -> term -> unit
val pp_self_parsing_type = fn : System.PrettyPrint.ppstream -> hol_type -> unit
val pp_self_parsing_term = fn : System.PrettyPrint.ppstream -> term -> unit
val type_to_string = fn : hol_type -> string
val term_to_string = fn : term -> string
val print_type = fn : hol_type -> unit
val print_term = fn : term -> unit
structure Extend_hol_pp :
  sig
    datatype gravity
      con APPL : gravity
      con BOTTOM : gravity
      con INFIX : int -> gravity
      con TOP : gravity
      con WEAK : gravity
    val gravity_geq : gravity -> gravity -> bool
    val extend_pp_type : (({depth:int, gravity:gravity}
                           -> hol_type -> System.PrettyPrint.ppstream -> unit)
                          -> {depth:int, gravity:gravity}
                             -> hol_type
                                -> System.PrettyPrint.ppstream -> unit)
                         -> unit
    val extend_pp_term : (({boundvars:term list, depth:int, gravity:gravity}
                           -> term -> System.PrettyPrint.ppstream -> unit)
                          -> {boundvars:term list, depth:int, gravity:gravity}
                             -> term -> System.PrettyPrint.ppstream -> unit)
                         -> unit
    val reset_pp_type : unit -> unit
    val reset_pp_term : unit -> unit
  end
open Base_logic
structure Save_hol : Save_hol_sig
structure Lexis : Lexis_sig
structure Type : Public_type_sig
structure Term : Public_term_sig
structure Match : Match_sig
structure Dsyntax :
  sig
    structure Term : Public_term_sig
    val mk_const : {Name:string, Ty:hol_type} -> term
    val mk_eq : {lhs:term, rhs:term} -> term
    val mk_imp : {ant:term, conseq:term} -> term
    val mk_select : {Body:term, Bvar:term} -> term
    val mk_forall : {Body:term, Bvar:term} -> term
    val mk_exists : {Body:term, Bvar:term} -> term
    val mk_neg : term -> term
    val mk_conj : {conj1:term, conj2:term} -> term
    val mk_disj : {disj1:term, disj2:term} -> term
    val mk_cond : {cond:term, larm:term, rarm:term} -> term
    val mk_pair : {fst:term, snd:term} -> term
    val mk_let : {arg:term, func:term} -> term
    val mk_cons : {hd:term, tl:term} -> term
    val mk_list : {els:term list, ty:hol_type} -> term
    val mk_pabs : {body:term, varstruct:term} -> term
    val dest_eq : term -> {lhs:term, rhs:term}
    val lhs : term -> term
    val rhs : term -> term
    val dest_imp : term -> {ant:term, conseq:term}
    val dest_select : term -> {Body:term, Bvar:term}
    val dest_forall : term -> {Body:term, Bvar:term}
    val dest_exists : term -> {Body:term, Bvar:term}
    val dest_neg : term -> term
    val dest_conj : term -> {conj1:term, conj2:term}
    val dest_disj : term -> {disj1:term, disj2:term}
    val dest_cond : term -> {cond:term, larm:term, rarm:term}
    val dest_pair : term -> {fst:term, snd:term}
    val dest_let : term -> {arg:term, func:term}
    val dest_cons : term -> {hd:term, tl:term}
    val dest_list : term -> {els:term list, ty:hol_type}
    val dest_pabs : term -> {body:term, varstruct:term}
    val is_eq : term -> bool
    val is_imp : term -> bool
    val is_select : term -> bool
    val is_forall : term -> bool
    val is_exists : term -> bool
    val is_neg : term -> bool
    val is_conj : term -> bool
    val is_disj : term -> bool
    val is_cond : term -> bool
    val is_pair : term -> bool
    val is_let : term -> bool
    val is_cons : term -> bool
    val is_list : term -> bool
    val is_pabs : term -> bool
    val list_mk_abs : term list * term -> term
    val list_mk_imp : term list * term -> term
    val list_mk_forall : term list * term -> term
    val gen_all : term -> term
    val list_mk_exists : term list * term -> term
    val list_mk_conj : term list -> term
    val list_mk_disj : term list -> term
    val list_mk_pair : term list -> term
    val strip_comb : term -> term * term list
    val strip_abs : term -> term list * term
    val strip_imp : term -> term list * term
    val strip_forall : term -> term list * term
    val strip_exists : term -> term list * term
    val strip_conj : term -> term list
    val strip_disj : term -> term list
    val strip_pair : term -> term list
    val infix_ty : hol_type -> hol_type -> hol_type
    val bool : hol_type
    val de_abs : term -> term list * term
    val find_term : (term -> bool) -> term -> term
    val find_terms : (term -> bool) -> term -> term list
    val subst_occs : int list list -> term subst -> term -> term
    val binder_restrictions : unit -> (string * string) list
    val associate_restriction : string * string -> unit
    val delete_restriction : string -> unit
  end
structure Net : Net_sig
structure Thm : Thm_sig
structure Theory : Theory_sig
structure Add_to_sml : Add_to_sml_sig
structure Library : Library_sig
structure Install : Install_sig
structure Const_spec : Const_spec_sig
structure Type_def : Type_def_sig
structure Const_def : Const_def_sig
structure Min : Mk_min_sig
structure Exists : Mk_exists_sig
open Bool
val T_DEF = |- T = (\x. x) = (\x. x) : thm
val FORALL_DEF = |- $! = (\P. P = (\x. T)) : thm
val AND_DEF = |- $/\ = (\t1 t2. !t. (t1 ==> t2 ==> t) ==> t) : thm
val OR_DEF = |- $\/ = (\t1 t2. !t. (t1 ==> t) ==> (t2 ==> t) ==> t) : thm
val F_DEF = |- F = (!t. t) : thm
val NOT_DEF = |- ~ = (\t. t ==> F) : thm
val EXISTS_UNIQUE_DEF = |- $?! = (\P. $? P /\ (!x y. P x /\ P y ==> (x = y)))
  : thm
val LET_DEF = |- LET = (\f x. f x) : thm
val COND_DEF =
  |- COND = (\t t1 t2. @x. ((t = T) ==> (x = t1)) /\ ((t = F) ==> (x = t2)))
  : thm
val ONE_ONE_DEF = |- !f. ONE_ONE f = (!x1 x2. (f x1 = f x2) ==> (x1 = x2))
  : thm
val ONTO_DEF = |- !f. ONTO f = (!y. ?x. y = f x) : thm
val TYPE_DEFINITION =
  |- !P rep.
       TYPE_DEFINITION P rep =
       (!x' x''. (rep x' = rep x'') ==> (x' = x'')) /\
       (!x. P x = (?x'. x = rep x')) : thm
val BOOL_CASES_AX = |- !t. (t = T) \/ (t = F) : thm
val IMP_ANTISYM_AX = |- !t1 t2. (t1 ==> t2) ==> (t2 ==> t1) ==> (t1 = t2) : thm
val ETA_AX = |- !t. (\x. t x) = t : thm
val SELECT_AX = |- !P x. P x ==> P ($@ P) : thm
val INFINITY_AX = |- ?f. ONE_ONE f /\ ~(ONTO f) : thm
open Exists
val EXISTS_DEF = |- $? = (\P. P ($@ P)) : thm
open Min
open Const_def
structure Theory : Theory_sig
val new_definition = fn : string * term -> thm
val new_infix_definition = fn : string * term * int -> thm
val new_binder_definition = fn : string * term -> thm
open Type_def
structure Theory : Theory_sig
val new_type_definition = fn : {inhab_thm:thm, name:string, pred:term} -> thm
open Const_spec
structure Theory : Theory_sig
val new_specification = fn
  : {consts:{const_name:string, fixity:fixity} list, name:string, sat_thm:thm}
    -> thm
open Install
val install_system_theory = fn : string -> unit
val install = fn : string -> unit
open Add_to_sml
val L = ref [] : (string * thm) list ref
val parser = fn : thm frag list -> thm
val add_to_sml = fn : (string * thm) list -> unit
val add_axioms_to_sml = fn : string -> unit
val add_definitions_to_sml = fn : string -> unit
val add_theorems_to_sml = fn : string -> unit
val add_theory_to_sml = fn : string -> unit
val add_theory_structure_to_sml = fn
  : {structure_name:string, theory_name:string} -> unit
val set_autoloads = fn : autoload_info -> unit
open Library
val loaded_cell = ref fn : (unit -> unit) ref
val lib_eq = fn : lib -> lib -> bool
val new_library = fn
  : {code:string list, doc:string, help:string list, loaded:string,
     name:string, parents:lib list, path:string, theories:string list}
    -> lib
val dest_library = fn
  : lib
    -> {code:string list, doc:string, help:string list, name:string,
        parents:lib list, path:string, theories:string list}
val prim_load_library = fn
  : (string -> unit) -> {lib:lib, theory:string} -> unit
val load_library = fn : {lib:lib, theory:string} -> unit
val load_library_in_place = fn : lib -> unit
val find_library = fn : string -> lib
val get_library_from_disk = fn : string -> lib
val move_library = fn : lib * string -> unit
val delete_library = fn : lib -> unit
val known_libraries = fn : unit -> lib list
val loaded_libraries = fn : unit -> lib list
val pp_library = fn : System.PrettyPrint.ppstream -> lib -> unit
val lib_help = fn : {lib:lib, topic:string} -> unit
open Theory
structure Thm : Thm_sig
val new_parent = fn : string -> unit
val new_type = fn : {Arity:int, Name:string} -> unit
val new_constant = fn : {Name:string, Ty:hol_type} -> unit
val new_infix = fn : {Name:string, Prec:int, Ty:hol_type} -> unit
val new_binder = fn : {Name:string, Ty:hol_type} -> unit
val new_open_axiom = fn : string * term -> thm
val store_definition = fn : string * term -> thm
val save_thm = fn : string * thm -> thm
val arity = fn : string -> int
val fixity = fn : string -> fixity
val precedence = fn : string -> int
val const_decl = fn : string -> {const:term, place:fixity, theory:string}
val is_constant = fn : string -> bool
val is_type = fn : string -> bool
val is_binder = fn : string -> bool
val is_infix = fn : string -> bool
val draft_mode = fn : unit -> bool
val current_theory = fn : unit -> string
val parents = fn : string -> string list
val ancestry = fn : string -> string list
val types = fn : string -> {Arity:int, Name:string} list
val constants = fn : string -> term list
val infixes = fn : string -> term list
val binders = fn : string -> term list
val axioms = fn : string -> (string * thm) list
val axiom = fn : string -> string -> thm
val definitions = fn : string -> (string * thm) list
val definition = fn : string -> string -> thm
val theorems = fn : string -> (string * thm) list
val theorem = fn : string -> string -> thm
val print_theory = fn : string -> unit
val html_theory = fn : string -> unit
val new_theory = fn : string -> unit
val close_theory = fn : unit -> unit
val load_theory = fn : string -> unit
val extend_theory = fn : string -> unit
val export_theory = fn : unit -> unit
val close = fn : unit -> unit
val delete_cache = fn : unit -> unit
val delete_theory_from_cache = fn : string -> unit
val theories_in_cache = fn : unit -> string list
val perform_atomic_theory_op = fn : (unit -> 'a) -> 'a
open Thm
structure Term : Public_term_sig
val reset_thm_count = fn : unit -> unit
val counting_thms = fn : bool -> unit
val thm_count = fn
  : unit
    -> {ABS:int, ASSUME:int, BETA_CONV:int, DISCH:int, INST_TYPE:int, MP:int,
        REFL:int, SUBST:int, axiom:int, definition:int, drule:int,
        from_disk:int, other:int, valid_tac:int}
val hyp = fn : thm -> term list
val concl = fn : thm -> term
val dest_thm = fn : thm -> term list * term
val thm_free_vars = fn : thm -> term list
val hyp_union = fn : thm list -> term list
val pp_thm = fn : System.PrettyPrint.ppstream -> thm -> unit
val thm_to_string = fn : thm -> string
val print_thm = fn : thm -> unit
val ASSUME = fn : term -> thm
val REFL = fn : term -> thm
val BETA_CONV = fn : term -> thm
val SUBST = fn : {thm:thm, var:term} list -> term -> thm -> thm
val ABS = fn : term -> thm -> thm
val INST_TYPE = fn : hol_type subst -> thm -> thm
val DISCH = fn : term -> thm -> thm
val MP = fn : thm -> thm -> thm
val mk_axiom_thm = fn : term list * term -> thm
val mk_definition_thm = fn : term list * term -> thm
val mk_drule_thm = fn : term list * term -> thm
val mk_disk_thm = fn : term list * term -> thm
val mk_tac_thm = fn : term list * term -> thm
val mk_thm = fn : term list * term -> thm
open Net
structure Term : Public_term_sig
val empty_net = NODE [] : 'a net
val enter = fn : term * 'a -> 'a net -> 'a net
val lookup = fn : term -> 'a net -> 'a list
open Dsyntax
structure Term : Public_term_sig
val mk_const = fn : {Name:string, Ty:hol_type} -> term
val mk_eq = fn : {lhs:term, rhs:term} -> term
val mk_imp = fn : {ant:term, conseq:term} -> term
val mk_select = fn : {Body:term, Bvar:term} -> term
val mk_forall = fn : {Body:term, Bvar:term} -> term
val mk_exists = fn : {Body:term, Bvar:term} -> term
val mk_neg = fn : term -> term
val mk_conj = fn : {conj1:term, conj2:term} -> term
val mk_disj = fn : {disj1:term, disj2:term} -> term
val mk_cond = fn : {cond:term, larm:term, rarm:term} -> term
val mk_pair = fn : {fst:term, snd:term} -> term
val mk_let = fn : {arg:term, func:term} -> term
val mk_cons = fn : {hd:term, tl:term} -> term
val mk_list = fn : {els:term list, ty:hol_type} -> term
val mk_pabs = fn : {body:term, varstruct:term} -> term
val dest_eq = fn : term -> {lhs:term, rhs:term}
val lhs = fn : term -> term
val rhs = fn : term -> term
val dest_imp = fn : term -> {ant:term, conseq:term}
val dest_select = fn : term -> {Body:term, Bvar:term}
val dest_forall = fn : term -> {Body:term, Bvar:term}
val dest_exists = fn : term -> {Body:term, Bvar:term}
val dest_neg = fn : term -> term
val dest_conj = fn : term -> {conj1:term, conj2:term}
val dest_disj = fn : term -> {disj1:term, disj2:term}
val dest_cond = fn : term -> {cond:term, larm:term, rarm:term}
val dest_pair = fn : term -> {fst:term, snd:term}
val dest_let = fn : term -> {arg:term, func:term}
val dest_cons = fn : term -> {hd:term, tl:term}
val dest_list = fn : term -> {els:term list, ty:hol_type}
val dest_pabs = fn : term -> {body:term, varstruct:term}
val is_eq = fn : term -> bool
val is_imp = fn : term -> bool
val is_select = fn : term -> bool
val is_forall = fn : term -> bool
val is_exists = fn : term -> bool
val is_neg = fn : term -> bool
val is_conj = fn : term -> bool
val is_disj = fn : term -> bool
val is_cond = fn : term -> bool
val is_pair = fn : term -> bool
val is_let = fn : term -> bool
val is_cons = fn : term -> bool
val is_list = fn : term -> bool
val is_pabs = fn : term -> bool
val list_mk_abs = fn : term list * term -> term
val list_mk_imp = fn : term list * term -> term
val list_mk_forall = fn : term list * term -> term
val gen_all = fn : term -> term
val list_mk_exists = fn : term list * term -> term
val list_mk_conj = fn : term list -> term
val list_mk_disj = fn : term list -> term
val list_mk_pair = fn : term list -> term
val strip_comb = fn : term -> term * term list
val strip_abs = fn : term -> term list * term
val strip_imp = fn : term -> term list * term
val strip_forall = fn : term -> term list * term
val strip_exists = fn : term -> term list * term
val strip_conj = fn : term -> term list
val strip_disj = fn : term -> term list
val strip_pair = fn : term -> term list
val infix_ty = fn : hol_type -> hol_type -> hol_type
val bool = (==`:bool`==) : hol_type
val de_abs = fn : term -> term list * term
val find_term = fn : (term -> bool) -> term -> term
val find_terms = fn : (term -> bool) -> term -> term list
val subst_occs = fn : int list list -> term subst -> term -> term
val binder_restrictions = fn : unit -> (string * string) list
val associate_restriction = fn : string * string -> unit
val delete_restriction = fn : string -> unit
open Match
structure Term : Public_term_sig
val match_type = fn : hol_type -> hol_type -> hol_type subst
val match_term = fn : term -> term -> term subst * hol_type subst
open Term
structure Type : Public_type_sig
val const_decl = fn : string -> {const:term, place:fixity, theory:string}
val fixity_of_term = fn : string -> fixity
val prec_of_term = fn : string -> int
val is_binder = fn : string -> bool
val is_infix = fn : string -> bool
val is_polymorphic = fn : string -> bool
val ty_antiq = fn : hol_type -> term
val free_vars = fn : term -> term list
val free_in = fn : term -> term -> bool
val all_vars = fn : term -> term list
val free_varsl = fn : term list -> term list
val all_varsl = fn : term list -> term list
val term_lt = fn : term -> term -> bool
val genvar = fn : hol_type -> term
val genvars = fn : hol_type -> int -> term list
val variant = fn : term list -> term -> term
val type_of = fn : term -> hol_type
val type_vars_in_term = fn : term -> hol_type list
val mk_var = fn : {Name:string, Ty:hol_type} -> term
val mk_primed_var = fn : {Name:string, Ty:hol_type} -> term
val list_mk_comb = fn : term * term list -> term
val mk_comb = fn : {Rand:term, Rator:term} -> term
val mk_abs = fn : {Body:term, Bvar:term} -> term
val dest_var = fn : term -> {Name:string, Ty:hol_type}
val dest_const = fn : term -> {Name:string, Ty:hol_type}
val dest_comb = fn : term -> {Rand:term, Rator:term}
val dest_abs = fn : term -> {Body:term, Bvar:term}
val is_var = fn : term -> bool
val is_const = fn : term -> bool
val is_comb = fn : term -> bool
val is_abs = fn : term -> bool
val dest_term = fn : term -> lambda
val rator = fn : term -> term
val rand = fn : term -> term
val bvar = fn : term -> term
val body = fn : term -> term
val aconv = fn : term -> term -> bool
val subst = fn : term subst -> term -> term
val inst = fn : hol_type subst -> term -> term
val beta_conv = fn : term -> term
open Type
val new_type_var = fn : unit -> hol_type
val reset_type_num = fn : unit -> unit
val type_subst = fn : hol_type subst -> hol_type -> hol_type
val type_vars = fn : hol_type -> hol_type list
val type_varsl = fn : hol_type list -> hol_type list
val mk_type = fn : {Args:hol_type list, Tyop:string} -> hol_type
val dest_type = fn : hol_type -> {Args:hol_type list, Tyop:string}
val mk_vartype = fn : string -> hol_type
val dest_vartype = fn : hol_type -> string
val is_vartype = fn : hol_type -> bool
val type_lt = fn : hol_type -> hol_type -> bool
val type_decl = fn : string -> {arity:int, theory:string, tyc:hol_type}
open Save_hol
val print_banner = fn : string -> unit
val save_hol = fn : string -> unit
open Lib
val curry = fn : ('a * 'b -> 'c) -> 'a -> 'b -> 'c
val uncurry = fn : ('a -> 'b -> 'c) -> 'a * 'b -> 'c
val append = fn : 'a list -> 'a list -> 'a list
val concat = fn : string -> string -> string
val equal = fn : ''a -> ''a -> bool
val ## = fn : ('a -> 'b) * ('c -> 'd) -> 'a * 'c -> 'b * 'd
val A = fn : ('a -> 'b) -> 'a -> 'b
val B = fn : ('a -> 'b) -> ('c -> 'a) -> 'c -> 'b
val C = fn : ('a -> 'b -> 'c) -> 'b -> 'a -> 'c
val I = fn : 'a -> 'a
val K = fn : 'a -> 'b -> 'a
val S = fn : ('a -> 'b -> 'c) -> ('a -> 'b) -> 'a -> 'c
val fst = fn : 'a * 'b -> 'a
val snd = fn : 'a * 'b -> 'b
val can = fn : ('a -> 'b) -> 'a -> bool
val assert = fn : ('a -> bool) -> 'a -> 'a
val tryfind = fn : ('a -> 'b) -> 'a list -> 'b
val el = fn : int -> 'a list -> 'a
val map2 = fn : ('a -> 'b -> 'c) -> 'a list -> 'b list -> 'c list
val all = fn : ('a -> bool) -> 'a list -> bool
val all2 = fn : ('a -> 'b -> bool) -> 'a list -> 'b list -> bool
val first = fn : ('a -> bool) -> 'a list -> 'a
val split_after = fn : int -> 'a list -> 'a list * 'a list
val partition = fn : ('a -> bool) -> 'a list -> 'a list * 'a list
val gather = fn : ('a -> bool) -> 'a list -> 'a list
val filter = fn : ('a -> bool) -> 'a list -> 'a list
val itlist = fn : ('a -> 'b -> 'b) -> 'a list -> 'b -> 'b
val itlist2 = fn : ('a -> 'b -> 'c -> 'c) -> 'a list -> 'b list -> 'c -> 'c
val rev_itlist = fn : ('a -> 'b -> 'b) -> 'a list -> 'b -> 'b
val rev_itlist2 = fn : ('a -> 'b -> 'c -> 'c) -> 'a list -> 'b list -> 'c -> 'c
val end_itlist = fn : ('a -> 'a -> 'a) -> 'a list -> 'a
val zip = fn : 'a list -> 'b list -> ('a * 'b) list
val combine = fn : 'a list * 'b list -> ('a * 'b) list
val unzip = fn : ('a * 'b) list -> 'a list * 'b list
val split = fn : ('a * 'b) list -> 'a list * 'b list
val mapfilter = fn : ('a -> 'b) -> 'a list -> 'b list
val flatten = fn : 'a list list -> 'a list
exception NOT_FOUND = NOT_FOUND
exception NO_CHANGE = NO_CHANGE
val assoc = fn : ''a -> (''a * 'b) list -> 'b
val assoc1 = fn : ''a -> (''a * 'b) list -> (''a * 'b) option
val assoc2 = fn : ''a -> ('b * ''a) list -> ('b * ''a) option
val subst_assoc = fn : ('a -> bool) -> 'a subst -> 'a option
val |-> = fn : 'a * 'a -> {redex:'a, residue:'a}
val mem = fn : ''a -> ''a list -> bool
val mk_set = fn : ''a list -> ''a list
val union = fn : ''a list -> ''a list -> ''a list
val U = fn : ''a list list -> ''a list
val set_diff = fn : ''a list -> ''a list -> ''a list
val subtract = fn : ''a list -> ''a list -> ''a list
val intersect = fn : ''a list -> ''a list -> ''a list
val null_intersection = fn : ''a list -> ''a list -> bool
val set_eq = fn : ''a list -> ''a list -> bool
val op_mem = fn : ('a -> 'b -> bool) -> 'a -> 'b list -> bool
val op_union = fn : ('a -> 'a -> bool) -> 'a list -> 'a list -> 'a list
val op_U = fn : ('a -> 'a -> bool) -> 'a list list -> 'a list
val op_intersect = fn : ('a -> 'a -> bool) -> 'a list -> 'a list -> 'a list
val for = fn : int -> int -> (int -> 'a) -> 'a list
val for_se = fn : int -> int -> (int -> 'a) -> unit
val list_of_array = fn : 'a array -> 'a list
val int_to_string = fn : int -> string
val string_to_int = fn : string -> int
val sort = fn : ('a -> 'a -> bool) -> 'a list -> 'a list
val int_sort = fn : int list -> int list
val clean_directory = fn : string -> unit
val file_exists_for_reading = fn : string -> bool
val find_path = fn : string list -> string -> string
val cons_path = fn : string -> string list ref -> unit
val append_path = fn : string -> string list ref -> unit
val timestamp = fn : unit -> time
val time_eq = fn : time -> time -> bool
val time_lt = fn : time -> time -> bool
val exit = fn : unit -> 'a
val compile = fn : string -> unit
val interpret = fn : string -> unit
val fresh_name = fn : string -> unit -> string
val use_string = fn : string -> unit
val say = fn : string -> unit
val quote = fn : string -> string
val eval_string = fn : string -> unit
val cd = fn : string -> unit
val pwd = fn : unit -> string
val ls = fn : unit -> int
val words2 = fn : string -> string -> string list
val front_n_back = fn : 'a list -> 'a list * 'a
val funpow = fn : int -> ('a -> 'a) -> 'a -> 'a
infix 3 ##
open Exception
exception HOL_ERR = HOL_ERR
val print_HOL_ERR = fn : exn -> unit
val Raise = fn : exn -> 'a
open Globals
val version_number = 7 : int
val neg_defined = fn : unit -> bool
val nums_defined = fn : unit -> bool
val strings_defined = fn : unit -> bool
val assert_neg_defined = fn : unit -> unit
val assert_nums_defined = fn : unit -> unit
val assert_strings_defined = fn : unit -> unit
val in_type_spec = ref NONE : string option ref
val print_exceptions = ref true : bool ref
val show_assums = ref false : bool ref
val allow_theorems_with_assumptions = ref true : bool ref
val use_init_file = ref false : bool ref
val max_print_depth = ref ~1 : int ref
val type_pp_prefix = ref "(==" : string ref
val type_pp_suffix = ref "==)" : string ref
val term_pp_prefix = ref "(--" : string ref
val term_pp_suffix = ref "--)" : string ref
val linewidth = ref 79 : int ref
val interp = ref false : bool ref
val arch = "sparc" : string
val theory_file_type = "ascii" : string
val remake_theory_files = false : bool
val paths =
  {HOLdir=ref "/usr/groups/hol/hol90.7/solaris/",
   help_path=ref
               ["/usr/groups/hol/hol90.7/solaris/help/90/",
                "/usr/groups/hol/hol90.7/solaris/help/88/ENTRIES/"],
   library_path=ref
                  ["/usr/groups/hol/hol90.7/solaris/library/desc/",
                   "/usr/groups/hol/hol90.7/solaris/contrib/desc/"],
   theory_path=ref ["/usr/groups/hol/hol90.7/solaris/theories/ascii/"]}
  : {HOLdir:string ref, help_path:string list ref,
     library_path:string list ref, theory_path:string list ref}
val HOLdir = ref "/usr/groups/hol/hol90.7/solaris/" : string ref
val theory_path = ref ["/usr/groups/hol/hol90.7/solaris/theories/ascii/"]
  : string list ref
val library_path =
  ref
    ["/usr/groups/hol/hol90.7/solaris/library/desc/",
     "/usr/groups/hol/hol90.7/solaris/contrib/desc/"] : string list ref
val help_path =
  ref
    ["/usr/groups/hol/hol90.7/solaris/help/90/",
     "/usr/groups/hol/hol90.7/solaris/help/88/ENTRIES/"] : string list ref
val output_HOL_ERR = ref fn
  : ({message:string, origin_function:string, origin_structure:string} -> unit)
      ref
val output_help = ref "/bin/cat" : string ref
val tilde_symbols = ref [] : string list ref
val pp_flags =
  {infix_at_front=ref false,show_dB=ref false,show_restrict=ref true,
   show_types=ref false,stack_infixes=ref true}
  : {infix_at_front:bool ref, show_dB:bool ref, show_restrict:bool ref,
     show_types:bool ref, stack_infixes:bool ref}
val show_restrict = ref true : bool ref
val show_types = ref false : bool ref
val show_dB = ref false : bool ref
val reserved_identifiers =
  {alphanumeric=["let","in","and","of"],symbolic=["\\",";","=>","|",":"]}
  : {alphanumeric:string list, symbolic:string list}
val goal_line = ref "____________________________" : string ref

  The code of library "PRIM_HOL" has been loaded.

  The help path for library "PRIM_HOL" has been adjusted.

[Major collection... 55% used (4316616/7742672), 770 msec]

[Major collection... 99% used (4339504/4342088), 810 msec]


          HHH                 LL
          HHH                  LL
          HHH                   LL
          HHH                    LL
          HHH          OOOO       LL
          HHHHHHH     OO  OO       LL
          HHHHHHH     OO  OO       LLL
          HHH          OOOO        LLLL
          HHH                     LL  LL
          HHH                    LL    LL
          HHH                   LL      LL
          HHH                  LL        LL90.7

Created on Tue Jan 23 15:27:33 GMT 1996
using: Standard ML of New Jersey, Version 0.93, February 15, 1993



The library "PRIM_HOL" is loaded.
val it = () : unit
- 

          HHH                 LL
          HHH                  LL
          HHH                   LL
          HHH                    LL
          HHH          OOOO       LL
          HHHHHHH     OO  OO       LL
          HHHHHHH     OO  OO       LLL
          HHH          OOOO        LLLL
          HHH                     LL  LL
          HHH                    LL    LL
          HHH                   LL      LL
          HHH                  LL        LL90.7

Created on Tue Jan 23 15:27:33 GMT 1996
using: Standard ML of New Jersey, Version 0.93, February 15, 1993



The library "PRIM_HOL" is loaded.
val it = () : unit
- = 
Loading theory "restr_binder"

Theory "bool" already consistent with disk, hence not exported.
val RES_ABSTRACT = |- !P B. RES_ABSTRACT P B = (\x. (P x) => (B x) | ARB) : thm
val ARB = |- ARB = (@x. T) : thm
val RES_SELECT = |- !P B. RES_SELECT P B = (@x. P x /\ B x) : thm
val RES_EXISTS = |- !P B. RES_EXISTS P B = (?x. P x /\ B x) : thm
val RES_FORALL = |- !P B. RES_FORALL P B = (!x. P x ==> B x) : thm
val it = () : unit


          HHH                 LL
          HHH                  LL
          HHH                   LL
          HHH                    LL
          HHH          OOOO       LL
          HHHHHHH     OO  OO       LL
          HHHHHHH     OO  OO       LLL
          HHH          OOOO        LLLL
          HHH                     LL  LL
          HHH                    LL    LL
          HHH                   LL      LL
          HHH                  LL        LL90.7

Created on Tue Jan 23 15:27:33 GMT 1996
using: Standard ML of New Jersey, Version 0.93, February 15, 1993



The library "PRIM_HOL" is loaded.
val it = () : unit
- = 
Loading theory "pair"

Theory "bool" already consistent with disk, hence not exported.
val CURRY_DEF = |- !f x y. CURRY f x y = f (x,y) : thm
val UNCURRY_DEF = |- !f x y. UNCURRY f (x,y) = f x y : thm
val PAIR_EQ = |- ((x,y) = (a,b)) = (x = a) /\ (y = b) : thm
val SND = |- !x y. SND (x,y) = y : thm
val FST = |- !x y. FST (x,y) = x : thm
val PAIR = |- !x. (FST x,SND x) = x : thm
val it = () : unit


          HHH                 LL
          HHH                  LL
          HHH                   LL
          HHH                    LL
          HHH          OOOO       LL
          HHHHHHH     OO  OO       LL
          HHHHHHH     OO  OO       LLL
          HHH          OOOO        LLLL
          HHH                     LL  LL
          HHH                    LL    LL
          HHH                   LL      LL
          HHH                  LL        LL90.7

Created on Tue Jan 23 15:27:33 GMT 1996
using: Standard ML of New Jersey, Version 0.93, February 15, 1993



The library "PRIM_HOL" is loaded.
val it = () : unit
- = 
Loading theory "combin"

Theory "bool" already consistent with disk, hence not exported.
val I_DEF = |- I = S K K : thm
val S_DEF = |- S = (\f g x. f x (g x)) : thm
val K_DEF = |- K = (\x y. x) : thm
val o_DEF = |- !f g. f o g = (\x. f (g x)) : thm
val I_o_ID = |- !f. (I o f = f) /\ (f o I = f) : thm
val I_THM = |- !x. I x = x : thm
val S_THM = |- !f g x. S f g x = f x (g x) : thm
val K_THM = |- !x y. K x y = x : thm
val o_ASSOC = |- !f g h. f o g o h = (f o g) o h : thm
val o_THM = |- !f g x. (f o g) x = f (g x) : thm
val it = () : unit


          HHH                 LL
          HHH                  LL
          HHH                   LL
          HHH                    LL
          HHH          OOOO       LL
          HHHHHHH     OO  OO       LL
          HHHHHHH     OO  OO       LLL
          HHH          OOOO        LLLL
          HHH                     LL  LL
          HHH                    LL    LL
          HHH                   LL      LL
          HHH                  LL        LL90.7

Created on Tue Jan 23 15:27:33 GMT 1996
using: Standard ML of New Jersey, Version 0.93, February 15, 1993



The library "PRIM_HOL" is loaded.
val it = () : unit
- = 
Loading theory "one"

Theory "bool" already consistent with disk, hence not exported.
val one_Axiom = |- !e. ?!fn. fn one = e : thm
val one = |- !v. v = one : thm
val one_axiom = |- !f g. f = g : thm
val it = () : unit


          HHH                 LL
          HHH                  LL
          HHH                   LL
          HHH                    LL
          HHH          OOOO       LL
          HHHHHHH     OO  OO       LL
          HHHHHHH     OO  OO       LLL
          HHH          OOOO        LLLL
          HHH                     LL  LL
          HHH                    LL    LL
          HHH                   LL      LL
          HHH                  LL        LL90.7

Created on Tue Jan 23 15:27:33 GMT 1996
using: Standard ML of New Jersey, Version 0.93, February 15, 1993



The library "PRIM_HOL" is loaded.
val it = () : unit
- = 
Loading theory "sum"

Theory "bool" already consistent with disk, hence not exported.
val OUTR = |- !x. OUTR (INR x) = x : thm
val OUTL = |- !x. OUTL (INL x) = x : thm
val ISR = |- (!x. ISR (INR x)) /\ (!y. ~(ISR (INL y))) : thm
val ISL = |- (!x. ISL (INL x)) /\ (!y. ~(ISL (INR y))) : thm
val INR = |- !x. ISR x ==> (INR (OUTR x) = x) : thm
val INL = |- !x. ISL x ==> (INL (OUTL x) = x) : thm
val ISL_OR_ISR = |- !x. ISL x \/ ISR x : thm
val sum_Axiom = |- !f g. ?!h. (!x. h (INL x) = f x) /\ (!x. h (INR x) = g x)
  : thm
val sum_axiom = |- !f g. ?!h. (h o INL = f) /\ (h o INR = g) : thm
val it = () : unit


          HHH                 LL
          HHH                  LL
          HHH                   LL
          HHH                    LL
          HHH          OOOO       LL
          HHHHHHH     OO  OO       LL
          HHHHHHH     OO  OO       LLL
          HHH          OOOO        LLLL
          HHH                     LL  LL
          HHH                    LL    LL
          HHH                   LL      LL
          HHH                  LL        LL90.7

Created on Tue Jan 23 15:27:33 GMT 1996
using: Standard ML of New Jersey, Version 0.93, February 15, 1993



The library "PRIM_HOL" is loaded.
val it = () : unit
- = 
Loading theory "num"

Theory "bool" already consistent with disk, hence not exported.
val INDUCTION = |- !P. P 0 /\ (!n. P n ==> P (SUC n)) ==> (!n. P n) : thm
val INV_SUC = |- !m n. (SUC m = SUC n) ==> (m = n) : thm
val NOT_SUC = |- !n. ~(SUC n = 0) : thm
val it = () : unit


          HHH                 LL
          HHH                  LL
          HHH                   LL
          HHH                    LL
          HHH          OOOO       LL
          HHHHHHH     OO  OO       LL
          HHHHHHH     OO  OO       LLL
          HHH          OOOO        LLLL
          HHH                     LL  LL
          HHH                    LL    LL
          HHH                   LL      LL
          HHH                  LL        LL90.7

Created on Tue Jan 23 15:27:33 GMT 1996
using: Standard ML of New Jersey, Version 0.93, February 15, 1993



The library "PRIM_HOL" is loaded.
val it = () : unit
- val basic_hol_lib =
  library name: BASIC_HOL
  description: Supplies numbers and pairs. Preloaded.
  parents: [PRIM_HOL]
   : lib

Loading theory "BASIC_HOL"

Theory "bool" already consistent with disk, hence not exported.
val it = () : unit

Loading the library "BASIC_HOL".

The library "PRIM_HOL" is already loaded.

  The parent libraries of library "BASIC_HOL" have been loaded.

  The theories belonging to library "BASIC_HOL" have been incorporated.
[opening /usr/groups/hol/hol90.7/solaris/src/2/num_conv.sig]
signature Num_conv_sig = sig val num_CONV : term -> thm end
[opening /usr/groups/hol/hol90.7/solaris/src/2/num_conv.sml]
structure Num_conv : Num_conv_sig
[opening /usr/groups/hol/hol90.7/solaris/src/2/let_conv.sig]
signature Let_conv_sig =
  sig
    val PAIRED_BETA_CONV : conv
    val let_CONV : conv
    val PAIRED_ETA_CONV : conv
    val GEN_BETA_CONV : conv
  end
[opening /usr/groups/hol/hol90.7/solaris/src/2/let_conv.sml]
.../src/2/let_conv.sml:250.8-250.57 Warning: binding not exhaustive
          {Args=ty1 :: ty2 :: nil,...} = ...
.../src/2/let_conv.sml:76.8-76.54 Warning: binding not exhaustive
          (fv,xv :: yv :: nil) = ...
.../src/2/let_conv.sml:72.8-72.41 Warning: binding not exhaustive
          t2 :: t3 :: nil = ...
.../src/2/let_conv.sml:71.8-71.50 Warning: binding not exhaustive
          t1 :: ty' :: nil = ...

[Major collection... 70% used (4617688/6549708), 930 msec]

[Increasing heap to 14536k]

[Major collection... 65% used (4908080/7440340), 970 msec]

[Increasing heap to 14668k]
structure Let_conv : Let_conv_sig
[opening /usr/groups/hol/hol90.7/solaris/src/2/num_induct.sig]
signature Num_induct_sig =
  sig
    val INDUCT : thm * thm -> thm
    val INDUCT_TAC : tactic
  end
[opening /usr/groups/hol/hol90.7/solaris/src/2/num_induct.sml]
structure Num_induct : Num_induct_sig
[opening /usr/groups/hol/hol90.7/solaris/src/2/rec_type_support.sig]
signature Rec_type_support_sig =
  sig
    val prove_induction_thm : thm -> thm
    val prove_cases_thm : thm -> thm
    val prove_constructors_one_one : thm -> thm
    val prove_constructors_distinct : thm -> thm
  end
[opening /usr/groups/hol/hol90.7/solaris/src/2/rec_type_support.sml]
.../src/2/rec_type_support.sml:773.8-773.56 Warning: binding not exhaustive
          {Args=_ :: ty :: nil,...} = ...
.../src/2/rec_type_support.sml:768.29-769.68 Warning: match nonexhaustive
          (rul,eq :: eqs,nil) => ...
          (rul,eq :: eqs,h :: t) => ...
  
.../src/2/rec_type_support.sml:758.32-767.9 Warning: match nonexhaustive
          (rul,eq,eqs,nil,acc) => ...
          (rul,eq,heq :: eqrst,h :: t,acc) => ...
  
.../src/2/rec_type_support.sml:740.13-740.64 Warning: binding not exhaustive
          l :: r :: nil = ...
.../src/2/rec_type_support.sml:738.1-744.11 Warning: match nonexhaustive
          _ :: nil => ...
          h :: rst => ...
  
.../src/2/rec_type_support.sml:728.4-737.6 Warning: match nonexhaustive
          (h :: rst,t) => ...
  
.../src/2/rec_type_support.sml:611.23-612.73 Warning: match nonexhaustive
          (nil,nil) => ...
          (a :: L1,b :: L2) => ...
  
.../src/2/rec_type_support.sml:344.8-344.60 Warning: binding not exhaustive
          {Args=ty :: rty :: nil,...} = ...

[Major collection... 61% used (4851528/7854300), 1010 msec]

[Increasing heap to 15492k]

[Major collection... 64% used (5234832/8169948), 1110 msec]

[Increasing heap to 16796k]

[Major collection... 56% used (5084124/8921224), 1090 msec]

[Major collection... 55% used (5045544/9040152), 1110 msec]

[Major collection... 65% used (5659484/8640608), 1280 msec]

[Increasing heap to 18476k]
structure Rec_type_support : Rec_type_support_sig

  The code of library "BASIC_HOL" has been loaded.

  The help path for library "BASIC_HOL" has been adjusted.
open Num_conv Let_conv
val num_CONV = fn : term -> thm
val PAIRED_BETA_CONV = fn : conv
val let_CONV = fn : conv
val PAIRED_ETA_CONV = fn : conv
val GEN_BETA_CONV = fn : conv

[Major collection... 46% used (4454956/9541920), 860 msec]

[Decreasing heap to 13556k]
open Num_induct Rec_type_support
val INDUCT = fn : thm * thm -> thm
val INDUCT_TAC = fn : tactic
val prove_induction_thm = fn : thm -> thm
val prove_cases_thm = fn : thm -> thm
val prove_constructors_one_one = fn : thm -> thm
val prove_constructors_distinct = fn : thm -> thm

[Major collection... 98% used (4582840/4647840), 850 msec]

[Major collection... 99% used (4607692/4607812), 840 msec]


          HHH                 LL
          HHH                  LL
          HHH                   LL
          HHH                    LL
          HHH          OOOO       LL
          HHHHHHH     OO  OO       LL
          HHHHHHH     OO  OO       LLL
          HHH          OOOO        LLLL
          HHH                     LL  LL
          HHH                    LL    LL
          HHH                   LL      LL
          HHH                  LL        LL90.7

Created on Tue Jan 23 15:29:20 GMT 1996
using: Standard ML of New Jersey, Version 0.93, February 15, 1993



The library "BASIC_HOL" is loaded.
- 

          HHH                 LL
          HHH                  LL
          HHH                   LL
          HHH                    LL
          HHH          OOOO       LL
          HHHHHHH     OO  OO       LL
          HHHHHHH     OO  OO       LLL
          HHH          OOOO        LLLL
          HHH                     LL  LL
          HHH                    LL    LL
          HHH                   LL      LL
          HHH                  LL        LL90.7

Created on Tue Jan 23 15:29:20 GMT 1996
using: Standard ML of New Jersey, Version 0.93, February 15, 1993



The library "BASIC_HOL" is loaded.
- = 
Loading theory "prim_rec"

Theory "BASIC_HOL" already consistent with disk, hence not exported.
val num_Axiom = |- !e f. ?!fn1. (fn1 0 = e) /\ (!n. fn1 (SUC n) = f (fn1 n) n)
  : thm
val PRE = |- (PRE 0 = 0) /\ (!m. PRE (SUC m) = m) : thm
val LESS_SUC_SUC = |- !m. m < SUC m /\ m < SUC (SUC m) : thm
val LESS_NOT_EQ = |- !m n. m < n ==> ~(m = n) : thm
val NOT_LESS_EQ = |- !m n. (m = n) ==> ~(m < n) : thm
val SUC_ID = |- !n. ~(SUC n = n) : thm
val EQ_LESS = |- !n. (SUC m = n) ==> m < n : thm
val LESS_0 = |- !n. 0 < SUC n : thm
val LESS_SUC_IMP = |- !m n. m < SUC n ==> ~(m = n) ==> m < n : thm
val LESS_THM = |- !m n. m < SUC n = (m = n) \/ m < n : thm
val LESS_SUC = |- !m n. m < n ==> m < SUC n : thm
val LESS_SUC_REFL = |- !n. n < SUC n : thm
val LESS_MONO = |- !m n. m < n ==> SUC m < SUC n : thm
val NOT_LESS_0 = |- !n. ~(n < 0) : thm
val SUC_LESS = |- !m n. SUC m < n ==> m < n : thm
val LESS_REFL = |- !n. ~(n < n) : thm
val INV_SUC_EQ = |- !m n. (SUC m = SUC n) = m = n : thm
val it = () : unit


          HHH                 LL
          HHH                  LL
          HHH                   LL
          HHH                    LL
          HHH          OOOO       LL
          HHHHHHH     OO  OO       LL
          HHHHHHH     OO  OO       LLL
          HHH          OOOO        LLLL
          HHH                     LL  LL
          HHH                    LL    LL
          HHH                   LL      LL
          HHH                  LL        LL90.7

Created on Tue Jan 23 15:29:20 GMT 1996
using: Standard ML of New Jersey, Version 0.93, February 15, 1993



The library "BASIC_HOL" is loaded.
- = 
Loading theory "arithmetic"

Theory "BASIC_HOL" already consistent with disk, hence not exported.
val DIVISION =
  |- !n. 0 < n ==> (!k. (k = (k DIV n) * n + k MOD n) /\ k MOD n < n) : thm
val ODD = |- (ODD 0 = F) /\ (!n. ODD (SUC n) = ~(ODD n)) : thm
val EVEN = |- (EVEN 0 = T) /\ (!n. EVEN (SUC n) = ~(EVEN n)) : thm
val FACT = |- (FACT 0 = 1) /\ (!n. FACT (SUC n) = SUC n * FACT n) : thm
val GREATER_OR_EQ = |- !m n. m >= n = m > n \/ (m = n) : thm
val LESS_OR_EQ = |- !m n. m <= n = m < n \/ (m = n) : thm
val GREATER = |- !m n. m > n = n < m : thm
val EXP = |- (!m. m EXP 0 = 1) /\ (!m n. m EXP SUC n = m * m EXP n) : thm
val MULT = |- (!n. 0 * n = 0) /\ (!m n. SUC m * n = m * n + n) : thm
val SUB =
  |- (!m. 0 - m = 0) /\ (!m n. SUC m - n = ((m < n) => 0 | (SUC (m - n))))
  : thm
val ADD = |- (!n. 0 + n = n) /\ (!m n. SUC m + n = SUC (m + n)) : thm
val SUB_RIGHT_EQ = |- !m n p. (m - n = p) = (m = n + p) \/ m <= n /\ p <= 0
  : thm
val SUB_LEFT_EQ = |- !m n p. (m = n - p) = (m + p = n) \/ m <= 0 /\ n <= p
  : thm
val SUB_RIGHT_GREATER = |- !m n p. m - n > p = m > n + p : thm
val SUB_LEFT_GREATER = |- !m n p. m > n - p = m + p > n /\ m > 0 : thm
val SUB_RIGHT_GREATER_EQ = |- !m n p. m - n >= p = m >= n + p \/ 0 >= p : thm
val SUB_LEFT_GREATER_EQ = |- !m n p. m >= n - p = m + p >= n : thm
val SUB_RIGHT_LESS = |- !m n p. m - n < p = m < n + p /\ 0 < p : thm
val SUB_LEFT_LESS = |- !m n p. m < n - p = m + p < n : thm
val SUB_RIGHT_LESS_EQ = |- !m n p. m - n <= p = m <= n + p : thm
val SUB_LEFT_LESS_EQ = |- !m n p. m <= n - p = m + p <= n \/ m <= 0 : thm
val SUB_LEFT_SUC = |- !m n. SUC (m - n) = ((m <= n) => (SUC 0) | (SUC m - n))
  : thm
val SUB_RIGHT_SUB = |- !m n p. (m - n) - p = m - (n + p) : thm
val SUB_LEFT_SUB = |- !m n p. m - n - p = ((n <= p) => m | ((m + p) - n)) : thm
val SUB_RIGHT_ADD = |- !m n p. (m - n) + p = ((m <= n) => p | ((m + p) - n))
  : thm
val SUB_LEFT_ADD = |- !m n p. m + (n - p) = ((n <= p) => m | ((m + n) - p))
  : thm
val MULT_LESS_EQ_SUC = |- !m n p. m <= n = SUC p * m <= SUC p * n : thm
val NOT_SUC_ADD_LESS_EQ = |- !m n. ~(SUC (m + n) <= m) : thm
val SUC_ADD_SYM = |- !m n. SUC (m + n) = SUC n + m : thm
val SUC_ONE_ADD = |- !n. SUC n = 1 + n : thm
val NOT_GREATER_EQ = |- !m n. ~(m >= n) = SUC m <= n : thm
val NOT_GREATER = |- !m n. ~(m > n) = m <= n : thm
val NOT_NUM_EQ = |- !m n. ~(m = n) = SUC m <= n \/ SUC n <= m : thm
val NOT_LEQ = |- !m n. ~(m <= n) = SUC n <= m : thm
val NOT_SUC_LESS_EQ_0 = |- !n. ~(SUC n <= 0) : thm
val ADD_MONO_LESS_EQ = |- !m n p. m + n <= m + p = n <= p : thm
val EQ_LESS_EQ = |- !m n. (m = n) = m <= n /\ n <= m : thm
val ODD_EXISTS = |- !n. ODD n = (?m. n = SUC (2 * m)) : thm
val EVEN_EXISTS = |- !n. EVEN n = (?m. n = 2 * m) : thm
val EVEN_ODD_EXISTS =
  |- !n. (EVEN n ==> (?m. n = 2 * m)) /\ (ODD n ==> (?m. n = SUC (2 * m)))
  : thm
val ODD_DOUBLE = |- !n. ODD (SUC (2 * n)) : thm
val EVEN_DOUBLE = |- !n. EVEN (2 * n) : thm
val ODD_MULT = |- !m n. ODD (m * n) = ODD m /\ ODD n : thm
val ODD_ADD = |- !m n. ODD (m + n) = ~(ODD m = ODD n) : thm
val EVEN_MULT = |- !m n. EVEN (m * n) = EVEN m \/ EVEN n : thm
val EVEN_ADD = |- !m n. EVEN (m + n) = EVEN m = EVEN n : thm
val EVEN_AND_ODD = |- !n. ~(EVEN n /\ ODD n) : thm
val EVEN_OR_ODD = |- !n. EVEN n \/ ODD n : thm
val ODD_EVEN = |- !n. ODD n = ~(EVEN n) : thm
val EVEN_ODD = |- !n. EVEN n = ~(ODD n) : thm
val FACT_LESS = |- !n. 0 < FACT n : thm
val LESS_LESS_EQ_TRANS = |- !m n p. m < n /\ n <= p ==> m < p : thm
val LESS_EQ_LESS_TRANS = |- !m n p. m <= n /\ n < p ==> m < p : thm
val LESS_MULT2 = |- !m n. 0 < m /\ 0 < n ==> 0 < m * n : thm
val MULT_EQ_0 = |- !m n. (m * n = 0) = (m = 0) \/ (n = 0) : thm
val LESS_EQ_0 = |- !n. n <= 0 = n = 0 : thm
val NOT_LESS_EQUAL = |- !m n. ~(m <= n) = n < m : thm
val LESS_EQ_EXISTS = |- !m n. m <= n = (?p. n = m + p) : thm
val LESS_EQUAL_ADD = |- !m n. m <= n ==> (?p. n = m + p) : thm
val LESS_EQ_CASES = |- !m n. m <= n \/ n <= m : thm
val GREATER_EQ = |- !n m. n >= m = m <= n : thm
val LESS_LESS_CASES = |- !m n. (m = n) \/ m < n \/ n < m : thm
val LESS_EXP_SUC_MONO = |- !n m. SUC (SUC m) EXP n < SUC (SUC m) EXP SUC n
  : thm
val ODD_OR_EVEN = |- !n. ?m. (n = SUC (SUC 0) * m) \/ (n = SUC (SUC 0) * m + 1)
  : thm
val ZERO_LESS_EXP = |- !m n. 0 < SUC n EXP m : thm
val NOT_EXP_0 = |- !m n. ~(SUC n EXP m = 0) : thm
val CANCEL_SUB = |- !p n m. p <= n /\ p <= m ==> ((n - p = m - p) = n = m)
  : thm
val SUB_CANCEL = |- !p n m. n <= p /\ m <= p ==> ((p - n = p - m) = n = m)
  : thm
val SUB_LESS_EQ_ADD = |- !m p. m <= p ==> (!n. p - m <= n = p <= m + n) : thm
val LESS_EQ_IMP_LESS_SUC = |- !n m. n <= m ==> n < SUC m : thm
val LESS_IMP_LESS_ADD = |- !n m. n < m ==> (!p. n < m + p) : thm
val SUB_SUB = |- !b c. c <= b ==> (!a. a - b - c = (a + c) - b) : thm
val NOT_SUC_LESS_EQ = |- !n m. ~(SUC n <= m) = m <= n : thm
val LESS_EQ_SUB_LESS = |- !a b. b <= a ==> (!c. a - b < c = a < b + c) : thm
val SUB_EQUAL_0 = |- !c. c - c = 0 : thm
val LESS_EQ_ADD_SUB = |- !c b. c <= b ==> (!a. (a + b) - c = a + (b - c)) : thm
val ADD_SUB = |- !a c. (a + c) - c = a : thm
val MULT_MONO_EQ = |- !m i n. (SUC n * m = SUC n * i) = m = i : thm
val LESS_MULT_MONO = |- !m i n. SUC n * m < SUC n * i = m < i : thm
val TIMES2 = |- !n. 2 * n = n + n : thm
val LESS_SUB_ADD_LESS = |- !n m i. i < n - m ==> i + m < n : thm
val SUB_LESS_OR = |- !m n. n < m ==> n <= m - 1 : thm
val SUB_LESS_0 = |- !n m. m < n = 0 < n - m : thm
val SUB_EQ_EQ_0 = |- !m n. (m - n = m) = (m = 0) \/ (n = 0) : thm
val SUB_LESS_EQ = |- !n m. n - m <= n : thm
val INV_PRE_LESS_EQ = |- !n. 0 < n ==> (!m. PRE m <= PRE n = m <= n) : thm
val INV_PRE_LESS = |- !m. 0 < m ==> (!n. PRE m < PRE n = m < n) : thm
val SUB_PLUS = |- !a b c. a - (b + c) = (a - b) - c : thm
val SUB_MONO_EQ = |- !n m. SUC n - SUC m = n - m : thm
val MOD_MOD = |- !n. 0 < n ==> (!k. (k MOD n) MOD n = k MOD n) : thm
val MOD_PLUS =
  |- !n. 0 < n ==> (!j k. (j MOD n + k MOD n) MOD n = (j + k) MOD n) : thm
val MOD_TIMES = |- !n. 0 < n ==> (!q r. (q * n + r) MOD n = r MOD n) : thm
val MOD_MULT = |- !n r. r < n ==> (!q. (q * n + r) MOD n = r) : thm
val ZERO_DIV = |- !n. 0 < n ==> (0 DIV n = 0) : thm
val ZERO_MOD = |- !n. 0 < n ==> (0 MOD n = 0) : thm
val MOD_EQ_0 = |- !n. 0 < n ==> (!k. (k * n) MOD n = 0) : thm
val LESS_MOD = |- !n k. k < n ==> (k MOD n = k) : thm
val DIV_MULT = |- !n r. r < n ==> (!q. (q * n + r) DIV n = q) : thm
val MOD_UNIQUE = |- !n k r. (?q. (k = q * n + r) /\ r < n) ==> (k MOD n = r)
  : thm
val DIV_UNIQUE = |- !n k q. (?r. (k = q * n + r) /\ r < n) ==> (k DIV n = q)
  : thm
val DIV_LESS_EQ = |- !n. 0 < n ==> (!k. k DIV n <= k) : thm
val MOD_ONE = |- !k. k MOD SUC 0 = 0 : thm
val DA = |- !k n. 0 < n ==> (?r q. (k = q * n + r) /\ r < n) : thm
val WOP = |- !P. (?n. P n) ==> (?n. P n /\ (!m. m < n ==> ~(P m))) : thm
val LESS_OR_EQ_ADD = |- !n m. n < m \/ (?p. n = p + m) : thm
val LESS_EQ_MONO = |- !n m. SUC n <= SUC m = n <= m : thm
val ZERO_LESS_EQ = |- !n. 0 <= n : thm
val LESS_ADD_SUC = |- !m n. m < m + SUC n : thm
val LESS_EQUAL_ANTISYM = |- !n m. n <= m /\ m <= n ==> (n = m) : thm
val MULT_EXP_MONO = |- !p q n m. (n * SUC q EXP p = m * SUC q EXP p) = n = m
  : thm
val MULT_SUC_EQ = |- !p m n. (n * SUC p = m * SUC p) = n = m : thm
val NOT_ODD_EQ_EVEN = |- !n m. ~(SUC (n + n) = m + m) : thm
val EXP_ADD = |- !p q n. n EXP (p + q) = n EXP p * n EXP q : thm
val LESS_ADD_1 = |- !m n. n < m ==> (?p. m = n + p + 1) : thm
val LEFT_SUB_DISTRIB = |- !m n p. p * (m - n) = p * m - p * n : thm
val RIGHT_SUB_DISTRIB = |- !m n p. (m - n) * p = m * p - n * p : thm
val LESS_MONO_MULT = |- !m n p. m <= n ==> m * p <= n * p : thm
val LESS_IMP_LESS_OR_EQ = |- !m n. m < n ==> m <= n : thm
val LESS_EQ_REFL = |- !m. m <= m : thm
val LESS_EQ_LESS_EQ_MONO = |- !m n p q. m <= p /\ n <= q ==> m + n <= p + q
  : thm
val LESS_EQ_TRANS = |- !m n p. m <= n /\ n <= p ==> m <= p : thm
val LESS_EQ_MONO_ADD_EQ = |- !m n p. m + p <= n + p = m <= n : thm
val EQ_MONO_ADD_EQ = |- !m n p. (m + p = n + p) = m = n : thm
val LESS_MONO_ADD_EQ = |- !m n p. m + p < n + p = m < n : thm
val LESS_MONO_ADD_INV = |- !m n p. m + p < n + p ==> m < n : thm
val LESS_MONO_ADD = |- !m n p. m < n ==> m + p < n + p : thm
val ADD_EQ_SUB = |- !m n p. n <= p ==> ((m + n = p) = m = p - n) : thm
val LESS_SUC_NOT = |- !m n. m < n ==> ~(n < SUC m) : thm
val INV_PRE_EQ = |- !m n. 0 < m /\ 0 < n ==> ((PRE m = PRE n) = m = n) : thm
val PRE_SUC_EQ = |- !m n. 0 < n ==> ((m = PRE n) = SUC m = n) : thm
val ADD_INV_0_EQ = |- !m n. (m + n = m) = n = 0 : thm
val ADD_EQ_0 = |- !m n. (m + n = 0) = (m = 0) /\ (n = 0) : thm
val PRE_SUB = |- !m n. PRE (m - n) = PRE m - n : thm
val SUB_ADD = |- !m n. n <= m ==> ((m - n) + n = m) : thm
val MULT_ASSOC = |- !m n p. m * n * p = (m * n) * p : thm
val LEFT_ADD_DISTRIB = |- !m n p. p * (m + n) = p * m + p * n : thm
val RIGHT_ADD_DISTRIB = |- !m n p. (m + n) * p = m * p + n * p : thm

[Major collection... 69% used (4824212/6896268), 860 msec]

[Increasing heap to 14436k]
val MULT_SYM = |- !m n. m * n = n * m : thm
val MULT_CLAUSES =
  |- !m n.
       (0 * m = 0) /\
       (m * 0 = 0) /\
       (1 * m = m) /\
       (m * 1 = m) /\
       (SUC m * n = m * n + n) /\
       (m * SUC n = m + m * n) : thm
val MULT_RIGHT_1 = |- !m. m * 1 = m : thm
val MULT_LEFT_1 = |- !m. 1 * m = m : thm
val MULT_SUC = |- !m n. m * SUC n = m + m * n : thm
val MULT_0 = |- !m. m * 0 = 0 : thm
val ADD_ASSOC = |- !m n p. m + n + p = (m + n) + p : thm
val SUB_EQ_0 = |- !m n. (m - n = 0) = m <= n : thm
val NOT_LESS = |- !m n. ~(m < n) = n <= m : thm
val LESS_EQ_ANTISYM = |- !m n. ~(m < n /\ n <= m) : thm
val LESS_ADD_NONZERO = |- !m n. ~(n = 0) ==> m < m + n : thm
val LESS_EQ_SUC_REFL = |- !m. m <= SUC m : thm
val LESS_EQ_ADD = |- !m n. m <= m + n : thm
val ADD_INV_0 = |- !m n. (m + n = m) ==> (n = 0) : thm
val LESS_CASES = |- !m n. m < n \/ n <= m : thm
val LESS_CASES_IMP = |- !m n. ~(m < n) /\ ~(m = n) ==> n < m : thm
val LESS_0_CASES = |- !m. (0 = m) \/ 0 < m : thm
val LESS_NOT_SUC = |- !m n. m < n /\ ~(n = SUC m) ==> SUC m < n : thm
val LESS_SUC_EQ_COR = |- !m n. m < n /\ ~(SUC m = n) ==> SUC m < n : thm
val LESS_EQ = |- !m n. m < n = SUC m <= n : thm
val OR_LESS = |- !m n. SUC m <= n ==> m < n : thm
val LESS_OR = |- !m n. m < n ==> SUC m <= n : thm
val FUN_EQ_LEMMA = |- !f x1 x2. f x1 /\ ~(f x2) ==> ~(x1 = x2) : thm
val LESS_LESS_SUC = |- !m n. ~(m < n /\ n < SUC m) : thm
val LESS_ANTISYM = |- !m n. ~(m < n /\ n < m) : thm
val ADD1 = |- !m. SUC m = m + 1 : thm
val LESS_TRANS = |- !m n p. m < n /\ n < p ==> m < p : thm
val SUB_0 = |- !m. (0 - m = 0) /\ (m - 0 = m) : thm
val LESS_ADD = |- !m n. n < m ==> (?p. p + n = m) : thm
val PRE_SUB1 = |- !m. PRE m = m - 1 : thm
val SUC_SUB1 = |- !m. SUC m - 1 = m : thm
val LESS_MONO_EQ = |- !m n. SUC m < SUC n = m < n : thm
val LESS_MONO_REV = |- !m n. SUC m < SUC n ==> m < n : thm
val num_CASES = |- !m. (m = 0) \/ (?n. m = SUC n) : thm
val ADD_SYM = |- !m n. m + n = n + m : thm
val ADD_CLAUSES =
  |- (0 + m = m) /\
     (m + 0 = m) /\
     (SUC m + n = SUC (m + n)) /\
     (m + SUC n = SUC (m + n)) : thm
val ADD_SUC = |- !m n. SUC (m + n) = m + SUC n : thm
val ADD_0 = |- !m. m + 0 = m : thm
val SUC_NOT = |- !n. ~(0 = SUC n) : thm
val it = () : unit


          HHH                 LL
          HHH                  LL
          HHH                   LL
          HHH                    LL
          HHH          OOOO       LL
          HHHHHHH     OO  OO       LL
          HHHHHHH     OO  OO       LLL
          HHH          OOOO        LLLL
          HHH                     LL  LL
          HHH                    LL    LL
          HHH                   LL      LL
          HHH                  LL        LL90.7

Created on Tue Jan 23 15:29:20 GMT 1996
using: Standard ML of New Jersey, Version 0.93, February 15, 1993



The library "BASIC_HOL" is loaded.
- = 
Loading theory "list"

Theory "BASIC_HOL" already consistent with disk, hence not exported.
val EVERY_DEF =
  |- (!P. EVERY P [] = T) /\ (!P h t. EVERY P (CONS h t) = P h /\ EVERY P t)
  : thm
val EL = |- (!l. EL 0 l = HD l) /\ (!l n. EL (SUC n) l = EL n (TL l)) : thm
val MAP2 =
  |- (!f. MAP2 f [] [] = []) /\
     (!f h1 t1 h2 t2.
       MAP2 f (CONS h1 t1) (CONS h2 t2) = CONS (f h1 h2) (MAP2 f t1 t2)) : thm
val MAP =
  |- (!f. MAP f [] = []) /\ (!f h t. MAP f (CONS h t) = CONS (f h) (MAP f t))
  : thm
val LENGTH = |- (LENGTH [] = 0) /\ (!h t. LENGTH (CONS h t) = SUC (LENGTH t))
  : thm
val FLAT = |- (FLAT [] = []) /\ (!h t. FLAT (CONS h t) = APPEND h (FLAT t))
  : thm
val APPEND =
  |- (!l. APPEND [] l = l) /\
     (!l1 l2 h. APPEND (CONS h l1) l2 = CONS h (APPEND l1 l2)) : thm
val SUM = |- (SUM [] = 0) /\ (!h t. SUM (CONS h t) = h + SUM t) : thm
val TL = |- !t h. TL (CONS h t) = t : thm
val HD = |- !t h. HD (CONS h t) = h : thm
val NULL_DEF = |- (NULL [] = T) /\ (!t h. NULL (CONS h t) = F) : thm
val LENGTH_CONS =
  |- !l n. (LENGTH l = SUC n) = (?h l'. (LENGTH l' = n) /\ (l = CONS h l'))
  : thm
val LENGTH_NIL = |- !l. (LENGTH l = 0) = l = [] : thm
val EVERY_CONJ = |- !l. EVERY (\x. P x /\ Q x) l = EVERY P l /\ EVERY Q l : thm
val EVERY_EL = |- !l P. EVERY P l = (!n. n < LENGTH l ==> P (EL n l)) : thm
val LENGTH_MAP = |- !l f. LENGTH (MAP f l) = LENGTH l : thm
val MAP_APPEND =
  |- !f l1 l2. MAP f (APPEND l1 l2) = APPEND (MAP f l1) (MAP f l2) : thm
val LENGTH_APPEND = |- !l1 l2. LENGTH (APPEND l1 l2) = LENGTH l1 + LENGTH l2
  : thm
val APPEND_ASSOC =
  |- !l1 l2 l3. APPEND l1 (APPEND l2 l3) = APPEND (APPEND l1 l2) l3 : thm
val CONS = |- !l. ~(NULL l) ==> (CONS (HD l) (TL l) = l) : thm
val EQ_LIST =
  |- !h1 h2. (h1 = h2) ==> (!l1 l2. (l1 = l2) ==> (CONS h1 l1 = CONS h2 l2))
  : thm
val NOT_EQ_LIST =
  |- !h1 h2. ~(h1 = h2) ==> (!l1 l2. ~(CONS h1 l1 = CONS h2 l2)) : thm
val LIST_NOT_EQ =
  |- !l1 l2. ~(l1 = l2) ==> (!h1 h2. ~(CONS h1 l1 = CONS h2 l2)) : thm
val NOT_CONS_NIL = |- !t h. ~(CONS h t = []) : thm
val NOT_NIL_CONS = |- !t h. ~([] = CONS h t) : thm
val CONS_11 = |- !h t h' t'. (CONS h t = CONS h' t') = (h = h') /\ (t = t')
  : thm
val list_CASES = |- !l. (l = []) \/ (?t h. l = CONS h t) : thm
val list_INDUCT = |- !P. P [] /\ (!t. P t ==> (!h. P (CONS h t))) ==> (!l. P l)
  : thm
val NULL = |- NULL [] /\ (!h t. ~(NULL (CONS h t))) : thm
val list_Axiom =
  |- !x f. ?!fn1. (fn1 [] = x) /\ (!h t. fn1 (CONS h t) = f (fn1 t) h t) : thm
val it = () : unit


          HHH                 LL
          HHH                  LL
          HHH                   LL
          HHH                    LL
          HHH          OOOO       LL
          HHHHHHH     OO  OO       LL
          HHHHHHH     OO  OO       LLL
          HHH          OOOO        LLLL
          HHH                     LL  LL
          HHH                    LL    LL
          HHH                   LL      LL
          HHH                  LL        LL90.7

Created on Tue Jan 23 15:29:20 GMT 1996
using: Standard ML of New Jersey, Version 0.93, February 15, 1993



The library "BASIC_HOL" is loaded.
- = val it = () : unit


          HHH                 LL
          HHH                  LL
          HHH                   LL
          HHH                    LL
          HHH          OOOO       LL
          HHHHHHH     OO  OO       LL
          HHHHHHH     OO  OO       LLL
          HHH          OOOO        LLLL
          HHH                     LL  LL
          HHH                    LL    LL
          HHH                   LL      LL
          HHH                  LL        LL90.7

Created on Tue Jan 23 15:29:20 GMT 1996
using: Standard ML of New Jersey, Version 0.93, February 15, 1993



The library "BASIC_HOL" is loaded.
- = 
Loading theory "tree"

Theory "BASIC_HOL" already consistent with disk, hence not exported.
val trf =
  |- !n f.
       trf n f =
       (@fn. !trl. HT (node trl) <= n ==> (fn (node trl) = f (MAP fn trl)))
  : thm
val HT = |- !t. HT t = (@n. bht n t /\ (!m. m < n ==> ~(bht m t))) : thm
val bht =
  |- bht =
     PRIM_REC (\tr. tr = node [])
       (\res n tr. ?trl. (tr = node trl) /\ EVERY res trl) : thm
val dest_node = |- !t. dest_node t = (@p. t = node p) : thm
val node = |- !tl. node tl = ABS_tree (node_REP (MAP REP_tree tl)) : thm
val tree_ISO_DEF =
  |- (!a. ABS_tree (REP_tree a) = a) /\
     (!r. Is_tree_REP r = REP_tree (ABS_tree r) = r) : thm
val tree_TY_DEF = |- ?rep. TYPE_DEFINITION Is_tree_REP rep : thm
val Is_tree_REP =
  |- Is_tree_REP = (\t. !P. (!tl. EVERY P tl ==> P (node_REP tl)) ==> P t)
  : thm
val node_REP =
  |- (node_REP [] = 0) /\
     (!t h. node_REP (CONS h t) = SUC (h + h) * 2 EXP node_REP t) : thm
val tree_Axiom = |- !f. ?!fn. !tl. fn (node tl) = f (MAP fn tl) tl : thm
val tree_Induct = |- !P. (!tl. EVERY P tl ==> P (node tl)) ==> (!t. P t) : thm
val node_11 = |- !tl1 tl2. (node tl1 = node tl2) = tl1 = tl2 : thm
val it = () : unit


          HHH                 LL
          HHH                  LL
          HHH                   LL
          HHH                    LL
          HHH          OOOO       LL
          HHHHHHH     OO  OO       LL
          HHHHHHH     OO  OO       LLL
          HHH          OOOO        LLLL
          HHH                     LL  LL
          HHH                    LL    LL
          HHH                   LL      LL
          HHH                  LL        LL90.7

Created on Tue Jan 23 15:29:20 GMT 1996
using: Standard ML of New Jersey, Version 0.93, February 15, 1993



The library "BASIC_HOL" is loaded.
- = 
Loading theory "ltree"

Theory "BASIC_HOL" already consistent with disk, hence not exported.
val PART =
  |- (!l. PART [] l = []) /\
     (!n t l.
       PART (CONS n t) l = CONS (FST (SPLIT n l)) (PART t (SND (SPLIT n l))))
  : thm
val SPLIT =
  |- (!l. SPLIT 0 l = ([],l)) /\
     (!n l.
       SPLIT (SUC n) l =
       (CONS (HD l) (FST (SPLIT n (TL l))),SND (SPLIT n (TL l)))) : thm
val AP =
  |- (!l. AP [] l = []) /\
     (!h t l. AP (CONS h t) l = CONS (h (HD l)) (AP t (TL l))) : thm
val Node =
  |- !v tl.
       Node v tl =
       ABS_ltree
         (node (MAP (FST o REP_ltree) tl),
          CONS v (FLAT (MAP (SND o REP_ltree) tl))) : thm
val ltree_ISO_DEF =
  |- (!a. ABS_ltree (REP_ltree a) = a) /\
     (!r. Is_ltree r = REP_ltree (ABS_ltree r) = r) : thm
val ltree_TY_DEF = |- ?rep. TYPE_DEFINITION Is_ltree rep : thm
val Is_ltree = |- !t l. Is_ltree (t,l) = size t = LENGTH l : thm
val size = |- size = (@fn. !tl. fn (node tl) = SUC (SUM (MAP fn tl))) : thm
val Node_onto = |- !l. ?v trl. l = Node v trl : thm
val Node_11 =
  |- !v1 v2 trl1 trl2.
       (Node v1 trl1 = Node v2 trl2) = (v1 = v2) /\ (trl1 = trl2) : thm
val ltree_Induct = |- !P. (!t. EVERY P t ==> (!h. P (Node h t))) ==> (!l. P l)
  : thm
val ltree_Axiom = |- !f. ?!fn. !v tl. fn (Node v tl) = f (MAP fn tl) v tl : thm
val it = () : unit


          HHH                 LL
          HHH                  LL
          HHH                   LL
          HHH                    LL
          HHH          OOOO       LL
          HHHHHHH     OO  OO       LL
          HHHHHHH     OO  OO       LLL
          HHH          OOOO        LLLL
          HHH                     LL  LL
          HHH                    LL    LL
          HHH                   LL      LL
          HHH                  LL        LL90.7

Created on Tue Jan 23 15:29:20 GMT 1996
using: Standard ML of New Jersey, Version 0.93, February 15, 1993



The library "BASIC_HOL" is loaded.
- = 
Loading theory "rec_type"

Theory "BASIC_HOL" already consistent with disk, hence not exported.
val exists_TRP = |- !P. (?v. P v []) ==> (?t. TRP P t) : thm
val TY_DEF_THM =
  |- !REP ABS P.
       (!a. ABS (REP a) = a) /\ (!r. TRP P r = REP (ABS r) = r) ==>
       (!f.
         ?!fn.
           !v tl.
             P v (MAP REP tl) ==>
             (fn (ABS (Node v (MAP REP tl))) = f (MAP fn tl) v tl)) : thm
val it = () : unit


          HHH                 LL
          HHH                  LL
          HHH                   LL
          HHH                    LL
          HHH          OOOO       LL
          HHHHHHH     OO  OO       LL
          HHHHHHH     OO  OO       LLL
          HHH          OOOO        LLLL
          HHH                     LL  LL
          HHH                    LL    LL
          HHH                   LL      LL
          HHH                  LL        LL90.7

Created on Tue Jan 23 15:29:20 GMT 1996
using: Standard ML of New Jersey, Version 0.93, February 15, 1993



The library "BASIC_HOL" is loaded.
- [opening 3/sys_lib.sig]
signature Sys_lib_sig =
  sig
    val prim_hol_lib : lib
    val basic_hol_lib : lib
    val hol_lib : lib
    val string_lib : lib
    val num_lib : lib
    val reduce_lib : lib
    val arith_lib : lib
    val set_lib : lib
    val pred_set_lib : lib
    val unwind_lib : lib
    val taut_lib : lib
    val hol88_lib : lib
    val ind_def_lib : lib
    val utils_lib : lib
    val group_lib : lib
    val integer_lib : lib
    val abs_theory_lib : lib
    val unity_lib : lib
    val prog_logic_lib : lib
    val pair_lib : lib
    val real_lib : lib
    val wellorder_lib : lib
    val window_lib : lib
    val list_lib : lib
    val res_quan_lib : lib
    val word_lib : lib
  end
val it = () : unit
[opening 3/sys_lib.sml]
structure Sys_lib : Sys_lib_sig
val it = () : unit

Loading theory "HOL"

Theory "BASIC_HOL" already consistent with disk, hence not exported.
val it = () : unit

Loading the library "HOL".

The library "BASIC_HOL" is already loaded.

  The parent libraries of library "HOL" have been loaded.

  The theories belonging to library "HOL" have been incorporated.
[opening /usr/groups/hol/hol90.7/solaris/src/3/define_type.sig]
signature Define_type_sig =
  sig
    val dtype : {clauses:{args:Parse_support.arg list, constructor:string,
                          fixity:fixity} list, save_name:string,
                 ty_name:string}
                -> thm
    val define_type : {fixities:fixity list, name:string,
                       type_spec:term frag list}
                      -> thm
    val string_define_type : string -> string -> fixity list -> thm
  end

[Major collection... 77% used (5383196/6936636), 1130 msec]

[Increasing heap to 16696k]
[opening /usr/groups/hol/hol90.7/solaris/src/3/define_type.sml]
.../src/3/define_type.sml:1233.8-1233.45 Warning: binding not exhaustive
          l1 :: lab :: l2 :: nil = ...
.../src/3/define_type.sml:1203.8-1203.49 Warning: binding not exhaustive
          (_,f :: s :: nil) = ...
.../src/3/define_type.sml:1148.8-1148.51 Warning: binding not exhaustive
          {Args=lty :: rty :: nil,...} = ...
.../src/3/define_type.sml:1114.8-1114.44 Warning: binding not exhaustive
          {Args=ty :: nil,...} = ...
.../src/3/define_type.sml:1104.8-1104.49 Warning: binding not exhaustive
          (_,h :: t :: nil) = ...
.../src/3/define_type.sml:1079.8-1079.43 Warning: binding not exhaustive
          (C,test :: a :: b :: nil) = ...
.../src/3/define_type.sml:1010.8-1010.55 Warning: binding not exhaustive
          {Args=resty :: nil,...} = ...
.../src/3/define_type.sml:1009.8-1009.74 Warning: binding not exhaustive
          (f,rl :: value :: ts :: nil) = ...
.../src/3/define_type.sml:989.34-991.69 Warning: match nonexhaustive
          (nil,h :: _) => ...
          (h1 :: t1,h2 :: t2) => ...
  
.../src/3/define_type.sml:968.4-976.6 Warning: match nonexhaustive
          (ty,rv,tv,(fl,(pv,(name,rl :: value :: tl :: nil)))) => ...
  
.../src/3/define_type.sml:901.8-901.48 Warning: binding not exhaustive
          {Args=ty1 :: ty2 :: nil,...} = ...
.../src/3/define_type.sml:900.8-900.38 Warning: binding not exhaustive
          (_,c1 :: c2 :: nil) = ...
.../src/3/define_type.sml:856.15-856.43 Warning: binding not exhaustive
          (_,h :: t :: nil) = ...
.../src/3/define_type.sml:852.8-852.42 Warning: binding not exhaustive
          {Args=ety :: nil,...} = ...
.../src/3/define_type.sml:829.11-829.51 Warning: binding not exhaustive
          {Args=ty1 :: ty2 :: nil,...} = ...
.../src/3/define_type.sml:827.23-836.9 Warning: match nonexhaustive
          (v,c :: nil,_) => ...
          (v,c :: cs,ty) => ...
  
.../src/3/define_type.sml:797.9-797.49 Warning: binding not exhaustive
          {Args=_ :: outty :: nil,...} = ...
.../src/3/define_type.sml:795.24-804.7 Warning: match nonexhaustive
          (c :: nil,_,_) => ...
          (c :: cs,v,ty) => ...
  
.../src/3/define_type.sml:760.28-762.53 Warning: match nonexhaustive
          (f,(nil,nil,nil,nil)) => ...
          (f,(a :: rst1,b :: rst2,c :: rst3,d :: rst4)) => ...
  
.../src/3/define_type.sml:726.8-726.64 Warning: binding not exhaustive
          (vs,(EQ,l :: r :: nil)) = ...
.../src/3/define_type.sml:692.25-693.45 Warning: match nonexhaustive
          (0,prefix,suffix) => ...
          (n,prefix,h :: t) => ...
  
.../src/3/define_type.sml:658.8-658.43 Warning: binding not exhaustive
          (v :: tl :: nil,imp) = ...
.../src/3/define_type.sml:606.8-606.40 Warning: binding not exhaustive
          (f,a1 :: a2 :: a3 :: nil) = ...
.../src/3/define_type.sml:601.8-601.64 Warning: binding not exhaustive
          (vs,(EQ,l :: r :: nil)) = ...
.../src/3/define_type.sml:590.8-590.36 Warning: binding not exhaustive
          (_,f :: l :: nil) = ...
.../src/3/define_type.sml:581.8-581.35 Warning: binding not exhaustive
          (_,h :: t :: nil) = ...
.../src/3/define_type.sml:557.8-557.40 Warning: binding not exhaustive
          ty :: nil = ...
.../src/3/define_type.sml:537.13-537.27 Warning: binding not exhaustive
          h :: t = ...
.../src/3/define_type.sml:434.8-434.68 Warning: binding not exhaustive
          (v :: tl :: nil,{ant=ant,conseq=conseq}) = ...
.../src/3/define_type.sml:372.8-372.59 Warning: binding not exhaustive
          (x :: y :: nil,cs) = ...
.../src/3/define_type.sml:264.8-264.58 Warning: binding not exhaustive
          (v :: tl :: nil,cs) = ...
.../src/3/define_type.sml:221.4-223.34 Warning: match nonexhaustive
          (p,prefix,x :: suffix) => ...
  
.../src/3/define_type.sml:103.10-103.50 Warning: binding not exhaustive
          {Args=lty :: rty :: nil,...} = ...
.../src/3/define_type.sml:101.21-111.8 Warning: match nonexhaustive
          (ty,v :: nil) => ...
          (ty,v :: vs) => ...
  

[Major collection... 68% used (6137356/8922676), 1440 msec]

[Increasing heap to 19144k]

[Major collection... 58% used (5717744/9833396), 1370 msec]

[Major collection... 61% used (6162212/10080024), 1430 msec]

[Increasing heap to 19252k]

[Major collection... 60% used (6172560/10213980), 1400 msec]

[Increasing heap to 19272k]

[Major collection... 55% used (5542024/9907524), 1190 msec]

[Major collection... 54% used (5599768/10187232), 1180 msec]

[Major collection... 55% used (5543432/10033064), 1160 msec]

[Major collection... 61% used (6075728/9933328), 1350 msec]

[Increasing heap to 19844k]

[Major collection... 70% used (7172356/10159688), 1510 msec]

[Increasing heap to 21200k]

[Major collection... 54% used (6342380/11596212), 1560 msec]

[Increasing heap to 22084k]

[Major collection... 66% used (7830440/11748220), 1830 msec]

[Increasing heap to 24896k]
structure Define_type : Define_type_sig
[opening /usr/groups/hol/hol90.7/solaris/src/3/gstack.sig]
signature Goalstack_sig =
  sig
    structure Thm : ...
    type goalstack
    type proofs
    structure Functional : ...
    structure Implicit : ...
    val set_goal_pp : (System.PrettyPrint.ppstream -> goal -> unit)
                      -> System.PrettyPrint.ppstream -> goal -> unit
    val pp_goalstack : System.PrettyPrint.ppstream -> goalstack -> unit
    val pp_proofs : System.PrettyPrint.ppstream -> proofs -> unit
  end
[opening /usr/groups/hol/hol90.7/solaris/src/3/gstack.sml]

[Major collection... 41% used (5363820/12935544), 1060 msec]

[Decreasing heap to 16504k]
structure Goalstack : Goalstack_sig
[opening /usr/groups/hol/hol90.7/solaris/src/3/psyntax.sig]
signature Psyntax_sig =
  sig
    val INST : (term * term) list -> thm -> thm
    val INST_TYPE : (hol_type * hol_type) list -> thm -> thm
    val INST_TY_TERM : (term * term) list * (hol_type * hol_type) list
                       -> thm -> thm
    val SUBST : (thm * term) list -> term -> thm -> thm
    val SUBST_CONV : (thm * term) list -> term -> term -> thm
    val define_new_type_bijections : string -> string -> string -> thm -> thm
    val dest_abs : term -> term * term
    val dest_comb : term -> term * term
    val dest_cond : term -> term * term * term
    val dest_conj : term -> term * term
    val dest_cons : term -> term * term
    val dest_const : term -> string * hol_type
    val dest_disj : term -> term * term
    val dest_eq : term -> term * term
    val dest_exists : term -> term * term
    val dest_forall : term -> term * term
    val dest_imp : term -> term * term
    val dest_let : term -> term * term
    val dest_list : term -> term list * hol_type
    val dest_pabs : term -> term * term
    val dest_pair : term -> term * term
    val dest_select : term -> term * term
    val dest_type : hol_type -> string * hol_type list
    val dest_var : term -> string * hol_type
    val inst : (hol_type * hol_type) list -> term -> term
    val match_term : term
                     -> term -> (term * term) list * (hol_type * hol_type) list
    val match_type : hol_type -> hol_type -> (hol_type * hol_type) list
    val mk_abs : term * term -> term
    val mk_comb : term * term -> term
    val mk_cond : term * term * term -> term
    val mk_conj : term * term -> term
    val mk_cons : term * term -> term
    val mk_const : string * hol_type -> term
    val mk_disj : term * term -> term
    val mk_eq : term * term -> term
    val mk_exists : term * term -> term
    val mk_forall : term * term -> term
    val mk_imp : term * term -> term
    val mk_let : term * term -> term
    val mk_list : term list * hol_type -> term
    val mk_pabs : term * term -> term
    val mk_pair : term * term -> term
    val mk_primed_var : string * hol_type -> term
    val mk_select : term * term -> term
    val mk_type : string * hol_type list -> hol_type
    val mk_var : string * hol_type -> term
    val new_binder : string * hol_type -> unit
    val new_constant : string * hol_type -> unit
    val new_infix : string * hol_type * int -> unit
    val new_recursive_definition : fixity -> thm -> string -> term -> thm
    val new_specification : string
                            -> (string * string * int) list -> thm -> thm
    val new_type : int -> string -> unit
    val new_type_definition : string * term * thm -> thm
    val subst : (term * term) list -> term -> term
    val subst_occs : int list list -> (term * term) list -> term -> term
    val type_subst : (hol_type * hol_type) list -> hol_type -> hol_type
  end
[opening /usr/groups/hol/hol90.7/solaris/src/3/rsyntax.sig]
signature Rsyntax_sig =
  sig
    val INST : term subst -> thm -> thm
    val INST_TYPE : hol_type subst -> thm -> thm
    val INST_TY_TERM : term subst * hol_type subst -> thm -> thm
    val SUBST : {thm:thm, var:term} list -> term -> thm -> thm
    val SUBST_CONV : {thm:thm, var:term} list -> term -> term -> thm
    val define_new_type_bijections : {ABS:string, REP:string, name:string,
                                      tyax:thm}
                                     -> thm
    val dest_abs : term -> {Body:term, Bvar:term}
    val dest_comb : term -> {Rand:term, Rator:term}
    val dest_cond : term -> {cond:term, larm:term, rarm:term}
    val dest_conj : term -> {conj1:term, conj2:term}
    val dest_cons : term -> {hd:term, tl:term}
    val dest_const : term -> {Name:string, Ty:hol_type}
    val dest_disj : term -> {disj1:term, disj2:term}
    val dest_eq : term -> {lhs:term, rhs:term}
    val dest_exists : term -> {Body:term, Bvar:term}
    val dest_forall : term -> {Body:term, Bvar:term}
    val dest_imp : term -> {ant:term, conseq:term}
    val dest_let : term -> {arg:term, func:term}
    val dest_list : term -> {els:term list, ty:hol_type}
    val dest_pabs : term -> {body:term, varstruct:term}
    val dest_pair : term -> {fst:term, snd:term}
    val dest_select : term -> {Body:term, Bvar:term}
    val dest_type : hol_type -> {Args:hol_type list, Tyop:string}
    val dest_var : term -> {Name:string, Ty:hol_type}
    val inst : hol_type subst -> term -> term
    val match_term : term -> term -> term subst * hol_type subst
    val match_type : hol_type -> hol_type -> hol_type subst
    val mk_abs : {Body:term, Bvar:term} -> term
    val mk_comb : {Rand:term, Rator:term} -> term
    val mk_cond : {cond:term, larm:term, rarm:term} -> term
    val mk_conj : {conj1:term, conj2:term} -> term
    val mk_cons : {hd:term, tl:term} -> term
    val mk_const : {Name:string, Ty:hol_type} -> term
    val mk_disj : {disj1:term, disj2:term} -> term
    val mk_eq : {lhs:term, rhs:term} -> term
    val mk_exists : {Body:term, Bvar:term} -> term
    val mk_forall : {Body:term, Bvar:term} -> term
    val mk_imp : {ant:term, conseq:term} -> term
    val mk_let : {arg:term, func:term} -> term
    val mk_list : {els:term list, ty:hol_type} -> term
    val mk_pabs : {body:term, varstruct:term} -> term
    val mk_pair : {fst:term, snd:term} -> term
    val mk_primed_var : {Name:string, Ty:hol_type} -> term
    val mk_select : {Body:term, Bvar:term} -> term
    val mk_type : {Args:hol_type list, Tyop:string} -> hol_type
    val mk_var : {Name:string, Ty:hol_type} -> term
    val new_binder : {Name:string, Ty:hol_type} -> unit
    val new_constant : {Name:string, Ty:hol_type} -> unit
    val new_infix : {Name:string, Prec:int, Ty:hol_type} -> unit
    val new_recursive_definition : {def:term, fixity:fixity, name:string,
                                    rec_axiom:thm}
                                   -> thm
    val new_specification : {consts:{const_name:string, fixity:fixity} list,
                             name:string, sat_thm:thm}
                            -> thm
    val new_type : {Arity:int, Name:string} -> unit
    val new_type_definition : {inhab_thm:thm, name:string, pred:term} -> thm
    val subst : term subst -> term -> term
    val subst_occs : int list list -> term subst -> term -> term
    val type_subst : hol_type subst -> hol_type -> hol_type
  end
[opening /usr/groups/hol/hol90.7/solaris/src/3/psyntax.sml]
structure Psyntax : Psyntax_sig
[opening /usr/groups/hol/hol90.7/solaris/src/3/rsyntax.sml]
structure Rsyntax : Rsyntax_sig

  The code of library "HOL" has been loaded.

  The help path for library "HOL" has been adjusted.
open Goalstack
structure Thm : Thm_sig
structure Functional :
  sig
    val set_goal : goal -> goalstack
    val add : goalstack -> proofs -> proofs
    val backup : goalstack -> goalstack
    val set_backup : int -> goalstack -> goalstack
    val restart : goalstack -> goalstack
    val drop : proofs -> proofs
    val expandf : tactic -> goalstack -> goalstack
    val current_goalstack : proofs -> goalstack
    val top_thm : goalstack -> thm
    val initial_goal : goalstack -> goal
    val top_goal : goalstack -> goal
    val top_goals : goalstack -> goal list
    val rotate : int -> goalstack -> goalstack
    val rotate_proofs : int -> proofs -> proofs
  end
structure Implicit :
  sig
    val set_goal : goal -> proofs
    val g : term frag list -> proofs
    val add : goalstack -> proofs
    val backup : unit -> goalstack
    val b : unit -> goalstack
    val set_backup : int -> unit
    val restart : unit -> goalstack
    val drop : unit -> proofs
    val expandf : tactic -> goalstack
    val expand : tactic -> goalstack
    val e : tactic -> goalstack
    val top_thm : unit -> thm
    val initial_goal : unit -> goal
    val top_goal : unit -> goal
    val top_goals : unit -> goal list
    val p : unit -> goalstack
    val status : unit -> proofs
    val rotate : int -> goalstack
    val rotate_proofs : int -> proofs
    val r : int -> goalstack
    val R : int -> proofs
  end
val set_goal_pp = fn
  : (System.PrettyPrint.ppstream -> goal -> unit)
    -> System.PrettyPrint.ppstream -> goal -> unit
val pp_goalstack = fn : System.PrettyPrint.ppstream -> goalstack -> unit
val pp_proofs = fn : System.PrettyPrint.ppstream -> proofs -> unit
open Implicit
val set_goal = fn : goal -> proofs
val g = fn : term frag list -> proofs
val add = fn : goalstack -> proofs
val backup = fn : unit -> goalstack
val b = fn : unit -> goalstack
val set_backup = fn : int -> unit
val restart = fn : unit -> goalstack
val drop = fn : unit -> proofs
val expandf = fn : tactic -> goalstack
val expand = fn : tactic -> goalstack
val e = fn : tactic -> goalstack
val top_thm = fn : unit -> thm
val initial_goal = fn : unit -> goal
val top_goal = fn : unit -> goal
val top_goals = fn : unit -> goal list
val p = fn : unit -> goalstack
val status = fn : unit -> proofs
val rotate = fn : int -> goalstack
val rotate_proofs = fn : int -> proofs
val r = fn : int -> goalstack
val R = fn : int -> proofs
open Define_type Sys_lib Rsyntax
val dtype = fn
  : {clauses:{args:Parse_support.arg list, constructor:string, fixity:fixity} 
               list, save_name:string, ty_name:string}
    -> thm
val define_type = fn
  : {fixities:fixity list, name:string, type_spec:term frag list} -> thm
val string_define_type = fn : string -> string -> fixity list -> thm
val prim_hol_lib =
  library name: PRIM_HOL
  description: Derived rules and such. Preloaded
  parents: []
   : lib
val basic_hol_lib =
  library name: BASIC_HOL
  description: Supplies numbers and pairs. Preloaded.
  parents: [PRIM_HOL]
   : lib
val hol_lib =
  library name: HOL
  description: Arithmetic, lists, trees, and recursive types. Preloaded.
  parents: [BASIC_HOL]
   : lib
val string_lib =
  library name: string
  description: The system string library, by Mike Gordon and Tom Melham
  parents: [HOL]
   : lib
val num_lib =
  library name: num
  description:
  The system library supporting proofs about numbers, due to John Harrison
  parents: [HOL]
   : lib
val reduce_lib =
  library name: reduce
  description:
  The system library for normalizing {bool,num} terms, by John Harrison
  parents: [HOL]
   : lib
val arith_lib =
  library name: arith
  description:
  The system linear arithmetic decision procedure library, by Richard Boulton
  parents: [reduce]
   : lib
val set_lib =
  library name: set
  description: The system library of sets, due to Tom Melham and P. Leveilley
  parents: [num]
   : lib
val pred_set_lib =
  library name: pred_set
  description:
  The library of sets-as-predicates, due to Tom Melham and Ton Kalker
  parents: [num]
   : lib
val unwind_lib =
  library name: unwind
  description:
  The system library for unwinding hardware lines, by Richard Boulton
  parents: [HOL]
   : lib
val taut_lib =
  library name: taut
  description: The system tautology checker library, by Richard Boulton
  parents: [HOL]
   : lib
val hol88_lib =
  library name: hol88
  description: A library for compatibility with hol88, by Konrad Slind
  parents: [HOL]
   : lib
val ind_def_lib =
  library name: ind_def
  description: The system inductive definition package, by Tom Melham
  parents: [hol88]
   : lib
val utils_lib =
  library name: utils
  description: A library of useful functions, by Elsa Gunter
  parents: [HOL]
   : lib
val group_lib =
  library name: group
  description: The system library of groups, by Elsa Gunter
  parents: [utils]
   : lib
val integer_lib =
  library name: integer
  description: The system library of integers, by Elsa Gunter
  parents: [group]
   : lib
val abs_theory_lib =
  library name: abs_theory
  description:
  A library for abstract theory operations, by Phil Windley and David Shepherd
  parents: [HOL]
   : lib
val unity_lib =
  library name: unity
  description:
  A library defining Chandy and Misra's UNITY logic, due to Flemming Andersen
  parents: [HOL]
   : lib
val prog_logic_lib =
  library name: prog_logic
  description:
  Various programming logics in HOL, by Mike Gordon, translator: Matthew Morley
  parents: [string]
   : lib
val pair_lib =
  library name: pair
  description:
  A library for manipulating pairs, by J. Grundy, translated by D. Shepherd
  parents: [HOL]
   : lib
val real_lib =
  library name: real
  description: The system library for real numbers, by John Harrison
  parents: [HOL]
   : lib
val wellorder_lib =
  library name: wellorder
  description:
  Theorems about the Axiom of Choice and wellordered sets, by John Harrison
  parents: [HOL]
   : lib
val window_lib =
  library name: window
  description: Support for transformational reasoning, by Jim Grundy
  parents: [HOL]
   : lib
val list_lib =
  library name: list
  description: Extended support for lists, by Paul Curzon and Wai Wong
  parents: [HOL]
   : lib
val res_quan_lib =
  library name: res_quan
  description: Support for restricted quantification, by Wai Wong
  parents: [HOL]
   : lib
val word_lib =
  library name: word
  description: Support for bit vectors, by Wai Wong
  parents: [num, res_quan, list]
   : lib
val INST = fn : term subst -> thm -> thm
val INST_TYPE = fn : hol_type subst -> thm -> thm
val INST_TY_TERM = fn : term subst * hol_type subst -> thm -> thm
val SUBST = fn : {thm:thm, var:term} list -> term -> thm -> thm
val SUBST_CONV = fn : {thm:thm, var:term} list -> term -> term -> thm
val define_new_type_bijections = fn
  : {ABS:string, REP:string, name:string, tyax:thm} -> thm
val dest_abs = fn : term -> {Body:term, Bvar:term}
val dest_comb = fn : term -> {Rand:term, Rator:term}
val dest_cond = fn : term -> {cond:term, larm:term, rarm:term}
val dest_conj = fn : term -> {conj1:term, conj2:term}
val dest_cons = fn : term -> {hd:term, tl:term}
val dest_const = fn : term -> {Name:string, Ty:hol_type}
val dest_disj = fn : term -> {disj1:term, disj2:term}
val dest_eq = fn : term -> {lhs:term, rhs:term}
val dest_exists = fn : term -> {Body:term, Bvar:term}
val dest_forall = fn : term -> {Body:term, Bvar:term}
val dest_imp = fn : term -> {ant:term, conseq:term}
val dest_let = fn : term -> {arg:term, func:term}
val dest_list = fn : term -> {els:term list, ty:hol_type}
val dest_pabs = fn : term -> {body:term, varstruct:term}
val dest_pair = fn : term -> {fst:term, snd:term}
val dest_select = fn : term -> {Body:term, Bvar:term}
val dest_type = fn : hol_type -> {Args:hol_type list, Tyop:string}
val dest_var = fn : term -> {Name:string, Ty:hol_type}
val inst = fn : hol_type subst -> term -> term
val match_term = fn : term -> term -> term subst * hol_type subst
val match_type = fn : hol_type -> hol_type -> hol_type subst
val mk_abs = fn : {Body:term, Bvar:term} -> term
val mk_comb = fn : {Rand:term, Rator:term} -> term
val mk_cond = fn : {cond:term, larm:term, rarm:term} -> term
val mk_conj = fn : {conj1:term, conj2:term} -> term
val mk_cons = fn : {hd:term, tl:term} -> term
val mk_const = fn : {Name:string, Ty:hol_type} -> term
val mk_disj = fn : {disj1:term, disj2:term} -> term
val mk_eq = fn : {lhs:term, rhs:term} -> term
val mk_exists = fn : {Body:term, Bvar:term} -> term
val mk_forall = fn : {Body:term, Bvar:term} -> term
val mk_imp = fn : {ant:term, conseq:term} -> term
val mk_let = fn : {arg:term, func:term} -> term
val mk_list = fn : {els:term list, ty:hol_type} -> term
val mk_pabs = fn : {body:term, varstruct:term} -> term
val mk_pair = fn : {fst:term, snd:term} -> term
val mk_primed_var = fn : {Name:string, Ty:hol_type} -> term
val mk_select = fn : {Body:term, Bvar:term} -> term
val mk_type = fn : {Args:hol_type list, Tyop:string} -> hol_type
val mk_var = fn : {Name:string, Ty:hol_type} -> term
val new_binder = fn : {Name:string, Ty:hol_type} -> unit
val new_constant = fn : {Name:string, Ty:hol_type} -> unit
val new_infix = fn : {Name:string, Prec:int, Ty:hol_type} -> unit
val new_recursive_definition = fn
  : {def:term, fixity:fixity, name:string, rec_axiom:thm} -> thm
val new_specification = fn
  : {consts:{const_name:string, fixity:fixity} list, name:string, sat_thm:thm}
    -> thm
val new_type = fn : {Arity:int, Name:string} -> unit
val new_type_definition = fn : {inhab_thm:thm, name:string, pred:term} -> thm
val subst = fn : term subst -> term -> term
val subst_occs = fn : int list list -> term subst -> term -> term
val type_subst = fn : hol_type subst -> hol_type -> hol_type
hol90 root directory now regarded as "/usr/groups/hol/hol90.7/solaris/".

[Major collection... 63% used (5010020/7924420), 980 msec]

[Major collection... 99% used (5012880/5012880), 920 msec]


          HHH                 LL
          HHH                  LL
          HHH                   LL
          HHH                    LL
          HHH          OOOO       LL
          HHHHHHH     OO  OO       LL
          HHHHHHH     OO  OO       LLL
          HHH          OOOO        LLLL
          HHH                     LL  LL
          HHH                    LL    LL
          HHH                   LL      LL
          HHH                  LL        LL90.7

Created on Tue Jan 23 15:33:12 GMT 1996
using: Standard ML of New Jersey, Version 0.93, February 15, 1993



The library "HOL" is loaded.
- 