head	1.3;
access;
symbols
	HOL97:1.3.2.1.0.2
	bpHOL97:1.3.2.1
	hol90_9_alpha:1.3.2.1
	hol90_pre8_for_multiple_compilers:1.3.0.2
	hol90_manual_after_dons_changes:1.2;
locks; strict;
comment	@% @;


1.3
date	96.09.04.19.01.48;	author drs1004;	state dead;
branches
	1.3.2.1;
next	1.2;

1.2
date	96.09.04.18.46.21;	author drs1004;	state Exp;
branches;
next	1.1;

1.1
date	96.02.27.15.12.06;	author drs1004;	state Exp;
branches;
next	;

1.3.2.1
date	96.09.04.19.04.11;	author drs1004;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Moving Manual changes to main devlopment branch (hol0_pre8 etc.)
@
text
@\chapter{Tools for making definitions}

This chapter looks at some of the tools provided with the \HOL\ system
for introducing new types and constants via definitional extension.
The primitive definitional facilities upon which these tools
are based have already been described in Section~\ref{avra_definitional}.

Only one of the tools described here, the primitive recursive
type definition package, is built into the core of \HOL.  The
others are provided into \HOL\ library and the `contrib' directory, and
are mentioned for reference.

\section{The datatype definition package}\label{types-package}\index{extension, of HOL logic@@extension, of \HOL\ logic!by type definition|(}
\index{type definition package, in HOL system@@type definition package, in \HOL\ system|(}


\begin{aside} Powerful new decision procedures are now
available for recursive datatypes.  
Users should consider using the routines in the
\ml{decision} library to define their datatypes.  This will allow
the decision procedures provided in that
library to reason about your new datatypes.  
Examples of using the \ml{decision} library to define
datatypes, and reason about them,
can be found in the library itself.  The relevant
function is \ml{HOLTypeInfo.define\_type\_info}.  The input syntax
used for that function is the same as described here.  
Other information,
including fixities and names for selector and discriminator functions,
must also be supplied. 
\end{aside}

Defining a new type by the primitive type definition
mechanism can be hard work.  But a set of tools
is provided in the system which---for a certain class of commonly-used {\it
concrete recursive types\/}\index{types, in HOL logic@@types, in \HOL\
logic!tools for construction of}\index{concrete recursive types, in HOL
logic@@concrete recursive types, in \HOL\ logic}---automatically carries out all
the formal proofs necessary to define these types and derive abstract
characterizations from their definitions.  This section provides a user-level
overview of these tools.  Details of the formal proofs carried out by these
tools are discussed in~\cite{Melham-banff}.

\index{type definition package, in HOL system@@type definition package, in \HOL\ system!use of, in recursive type definition|(}
\index{recursive types, in HOL logic@@recursive types, in \HOL\ logic!tools for construction of|(}
The main \ML\ function in the \HOL\ type definition package is

\begin{boxed}
\index{define_type@@\ml{hol\_datatype}|pin}
\begin{verbatim}
   val define_type : {
      fixities: fixity list,
      name: string,
      type_spec: term frag list
   } -> thm
\end{verbatim}\end{boxed}

\noindent This function can be used to define any concrete recursive type in
the \HOL\ system.  These are types whose values are generated by a set of {\it
constructors\/} (i.e.\ functions) which yield concrete representations for
these values.  Examples include types which denote finite sets of atomic values
(enumerated types), types which denote sets of structured values (record types)
or finite disjoint unions of structured values (variant records), and types
which denote sets of recursive data structures (recursive types).

The \ml{type\_spec} field \ml{define\_type} is
a user-supplied specification of the concrete
recursive type to be defined.  This type specification is written in 
a notation (explained below) which (vaguely) resembles
a data type declaration in functional programming languages like Standard
\ML~\cite{sml}.  It simply states the names of the new type's
constructors and the logical types of their \mbox{arguments.}  The output is a
theorem which abstractly characterizes the properties of
the desired recursive type---i.e.\ a 
derived "abstract axiomatization' of the type.

The \ml{fixities} field specifies the syntactic fixities of the
constructors for the new type.  The \ml{name} field should specify the
name of the new type.

\subsection{The input}

The type specification given \index{type definition package, in HOL
system@@type definition package, in \HOL\ system!input to|(} to \ml{define\_type}
must be an \ML\ quotation\index{frag lists, in ML@@frag lists, in \ML!as
input to HOL define_type package@@as input to \HOL\ \ml{define\_type}
package} of the form:

\begin{boxed} \begin{alltt}
spec :: {\it ident} {\bf =} clauses

clauses :: clause
         \(|\) clause | clauses

clause  :: constructor
         \(|\) constructor {\bf of} types

types :: {\it type}
       \(|\) {\it type} {\bf \verb%=>%} ctypes

constructor :: {\it ident} 
\end{alltt} \end{boxed}

\noindent This gives the general form
\begin{hol}\begin{alltt}
   {\normalsize\sl op} = \(C\sb{1}\;ty{}\sb{1}\sp{1}\ml{ => }\ldots\ml{ => }ty{}\sb{1}\sp{k\sb{1}} \) 
        |      \(\vdots\)
        | \(C\sb{m}\;ty{}\sb{m}\sp{1}\ml{=>}\ldots\ml{ => }ty{}\sb{m}\sp{k\sb{m}}\)
\end{alltt}\end{hol}

\noindent where each $ty_i^{j}$ is either a type expression already defined
as a type in the current theory (this type expression must not
contain \ty{op}) or is the name \ty{op} itself.  Input of this form
describes an $n$-ary type operator \ty{op},
where $n$ is the number of distinct type variables in the types 
$ty_i^{j}$ on the right hand side of the equation.
If $n = 0$ then \ty{op} is a type constant;
otherwise \ty{op} is an $n$-ary type operator.  The concrete 
type described has $m$
distinct constructors \m{C_1, \dots, C_m} where $m \geq 1$.
Each constructor \m{C_i} takes $k_i$ arguments, where $k_i \geq 0$;
and the types of these arguments are given by the type
expressions $ty_i^j$ for $1 \leq j \leq k_i$.  If one or more of the type
expressions $ty_i^{j}$ is the type \ty{op} itself, then the \mbox{equation}
specifies a {\it recursive\/} type.  In any specification of a recursive type,
at least one constructor must be non-recursive---i.e.\ all its arguments must
have types which already exist in the current theory.

The input parser for \ml{define\_type} treats type expressions exactly as the
\HOL\ quotation parser does, with precedences among the various built-in type
operators in force.\index{type definition package, in HOL system@@type definition package, in \HOL\ system!input to|)}
Note that the input can include type antiquotations (see
Section~\ref{antiquotation}).

\begin{aside} 
The input syntax may cause some confusion, since
the symbol \ml{=>} is used to indicate a curried instance of
a constructor, and not a function type. Thus, the input
\begin{alltt}
   btree = LEAF of 'a
         | NODE of 'a btree => 'a btree
\end{alltt}
is defining a type of binary trees, since the second clause
indicates that \ml{NODE} is a curried function, and not
a paired function as the more normal
\begin{alltt}
   btree = LEAF of 'a
         | NODE of 'a btree * 'a btree
\end{alltt}
would suggest.
\end{aside}

\subsection{The type specified}

The logical type described by an input string of the form
shown above is intended
to denote the set of all values which can be finitely 
generated using the constructors \m{C_1, \dots, C_m}, 
where each constructor is one-to-one and any two
different constructors yield different values.   Every value of this 
type will be denoted by some term of the form:

\[ C_i\;x_i^1\;\ldots\;x_i^{k_i} \]

\noindent where $x_i^j$ is a term of type $ty_i^j$ for $1 \leq j \leq
k_i$. In addition, any two terms:

\[ C_i\;x_i^1\;\ldots\;x_i^{k_i} \qquad {\rm and} \qquad
   C_j\;x_j^1\;\ldots\;x_j^{k_j} \]

\noindent denote equal values exactly when their constructors are the same
(i.e.\ $i=j$) and these constructors are applied to equal arguments 
(i.e.\ $x_i^n = x_j^n\;\,{\rm for}\;\,1\leq n\leq k_i$).  

\subsection{The output}\label{define-type-output}
\index{type definition package, in HOL system@@type definition package, in \HOL\ system!output of|(}

\noindent For any type specification 
in the form of an equation of the kind discussed above, executing:

{\def\op{{\normalsize\sl op}}
\begin{hol}
\index{define\_type@@\ml{define\_type}}
\begin{alltt}
   define\_type `{\op} = \(C\sb{1}\;ty{}\sb{1}\sp{1}\ml{ => }\ldots\ml{ => }ty{}\sb{1}\sp{k\sb{1}} \)
                       | \(\vdots\)
                       | \(C\sb{m}\;ty{}\sb{m}\sp{1}\ml{ => }\ldots\ml{ =>}ty{}\sb{m}\sp{k\sb{m}}\)`;
\end{alltt}\end{hol}}

\noindent will make a formal definition for a
type (or  type operator) \ty{op}
in the current theory segment, make appropriate definitions for
constants  \m{C_1, C_2,\dots, C_m}
and automatically prove a theorem which
provides an abstract
characterization\index{characterizing theorem!for defined types}\index{automated derivation!of characterizing theorems for recursive types}
of the newly-defined type \ty{op}.
This theorem, which is
stored in the current theory segment under the name \ml{$op$\_Axiom} and also returned by
\ml{define\_type}, has the form shown below:

{\def\op{{\normalsize\sl op}}
\begin{hol}\begin{alltt}
   |- !f\(\sb{1}\:\cdots\:\)f\(\sb{m}\). ?!fn:{\op}->'b.
         !x\(\sb{1}\sp{1}\;\,\cdots\,\;\)x\(\sb{1}\sp{k\sb{1}}\). fn(\m{C}\(\sb{1}\,\) x\(\sb{1}\sp{1}\;\,\ldots\,\;\)x\(\sb{1}\sp{k\sb{1}}\)) = f\(\sb{1}\) (fn x\(\sb{1}\sp{1}\))\(\;\ldots\;\)(fn x\(\sb{1}\sp{k\sb{1}}\)) x\(\sb{1}\sp{1}\;\ldots\;\)x\(\sb{1}\sp{k\sb{1}}\)
                                      \(\vdots\)
         !x\(\sb{m}\sp{1}\;\cdots\;\)x\(\sb{1}\sp{k\sb{m}}\!\). fn(\m{C}\(\sb{m}\) x\(\sb{m}\sp{1}\;\ldots\;\)x\(\sb{m}\sp{k\sb{m}}\)) = f\(\sb{m}\) (fn x\(\sb{m}\sp{1}\))\(\;\ldots\;\)(fn x\(\sb{m}\sp{k\sb{m}}\)) x\(\sb{m}\sp{1}\;\ldots\;\)x\(\sb{m}\sp{k\sb{m}}\)
\end{alltt}\end{hol}}     


\noindent where the right hand sides of the equations include recursive
applications "$\ml{fn}\;\ml{x}_i^j$' only for variables  $\ml{x}_i^j$ of type
\ty{op}.  (See the examples given below.) A theorem of this form asserts the
unique existence of primitive recursive functions defined by cases on the
constructors \m{C_1, C_2,\dots,C_m}.  This is a slight
extension of the {\it initiality\/}\index{initiality} property by which
structures of this kind are characterized in the "initial algebra' approach to
specifying abstract data types~\cite{goguen}.  This property provides an
abstract characterization of the type \ty{op} which is both succinct and
complete, in the sense that it completely determines the structure of the
values of \ty{op} up to isomorphism.

The call to \ml{define\_type} shown above fails if:

\begin{myenumerate}
 
\item not in draft mode\index{draft mode, in HOL system@@draft mode, in \HOL\ system};

\item \ty{op} is already the name of a type constant or type operator in the
current theory;

\item any one of $C_1,\dots,C_{m}$ is already the name
of a constant in the current theory.

\item either \ty{op} or any one $C_{1},\dots,C_{m}$ is not a
legal identifier (see Section~\ref{HOL-lex}).

\item $\ml{ABS\_}\ty{op}$\index{ABS_@@\ml{ABS\_}$\ldots$}
 or $\ml{REP\_}\ty{op}$\index{REP_@@\ml{REP\_}$\ldots$}
 are already constants in the
current theory;

\item there is already an axiom, definition, constant specification or type
definition stored under either the name
$\ty{op}\ml{\_Axiom}$ or the name
$\ty{op}\ml{\_TY\_DEF}$\index{TY_DEF@@$\ldots$\ml{\_TY\_DEF}} or the name
$\ty{op}\ml{\_ISO\_DEF}$ in the current
theory segment.

\item there is already a theorem stored under the name \ml{"\m{name}"} in the
current theory segment.

\item the input type specification does not conform to the syntax described
above.

\end{myenumerate}
\index{recursive types, in HOL logic@@recursive types, in \HOL\ logic!tools for construction of|)}\index{type definition extension, in HOL logic@@type definition extension, in \HOL\ logic|)}
\index{type definition package, in HOL system@@type definition package, in \HOL\ system!output of|)}
\index{type definition package, in HOL system@@type definition package, in \HOL\ system!use of, in recursive type definition|)}

\subsubsection{Examples}\label{define-type-example}

\index{primitive recursion theorem!a degenerate case|(}
The session that follows illustrates the use of \ml{define\_type} in defining
a variety of simple concrete types.  It is assumed that the session begins
with the user in draft mode.

The first definition is simple, the definition of a type \ml{three} with
exactly three distinct values: \ml{ONE}, \ml{TWO}, and \ml{THREE}.

\setcounter{sessioncount}{1}\label{types-session}
\begin{session}\begin{verbatim}
- val three_Axiom = define_type {
    name = "three",
    type_spec = `three = ONE | TWO | THREE`,
    fixities = [Prefix,Prefix,Prefix]
  }
val three_Axiom = 
|- !e0 e1 e2. ?! fn. (fn ONE = e0) /\ (fn TWO = e1) /\ (fn THREE = e2)
\end{verbatim}\end{session}

\noindent The theorem returned by \ml{define\_type} provides a complete 
and abstract characterization of
a defined logical type \ml{three} which denotes a set of
exactly three elements.  This characterization takes the form of a
degenerate `primitive recursion'
 theorem for the concrete type \ml{three}. 
Since \ml{three} is an enumerated type with no recursive constructors, 
the theorem returned by \ml{define\_type} simply
states that any function defined by cases on the three constants  \ml{ONE},
\ml{TWO}, and \ml{THREE} exists and is uniquely defined. 

It follows immediately from this theorem that the type constant \ml{three}
denotes a set containing exactly three values: the fact that the function
\ml{fn} always exists implies that the constants \ml{ONE}, \ml{TWO}, and
\ml{THREE} denote distinct values of type \ml{three}, and the fact that \ml{fn}
is uniquely determined by its values for \ml{ONE}, \ml{TWO}, and \ml{THREE}
implies that these constants denote the only values of type \ml{three}.
\index{primitive recursion theorem!a degenerate case|)}

The next call to \ml{define\_type} defines a `record type' \ml{rec}
\index{types, in HOL logic@@types in \HOL\ logic!record types}\index{record
types}, values of
which are records with three boolean fields (essentially 3-tuples):

\begin{session}\begin{verbatim}
- val rec_Axiom = define_type {
    name = "three",
    type_spec = `rec = REC of bool => bool => bool`,
    fixities = [Prefix]
  };
val rec_Axiom = |- !f. ?! fn. !b0 b1 b2. fn(REC b0 b1 b2) = f b0 b1 b2 : thm
\end{verbatim}\end{session}\label{rec-def}

\noindent Here, the resulting theorem states that a function \ml{fn} on
record values of type \ml{rec} can be
uniquely defined in terms of a function \ml{f} of the three components of
the record.

A more interesting {\it recursive\/}
  example is the type of natural 
numbers\index{number theory, in HOL logic@@number theory, in \HOL\ logic!type definition package version of}
\index{type definition package, in HOL system@@type definition package, in \HOL\ system!use of, to build number theory}, which can be defined using \ml{define\_type} as follows:

\begin{session}\begin{verbatim}
- val nat_Axiom = define_type {
    name = "three",
    type_spec = `nat = Z | Suc of nat`,
    fixities = [Prefix,Prefix]
  };
val nat_Axiom = |- !e f. ?! fn. (fn Z = e) /\ (!n. fn(Suc n) = f(fn n)n) : thm
\end{verbatim}\end{session}

\noindent Here, the input string describes a type \ml{nat} with two
constructors: \ml{Z}, which stands for zero; and \ml{Suc}, which is the
successor function on natural numbers.  (The names 
\ml{Z}, and \ml{Suc} are used here because \ml{0} and \ml{SUC} are already
constants in the built-in \HOL\ theory \ml{num}.)
The output theorem is just the primitive recursion 
theorem\footnote{See Section~\ref{prim_rec} for a discussion of
the primitive recursion theorem.}
for the natural numbers; it states that any primitive recursive definition on
the natural numbers (\ie\ on values of type \ml{nat})
uniquely defines a total function.

A recursive type of labelled binary trees\index{binary tree theory, in HOL logic@@binary tree theory, in \HOL\ logic|(}, where labels of type \ml{'a}
appear only on leaf nodes, can likewise be defined using \ml{define\_type}.
The input states that a binary tree is either a leaf node (\ml{LEAF})
labelled by a value of type \ml{'a} or an internal node \ml{NODE} with
two binary trees as subtrees:

\begin{session}\begin{verbatim}
- val btree_Axiom = define_type {
    name = "three",
    type_spec = `btree = LEAF 'a | NODE of 'a btree => 'a btree`,
    fixities = [Prefix,Prefix]
  };
btree_Axiom = 
|- !f0 f1.
    ?! fn.
     (!x. fn(LEAF x) = f0 x) /\
     (!b1 b2. fn(NODE b1 b2) = f1(fn b1)(fn b2)b1 b2)
\end{verbatim}\end{session}\label{btree-def}

\noindent The result returned by the call to {\small \verb!define_type!} is,
in this case, an abstract
characterization for a defined type {\small\verb!'a btree!},
in the form of a `primitive recursion theorem' for the required
type of labelled binary trees.\index{binary tree theory, in HOL logic@@binary tree theory, in \HOL\ logic|)}

Any simple  concrete  recursive  type  can  be  defined  automatically  from  a
user-supplied equation using \ml{define\_type} in exactly the same way.

\subsection{Defining recursive functions}\label{prim-rec-defs}
\label{new-rec-def}

\index{type definition package, in HOL system@@type definition package, in \HOL\ system!use of, in recursive function definition|(}
\index{recursive definitions, in HOL logic@@recursive definitions, in \HOL\ logic!automated, for recursive types|(}
\index{primitive recursion theorem!for binary trees|(}
An important property of the characterizing theorems for concrete types
shown in the examples given above is that they
provide a formal
means for defining recursive functions on those types.
When a concrete 
recursive type  \ty{op} is
 characterized by a theorem of the kind returned by
\ml{define\_type}\index{types, in HOL logic@@types, in \HOL\ logic!tools for construction of} (see Section~\ref{define-type-output}) this theorem
can be used to 
prove the existence of any 
{\it primitive recursive\/} function on \ty{op} and to
define constants which denote such functions.  

%This is illustrated
%for a particular
%example by the method of defining primitive recursive functions on
%the natural numbers  discussed in Section~\ref{num-prim-rec}.  In that section,
%an \ML\ function \ml{new\_prim\_rec\_definition}\index{new_prim_rec_definition@@\ml{new\_prim\_rec\_definition}}
% was described which automates
%the logical inferences necessary to derive particular primitive recursive
%definitions on the built-in defined type \ml{num} of natural numbers.  The
%basis of this function is the primitive recursion theorem
%
%\begin{hol}
%\index{num_Axiom@@\ml{num\_Axiom}}
%\begin{verbatim}
%   num_Axiom   |- !x f. ?!fn. (fn 0 = x) /\ (!n. fn(SUC n) = f (fn n) n)
%\end{verbatim}\end{hol}
%
%\noindent which is pre-proved and stored in the built-in theory \ml{prim\_rec}\index{prim_rec@@\ml{prim\_rec}}
%(see Section~\ref{prim_rec}).  The \ML\ function
%\ml{new\_prim\_rec\_definition} uses \ml{num\_Axiom} to automate the
%justification of any user-supplied primitive recursive definition on the
%natural numbers.

The type definition package\index{primitive recursion theorem!automated use of, in HOL system@@automated use of, in \HOL\ system|(} provides a similar function for defining 
primitive recursive functions on
arbitrary concrete recursive
types.
%\footnote{In fact, {\tt new\_prim\_rec\_definition} is defined in ML
%using the more general tools provided by the type definition package.}
The \ML\ function

\begin{boxed}\index{new_recursive_definition@@\ml{new\_recursive\_definition}|pin}
\begin{verbatim}
   val new_recursive_definition : {
         name : string,
         rec_axiom : thm,
         def : term,
         fixity: fixity
   }; 
\end{verbatim}\end{boxed}

\noindent automates the
inferences necessary to justify any given primitive recursive definition on a
concrete recursive type of the kind definable by \ml{define\_type}.
 It takes four arguments.
\ml{rec\_axiom} is the primitive recursion theorem for 
the concrete type in question
(\ie\ a theorem obtained from {\small\verb!define_type!} or a theorem
proved by some other mechanism which has the right form - 
e.g. \ml{num\_Axiom}).\index{define_type@@\ml{define\_type}}  \ml{name}
is a name under which the resulting definition will be saved in the
current theory segment.
The last argument, \ml{def} is a term giving the desired primitive recursive
definition.  The value returned
by  {\small\verb!new_recursive_definition!} is a theorem
which states the primitive recursive definition requested by the
user.  This theorem is derived by formal proof from an instance of the general
primitive recursion theorem\index{automated derivation!of recursive definitions}
 given as the second argument.

If the \ML\ variable \ty{op}\ml{\_Axiom} is bound to a theorem of the form
returned by \ml{define\_type},
then evaluating:

{\def\op{{\normalsize\sl op}}
\begin{hol}\begin{alltt}
   new_recursive_definition \{
     name="\m{name}",
     rec_axiom=\op\_Axiom,
     def=``{\normalsize\it primitive recursive definition on \op}``,
     fixity={\it fixity}
   \};
\end{alltt}\end{hol}}

\noindent  automatically proves the existence of the primitive recursive
function supplied as the fourth argument, 
and then declares a new constant in the current theory
with this definition as its
specification. This constant specification is returned as a theorem
and is saved in the current theory segment under the name
$name$.
Failure occurs if:

\begin{myenumerate}
\item \HOL\ cannot prove there is a function 
satisfying the defining equations supplied by the user 
(\ie\ the term supplied to \ml{new\_recursive\_definition} 
 is not a well-formed primitive recursive definition on values 
of type \ty{op});
\item any other condition for making a constant specification is violated
(see the failure conditions for \ml{new\_specification} in 
Section~\ref{conspec}).
\end{myenumerate}

Curried\index{currying, in ML@@currying, in \ML!in recursive definitions}
functions defined using \ml{new\_recursive\_definition} can be
recursive on any one of their arguments.  Furthermore, defining equations need
not be given for all the constructors of the concrete type in question.  See
the examples given in the next section, or the examples of functions 
defined on \ml{num} given in Section~\ref{num-prim-rec} for more details.

The \ML\ function 

\begin{boxed}
\index{prove_rec_fn_exists@@\ml{prove\_rec\_fn\_exists}|pin}
\begin{verbatim}
   prove_rec_fn_exists : thm -> term -> thm
\end{verbatim}\end{boxed}

\noindent is a version of \ml{new\_recursive\_definition} which proves only
that the required function exists; it does not make a constant specification.
The first argument is a theorem of the form returned by \ml{define\_type},
and the second is a user-supplied primitive recursive function definition.
The theorem which is returned asserts the existence of the recursively-defined
function in question (if it is primitive recursive over the type characterized
by the theorem given as the first argument). 
\index{recursive definitions, in HOL logic@@recursive definitions, in \HOL\ logic!automated, for recursive types|)}
\index{type definition package, in HOL system@@type definition package, in \HOL\ system!use of, in recursive function definition|)}
\index{primitive recursion theorem!automated use of, in HOL system@@automated use of, in \HOL\ system|)}

\subsubsection{More examples}

Continuing the example session started above in Section~\ref{define-type-example},
the following interactions with the system show how the \ML\ function
\ml{new\_recursive\_definition} can be used to define functions on concrete types,
which have themselves been defined using \ml{define\_type}.

Given the characterizing theorem
\ml{btree\_Axiom} for the type of labelled binary trees
defined in Section~\ref{types-session}, a recursive function \ml{Leaves}, which
computes the number of leaf nodes in a binary tree, 
can be defined recursively in \HOL\ as shown below:

\begin{session}\begin{verbatim}
- val Leaves = 
=     new_recursive_definition {
=         rec_axiom = btree_Axiom,
=         name = "Leaves",
=         def = ``(Leaves (LEAF (x:'a)) = 1) /\
=                   (Leaves (NODE t1 t2) = (Leaves t1) + (Leaves t2))``,
=         fixity = Prefix
=     };
Leaves = 
|- (!x. Leaves(LEAF x) = 1) /\
   (!t1 t2. Leaves(NODE t1 t2) = (Leaves t1) + (Leaves t2))
\end{verbatim}\end{session}

\noindent The result of the call to {\small\verb!new_recursive_definition!} is
a theorem which states that the constant {\small\verb!Leaves!} satisfies the
primitive-recursive defining equations supplied by the user.  This theorem is
derived automatically from an instance of the general primitive recursion
theorem for binary trees ({\small\verb!btree_Axiom!}) and an appropriate
constant specification for the constant {\small\verb!Leaves!}. 

The function defined using \ml{new\_recursive\_definition}\index{type
definition package, in HOL system@@type definition package, in \HOL\
system!use of, in case definition} need not, in fact, be recursive.
Here is the definition of a predicate \ml{IsLeaf}, which is true of
binary trees which are leaves, but is false of the internal nodes in a
binary tree:

\begin{session}\begin{verbatim}
- val IsLeaf = 
=     new_recursive_definition {
=         rec_axiom = btree_Axiom,
=         name = "IsLeaf",
=         def = ``(IsLeaf (NODE t1 t2) = F) /\ 
=                   (IsLeaf (LEAF (x:'a)) = T)``,
=         fixity = Prefix
=     };
IsLeaf = |- (!t1 t2. IsLeaf(NODE t1 t2) = F) /\ (!x. IsLeaf(LEAF x) = T)
\end{verbatim}\end{session}

\noindent Note that two equations defining a (recursive or non-recursive)
function on binary trees by cases can be given in either order.  Here, the
\ml{NODE} case is given first, and the \ml{LEAF} case second.  The reverse
order was used in the above definition of \ml{Leaves}.

The \ML\ function  {\small\verb!new_recursive_definition!} also allows the user
to partially specify\index{type definition package, in HOL system@@type definition package, in \HOL\ system!use of, in partial definition} the value of a function defined on a concrete type, by
allowing defining equations for some of the constructors to be omitted.  Here,
for example, is the definition of a function \ml{Label} which extracts the
label from a leaf node.  The value of \ml{Label} applied to an internal node
is left unspecified:

\begin{session}\begin{verbatim}
- val Label = 
=     new_recursive_definition {
=        rec_Axiom = btree_Axiom,
=        name = "Label" 
=        def = ``Label (LEAF (x:'a)) = x``,
=        fixity=Prefix
=     };
Label = |- !x. Label(LEAF x) = x
\end{verbatim}\end{session}

\index{type definition package, in HOL system@@type definition package, in \HOL\ system!use of, in curried infix definition|(} 
Curried functions can also be defined, and the recursion can be on any
argument.  The next definition defines an infix (curried)
function \ml{<<} which expresses the idea that one tree is a proper
subtree of another.

\begin{session}\begin{verbatim}
- val Subtree = 
=     new_recursive_definition {
=        rec_Axiom = btree_Axiom,
=        name = "Subtree",
=        def = ``(t << (LEAF x)     = F) /\
=                  (t << (NODE t1 t2) = ((t=t1) \/ (t=t2) \/ 
=                                        (t << t1) \/ (t << t2)))``,
=        fixity = Infix 300
=   };
Subtree = 
|- (!t x. t << (LEAF x) = F) /\
   (!t t1 t2.
     t << (NODE t1 t2) = (t = t1) \/ (t = t2) \/ t << t1 \/ t << t2)
\end{verbatim}\end{session}

\noindent Note that the function \ml{<<} 
is recursive on its second argument\index{type definition package, in HOL system@@type definition package, in \HOL\ system!use of, in curried infix definition|)}.

Finally, the function {\small\verb!new_recursive_definition!} can also be used
to define functions by cases on enumerated types.  For example, a predicate
\ml{One}, which is true of only the value \ml{ONE} of the three-valued type
\ml{three} defined above in Section~\ref{types-session}, can be defined as
follows:

\begin{session}\begin{verbatim}
- val One = new_recursive_definition {
=             rec_axiom = three_Axiom,
=             name = "One", 
=             def = ``(One ONE = T) /\ 
=                       (One TWO = F) /\ 
=                       (One THREE = F)``,
=             fixity = Prefix
=           };
One = |- (One ONE = T) /\ (One TWO = F) /\ (One THREE = F)
\end{verbatim}\end{session}

The existence only of
any function definable using \ml{new\_recursive\_definition} can be proved
using \ml{prove\_rec\_fn\_exists}.  For example:

\begin{session}\begin{verbatim}
- close_theory();
() : unit

- val exists = prove_rec_fn_exists three_Axiom 
=              ``(f ONE = T) /\ (f TWO = F) /\ (f THREE = F)``;
exists = |- ?f. (f ONE = T) /\ (f TWO = F) /\ (f THREE = F)
\end{verbatim}\end{session}

\noindent The resulting theorem simply states the existence of the 
required function.  Here, a constant is not defined, and the user need
not be in draft mode.
\index{primitive recursion theorem!for binary trees|)}

\subsection{Structural induction}

\index{type definition package, in HOL system@@type definition package, in \HOL\ system!use of, to build induction tools|(} 
\index{induction rule!structural, derivation of|(}
For any concrete recursive type definable 
 using the \HOL\ type definition package there is a structural induction
theorem which states the validity of proof by induction  
on the structure of the type's values.  The \ML\ function

\begin{boxed}
\index{prove_induction_thm@@\ml{prove\_induction\_thm}|pin}
\begin{verbatim}
   prove_induction_thm : thm -> thm 
\end{verbatim}\end{boxed}

\noindent can be used to derive a structural induction\index{automated derivation!of structural induction theorems}\index{induction rule!for concrete recursive types}
theorem for any concrete
recursive type defined using \ml{define\_type}.  If the \ML\ 
variable \ty{op}\ml{\_Axiom} is bound to a theorem of the form
returned by \ml{define\_type}, 
then executing 

\[ \ml{prove\_induction\_thm}\;\ty{op}\ml{\_Axiom} \]

\noindent will prove  and  return a  structural induction  theorem for  
the concrete type
\ty{op}.  The "induction' theorem is degenerate in the case of non-recursive
types (see the examples given below). Failure occurs, or an unpredictable 
output theorem is returned, if the input theorem does not have the form
of a theorem  returned by \ml{define\_type}.

\subsubsection{Examples}

A structural induction theorem on the type of binary trees defined in the session
beginning on Section~\ref{types-session} can be proved by:

\begin{session}\begin{verbatim}
- val btree_Induct = prove_induction_thm btree_Axiom;
btree_Induct =
|- !P.
    (!x. P(LEAF x)) /\ (!b1 b2. P b1 /\ P b2 ==> P(NODE b1 b2)) ==>
    (!b. P b)
\end{verbatim}\end{session}


\noindent The output theorem states that a predicate \ml{P} is true of all
binary trees if it is true of all labelled leaf nodes, and whenever it is true
of two binary trees \ml{b1} and \ml{b2} it is also true of the binary tree
\ml{NODE b1 b2}, in which \ml{b1} and \ml{b2} occur as immediate left and right
subtrees.

For non-recursive types, the induction theorem returned by
\ml{prove\_induction\_thm} is degenerate: there are no "step' cases in the
induction.  For the two types \ml{three} and \ml{rec} defined in the preceding
interactions of this session, the induction theorems are:

\begin{session}\begin{verbatim}
- val three_Induct = prove_induction_thm three_Axiom;
three_Induct = |- !P. P ONE /\ P TWO /\ P THREE ==> (!t. P t)

- val rec_Induct = prove_induction_thm rec_Axiom;
rec_Induct = |- !P. (!b0 b1 b2. P(REC b0 b1 b2)) ==> (!r. P r)
\end{verbatim}\end{session}

\noindent Here, induction simply reduces to the consideration of
cases,\index{case analysis, in HOL logic@@case analysis, in \HOL\ logic!as instance  of induction} one for each of the constructors for the concrete type involved.
\index{induction rule!structural, derivation of|)}

\subsection{Structural induction tactics}
\label{avrasi}

\index{theorem continuations!use of, in derivation of induction tactics|(}
This section has been included here for reference
because it relates chiefly to the
type definition package, but it involves concepts not defined until
later, in Chapter~\ref{tactics-and-tacticals}. Tactics, goals
and subgoals are
defined in Section~\ref{tactics}; and theorem continuations, in
Section~\ref{asm-manip}. \ml{MAP\_EVERY} is defined in Section~\ref{avra_manip1}.
\ml{ASSUME\_TAC} is defined in Section~\ref{avra_builtin}.
\ml{MP\_TAC}  and \ml{INDUCT\_TAC} can be found in \REFERENCE.

The \ML\ function

\begin{boxed}
\index{INDUCT_THEN@@\ml{INDUCT\_THEN}|pin}
\index{induction tactics!derivation of|(}
\begin{verbatim}
   INDUCT_THEN : thm -> (thm -> tactic) -> tactic
\end{verbatim}\end{boxed}

\noindent can be used to generate
a structural induction tactic\index{automated derivation!of structural induction tactics}
for any concrete types definable using \ml{define\_type}.\index{define_type@@\ml{define\_type}}  The first argument
is an induction theorem of the form returned by the function
\ml{prove\_induction\_thm}\index{prove_induction_thm@@\ml{prove\_induction\_thm}} discussed in the previous section.  The second
argument is a theorem continuation\index{characterizing theorem!use of, in deriving induction} (see
Chapter~\ref{tactics-and-tacticals}) that determines what is to be done with
the induction hypotheses when the resulting tactic is applied to a goal.

If $th$ is an induction theorem for a concrete type \ty{op} with
$m$ constructors  \mbox{$C_1$, \dots, $C_m$}
(\ie\ a theorem of the kind returned by
\ml{prove\_induction\_thm}) and $F$ is a theorem continuation, then the
tactic $\ml{INDUCT\_THEN}\;th\;F$ will reduce a goal 
{\small\verb%(%}$\Gamma${\small\verb%,"!%}$x{:}
\ty{op}${\small\verb%.%}$t[x]${\small\verb%")%} to the collection of $m$
induction subgoals generated by:

\[ \begin{array}[t]{@@{}l@@{}l}
 \ml{MAP\_EVERY } F \ml{ [}th_1^1\ml{;}\;\ldots\ml{;}\;th_1^{k_1}\ml{]} & 
\ml{ (}\Gamma\ml{, ``}t[ C_1\;x_1^1\;\ldots\;x_1^{k_1}]\ml{``)},\\
\qquad\qquad \vdots & \mbox{} \\
 \ml{MAP\_EVERY } F \ml{ [}th_m^1\ml{;}\;\ldots\ml{;}\;th_m^{k_m}\ml{]} & 
\ml{ (}\Gamma\ml{, ``}t[ C_m\;x_m^1\;\ldots\;x_m^{k_m}]\ml{``)}
 \end{array}
\]\index{MAP_EVERY@@\ml{MAP\_EVERY}}

\noindent where $th_i^j$ is a theorem of the form $\ml{|- }t[x_i^j]$ asserting
the truth of $t[x_i^j]$ for the $j$th recursive argument (for non-recursive 
arguments, there will be no $th_i^j$ in the list) of the $i$th constructor
$C_i$ (for $1 \leq i \leq m$).

The most common use of \ml{INDUCT\_THEN} is in conjunction with the theorem
continuation \ml{ASSUME\_TAC}.  For example, the built-in
induction tactic \ml{INDUCT\_TAC} for mathematical induction on 
the natural numbers is defined in \ML\ by:

\begin{hol}
\index{INDUCT_TAC@@\ml{INDUCT\_TAC}}
\begin{verbatim}
   val INDUCT_TAC = INDUCT_THEN INDUCTION ASSUME_TAC 
\end{verbatim}\end{hol}

\noindent This built-in tactic reduces a goal
 {\small\verb%(%}$\Gamma${\small\verb%,``!%}$n${\small\verb%.%}$t[n]${\small\verb%``)%} to a basis subgoal
{\small\verb%(%}$\Gamma${\small\verb%,``%}$t[${\small\verb%0%}$]${\small\verb%``)%} 
and a step subgoal 
{\small\verb%(%}$\Gamma\cup\{${\small\verb%``%}$t[n]${\small\verb%``%}$\}${\small\verb%,``%}$t[${\small\verb%SUC %}$n]${\small\verb%``)%}.
The extra assumption  {\small\verb%``%}$t[n]${\small\verb%``%} (\ie\ the
induction hypothesis)
is added to the assumptions $\Gamma$ by \ml{ASSUME\_TAC}.  

By contrast, the
induction tactic \ml{INDUCT\_MP\_TAC} (which is not built-in) defined
by:

\begin{hol}\begin{verbatim}
   val INDUCT_MP_TAC = INDUCT_THEN INDUCTION MP_TAC
\end{verbatim}\end{hol}

\noindent reduces a goal
 {\small\verb%(%}$\Gamma${\small\verb%,``!%}$n${\small\verb%.%}$t[n]${\small\verb%``)%} to a basis subgoal
{\small\verb%(%}$\Gamma${\small\verb%,``%}$t[${\small\verb%0%}$]${\small\verb%``)%} 
and an induction step subgoal 
{\small\verb%(%}$\Gamma${\small\verb%, ``%}$t[n]${\small\verb% ==> %}$t[${\small\verb%SUC %}$n]${\small\verb%``)%}.
Here, the theorem continuation \ml{MP\_TAC} makes the induction hypothesis
an antecedent of the step subgoal, rather than an assumption.

As this example illustrates, the theorem continuation $F$ in 
an induction tactic

\[ \ml{INDUCT\_THEN }th\;\;F \]

\noindent generated using an induction theorem $th$ can be thought of as a
function which determines what is to be done with the induction hypotheses
corresponding to the recursive arguments of constructors in the step
cases of a proof by structural induction.  When $F$ is \ml{ASSUME\_TAC}, 
the induction hypotheses become assumptions in the subgoals generated; and when
$F$ is \ml{MP\_TAC}, the induction hypotheses become the antecedents of
implicative subgoals.  Other theorem continuations (for which, see
Chapter~\ref{tactics-and-tacticals} and \REFERENCE) can also be used\index{theorem continuations!use of, in derivation of induction tactics|)}.
\index{type definition package, in HOL system@@type definition package, in \HOL\ system!use of, to build induction tools|)}\index{induction tactics!derivation of|)} 

\subsection{Other tools}


The function

\begin{boxed}
\index{prove_constructors_one_one@@\ml{prove\_constructors\_one\_one}|pin}
\begin{verbatim}
   prove_constructors_one_one : thm -> thm
\end{verbatim}\end{boxed}

\noindent proves that the constructors\index{constructors, of concrete types in HOL logic@@constructors, of concrete types in \HOL\ logic!proving one-to-one}
 of a concrete type which take arguments
are one-to-one\index{automated derivation!of one-to-one theorems}.  The argument to \ml{prove\_constructors\_one\_one} is a
theorem of the form returned by \ml{define\_type}.

The function 

\begin{boxed}
\index{prove_constructors_distinct@@\ml{prove\_constructors\_distinct}|pin}
\begin{verbatim}
   prove_constructors_distinct : thm -> thm
\end{verbatim}\end{boxed}

\noindent proves that the constructors\index{constructors, of concrete types in HOL logic@@constructors, of concrete types in \HOL\ logic!proving distinct}
 of a concrete type yield distinct\index{automated derivation!of
distinctness theorems} values.  The argument to
\ml{prove\_constructors\_distinct} is again 
a theorem of the form returned by \ml{define\_type}.

The function

\begin{boxed}
\index{prove_cases_thm@@\ml{prove\_cases\_thm}|pin}
\begin{verbatim}
   prove_cases_thm : thm -> thm
\end{verbatim}\end{boxed}

\noindent proves a cases\index{automated derivation!of case analysis theorems}
 theorem\index{case analysis, in HOL logic@@case analysis, in \HOL\ logic!theorems for} for any concrete type.  Such a theorem states that every
value can be constructed using one of the type's constructors.  This property
follows more easily (and therefore is faster to prove) from induction than from
primitive recursion, so the function \ml{prove\_cases\_thm} takes as an
argument an induction theorem of the kind returned by
\ml{prove\_induction\_thm}.\index{prove_induction_thm@@\ml{prove\_induction\_thm}}

These auxiliary tools work for any concrete type definable using
\ml{define\_type}.

\subsubsection{Examples}

The following interactions with the system show the proof that the constructor
\ml{LEAF} for the type \ml{'a btree}  is one-one,
and also that the constructor \ml{REC} for the type \ml{rec} is one-to-one.

\begin{session}\begin{verbatim}
- val LEAF_one_one = prove_constructors_one_one btree_Axiom;
LEAF_one_one = 
|- (!x x'. (LEAF x = LEAF x') = (x = x')) /\
   (!b1 b2 b1' b2'.
     (NODE b1 b2 = NODE b1' b2') = (b1 = b1') /\ (b2 = b2'))

- val REC_one_one = prove_constructors_one_one rec_Axiom;
REC_one_one = 
|- !b0 b1 b2 b0' b1' b2'.
    (REC b0 b1 b2 = REC b0' b1' b2') =
    (b0 = b0') /\ (b1 = b1') /\ (b2 = b2')
\end{verbatim}\end{session}

The function \ml{prove\_constructors\_one\_one} fails when the concrete 
type involved has no constructors that take arguments.  For example:

\begin{session}\begin{verbatim}
- val th = prove_constructors_one_one three_Axiom;
evaluation failed     prove_constructors_one_one: invalid input theorem
\end{verbatim}\end{session}

The function \ml{prove\_constructors\_distinct} returns the theorem stating
that the constructors of a concrete type yield pair-wise distinct values.  For
example:

\begin{session}\begin{verbatim}
- val NOT_LEAF_NODE = prove_constructors_distinct btree_Axiom;
NOT_LEAF_NODE = |- !x b1 b2. ~(LEAF x = NODE b1 b2)

- val three_distinct = prove_constructors_distinct three_Axiom;
three_distinct = |- ~(ONE = TWO) /\ ~(ONE = THREE) /\ ~(TWO = THREE)
\end{verbatim}\end{session}

Cases theorems\index{case analysis, in HOL logic@@case analysis, in \HOL\ logic!as instance  of induction} are proved from structural induction theorems. For the binary
tree example considered in the present session, here is the cases theorem:

\begin{session}\begin{verbatim}
- val btree_cases = prove_cases_thm btree_Induct;
btree_cases = |- !b. (?x. b = LEAF x) \/ (?b1 b2. b = NODE b1 b2)
\end{verbatim}\end{session}

\noindent Note that the structural induction theorem for binary trees, 
\ml{btree\_Induct}, is used.
\index{extension, of HOL logic@@extension, of \HOL\ logic!by type definition|)}
\index{type definition package, in HOL system@@type definition package, in \HOL\ system|)}


\section{The recursive function definition package}

See the \ml{tfl}\ library for the description of this new
package for defining recursive functions and proving their
termination.

\section{Other type definition packages}

See the \ml{mutrec} and \ml{nested-red} libraries for descriptions
of tools to define more sophisticated classes of recursive datatypes.

\section{The inductive relations definition packages}

See the \ml{ind\_def} library and \ml{ind\_def\_new} libraries for
tools to define inductive relations.  The first package is better
documented, and new users shoul try this first.  The second is
not well documented but handles a larger range of inductive
relations, including the coinductive and mutually recursive cases.
@


1.3.2.1
log
@Moving changes toManual Description to main development branch
@
text
@@


1.2
log
@lots of development by don
@
text
@@


1.1
log
@much improved (??), by DRS
@
text
@d16 17
d49 1
a49 1
\index{hol_datatype@@\ml{hol\_datatype}|pin}
d51 5
a55 1
   val hol\_datatype : term frag list -> thm
a56 6
%\HOLNINETYEIGHT The version of \ml{define\_type} defined here is
%\ml{Define\_type.define\_type}, not the version found at the top level.
%The version at the top level needs fixity information, and is
%included for compatibility reasons.  If using the version described
%here, fixities can be specified
%using the functions described in Section~\ref{fixities}.
d66 2
a67 3
The input to \ml{hol\_datatype} is
a user-supplied\footnote{ In this context, {\it informal\/} means not
in the language of higher order logic.} specification of the concrete
d77 4
d84 1
a84 1
system@@type definition package, in \HOL\ system!input to|(} to \ml{hol\_datatype}
d86 1
a86 1
input to HOL hol_datatype package@@as input to \HOL\ \ml{hol\_datatype}
d90 1
a90 1
TYPE_SPEC :: {\it ident} {\bf =} CLAUSES 
d92 2
a93 2
CLAUSES :: CLAUSE
         | CLAUSE | CLAUSES
d95 2
a96 4
CLAUSE  :: ""  (* definition of the empty string in the string library *)
         | CONSTRUCTOR
         | CONSTRUCTOR {\bf of} TYPE 
         | CONSTRUCTOR {\bf of} TYPE {\bf \verb%=>%} CURRIED_TYPE
d98 2
a99 2
CURRIED_TYPE :: TYPE 
              | TYPE {\bf \verb%=>%} CURRIED_TYPE
d101 1
a101 1
CONSTRUCTOR :: {\it ident} 
d104 1
a104 1
This gives the general form
d106 1
a106 1
   `{\normalsize\sl op} = \(C\sb{1}\;ty{}\sb{1}\sp{1}\ml{ => }\ldots\ml{ => }ty{}\sb{1}\sp{k\sb{1}} \) 
d108 1
a108 1
        | \(C\sb{m}\;ty{}\sb{m}\sp{1}\ml{=>}\ldots\ml{ => }ty{}\sb{m}\sp{k\sb{m}}\)`
d129 1
a129 1
The input parser for \ml{hol\_datatype} treats type expressions exactly as the
d135 2
a136 1
\WARNING The input syntax may cause some confusion, since
d139 6
a144 6
\begin{hol}\begin{alltt}
   `btree = LEAF of 'a
          | NODE of 'a btree => 'a btree`
\end{alltt}\end{hol}
really is defining a type of binary trees, since the second clause
is indicating that \ml{NODE} is a curried function, and not
d146 4
a149 4
\begin{hol}\begin{alltt}
   `btree = LEAF of 'a
          | NODE of 'a btree * 'a btree`
\end{alltt}\end{hol}
d151 1
d183 1
a183 1
\index{hol\_datatype@@\ml{hol\_datatype}}
d185 1
a185 1
   hol\_datatype `{\op} = \(C\sb{1}\;ty{}\sb{1}\sp{1}\ml{ => }\ldots\ml{ => }ty{}\sb{1}\sp{k\sb{1}} \)
d200 1
a200 1
\ml{hol\_datatype}, has the form shown below:
d223 1
a223 1
The call to \ml{hol\_datatype} shown above fails if:
d264 1
a264 1
The session that follows illustrates the use of \ml{hol\_datatype} in defining
d273 5
a277 1
- val three_Axiom = hol_datatype `three = ONE | TWO | THREE`;
d282 1
a282 1
\noindent The theorem returned by \ml{hol\_datatype} provides a complete 
d286 1
a286 1
degenerate "primitive recursion'
d289 1
a289 1
the theorem returned by \ml{hol\_datatype} simply
d301 1
a301 1
The next call to \ml{hol\_datatype} defines a `record type' \ml{rec}
d307 5
a311 1
- val rec_Axiom = hol_datatype `rec = REC of bool => bool => bool`;
d323 1
a323 1
\index{type definition package, in HOL system@@type definition package, in \HOL\ system!use of, to build number theory}, which can be defined using \ml{hol\_datatype} as follows:
d326 5
a330 1
- val nat_Axiom = hol_datatype `nat = Z | Suc of nat`;
d347 1
a347 1
appear only on leaf nodes, can likewise be defined using \ml{hol\_datatype}.
d353 5
a357 2
- val btree_Axiom = 
=     hol_datatype `btree = LEAF 'a | NODE of 'a btree => 'a btree`;
d365 1
a365 1
\noindent The result returned by the call to {\small \verb!hol_datatype!} is,
d368 1
a368 1
in the form of a "primitive recursion theorem' for the required
d372 1
a372 1
user-supplied equation using \ml{hol\_datatype} in exactly the same way.
d387 1
a387 1
\ml{hol\_datatype}\index{types, in HOL logic@@types, in \HOL\ logic!tools for construction of} (see Section~\ref{define-type-output}) this theorem
d427 4
a430 3
	 rec_axiom : thm,
	 def : term
       }; 
d435 1
a435 1
concrete recursive type of the kind definable by \ml{hol\_datatype}.
d439 1
a439 1
(\ie\ a theorem obtained from {\small\verb!hol_datatype!} or a theorem
d441 1
a441 1
e.g. \ml{num\_Axiom}).\index{hol_datatype@@\ml{hol\_datatype}}  \ml{name}
d453 1
a453 1
returned by \ml{hol\_datatype},
d458 1
a458 1
   new_recursive_definition {
d461 3
a463 2
     def=(--`{\normalsize\it primitive recursive definition on \op}`--)
   };
d503 1
a503 1
The first argument is a theorem of the form returned by \ml{hol\_datatype},
d517 1
a517 1
which have themselves been defined using \ml{hol\_datatype}.
d530 3
a532 2
=         def = (--`(Leaves (LEAF (x:'a)) = 1) /\
=                   (Leaves (NODE t1 t2) = (Leaves t1) + (Leaves t2))`--)
d558 4
a561 2
=         def = (--`(IsLeaf (NODE t1 t2) = F) /\ 
=                   (IsLeaf (LEAF (x:'a)) = T)`--);
d582 2
a583 1
=        def = (--`Label (LEAF (x:'a)) = x`--)
d595 1
a595 2
- hol_infix 300 "<<";
val Subtree = 
d599 1
a599 1
=        def = (--`(t << (LEAF x)     = F) /\
d601 2
a602 1
=                                        (t << t1) \/ (t << t2)))`--)
d623 1
a623 1
=             def = (--`(One ONE = T) /\ 
d625 3
a627 1
=                       (One THREE = F)`--);
d640 1
a640 1
=              (--`(f ONE = T) /\ (f TWO = F) /\ (f THREE = F)`--);
a663 1

d666 1
a666 1
recursive type defined using \ml{hol\_datatype}.  If the \ML\ 
d668 1
a668 1
returned by \ml{hol\_datatype}, 
d678 1
a678 1
of a theorem  returned by \ml{hol\_datatype}.
d742 1
a742 1
for any concrete types definable using \ml{hol\_datatype}.\index{hol_datatype@@\ml{hol\_datatype}}  The first argument
d760 1
a760 1
\ml{ (}\Gamma\ml{, (--`}t[ C_1\;x_1^1\;\ldots\;x_1^{k_1}]\ml{`--))},\\
d763 1
a763 1
\ml{ (}\Gamma\ml{, (--`}t[ C_m\;x_m^1\;\ldots\;x_m^{k_m}]\ml{`--))}
d784 2
a785 2
 {\small\verb%(%}$\Gamma${\small\verb%,(--`!%}$n${\small\verb%.%}$t[n]${\small\verb%`--))%} to a basis subgoal
{\small\verb%(%}$\Gamma${\small\verb%,(--`%}$t[${\small\verb%0%}$]${\small\verb%`--))%} 
d787 2
a788 2
{\small\verb%(%}$\Gamma\cup\{${\small\verb%(--`%}$t[n]${\small\verb%`--)%}$\}${\small\verb%,(--`%}$t[${\small\verb%SUC %}$n]${\small\verb%`--))%}.
The extra assumption  {\small\verb%(--`%}$t[n]${\small\verb%`--)%} (\ie\ the
d801 2
a802 2
 {\small\verb%(%}$\Gamma${\small\verb%,(--`!%}$n${\small\verb%.%}$t[n]${\small\verb%`--))%} to a basis subgoal
{\small\verb%(%}$\Gamma${\small\verb%,(--`%}$t[${\small\verb%0%}$]${\small\verb%`--))%} 
d804 1
a804 1
{\small\verb%(%}$\Gamma${\small\verb%, (--`%}$t[n]${\small\verb% ==> %}$t[${\small\verb%SUC %}$n]${\small\verb%`--))%}.
d837 1
a837 1
theorem of the form returned by \ml{hol\_datatype}.
d851 1
a851 1
a theorem of the form returned by \ml{hol\_datatype}.
d870 1
a870 1
\ml{hol\_datatype}.
d928 3
a930 1
<Konrad's package> - see appropriate library.
d934 2
a935 7
\subsection{The mutually recursive types definition package}

See the \ml{mutrec} library.

\subsection{The nested recursive types definition package}

See the \ml{nested-rec} contrib, and ask on info-hol.
d937 1
a937 1
\section{The inductive relations definition package}
d939 5
a943 1
See the \ml{ind\_def} library.
@
